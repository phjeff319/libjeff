#include<cmath>
#include<iomanip>
#include<iostream>
//#include<fstream>

###CUDA####include<cuda.h>
###CUDA####include"cuda_setting.h"
###CUDA####include"cuda_tools.h"

#include"geometry.h"

#include"debug_mode.h"
#include"earth.h"
#include"error_code.h"
#include"grid_data_field.h"
#include"math_special_function.h"
#include"physics_constants.h"
#include"polygon.h"
#include"sorting.h"
#include"tools.h"
#include"vector.h"

using namespace libjeff;
namespace libjeff{
  ###CPP### ###CUDA### ###HOST### int geometry_is_pt_inside_convex_polygon(int nside,double **vertices,double *point){
    double vec1[3], vec2[3], vec3[3];
    int i;
    
    bool zero = 0, positive = 0, negative = 0;
    
    for(i=0;i<nside-1;i++){
      vec1[0] = vertices[i+1][0] - vertices[i][0];
      vec1[1] = vertices[i+1][1] - vertices[i][1];
      vec1[2] = 0.;
      
      vec2[0] = point[0] - vertices[i][0];
      vec2[1] = point[1] - vertices[i][1];
      vec2[2] = 0.;
      
      vector_cross_pro(vec1,vec2,vec3);
      
      if(vec3[2] > c_zero){
	positive = 1;
      }
      else if(vec3[2] < -c_zero){
	negative = 1;
      }
      else{
	zero = 1;
      }
    }
    vec1[0] = vertices[0][0] - vertices[nside - 1][0];
    vec1[1] = vertices[0][1] - vertices[nside - 1][1];
    vec1[2] = 0.;
    
    vec2[0] = point[0] - vertices[nside-1][0];
    vec2[1] = point[1] - vertices[nside-1][1];
    vec2[2] = 0.;
    
    vector_cross_pro(vec1,vec2,vec3);
    
    if(vec3[2] > c_zero){
      positive = 1;
    }
    else if(vec3[2] < -c_zero){
      negative = 1;
    }
    else{
      zero = 1;
    }
    
    if(positive && negative && zero){ // on polygon
      return 0;
    }
    else if(positive && negative){ // outside polygon
      return 1;
    }
    else{ //inside polygon
      return -1;
    }
  }
/*
double ellipse_metric(double *center,double xwidth,double ywidth,double orient,double *point){
  orient *= ang_to_rad;
  return pow(2*(point[0]*cos(orient) - point[1]*sin(orient) - center[0])/xwidth,2.) + pow(2*(point[0]*sin(orient) + point[1]*cos(orient) - center[1])/ywidth,2.);
}
bool geometry_is_line_segment_touch_ellipse(double *center,double xwidth,double ywidth,double orient,double *point1,double *point2){
  //refers to ellipse_metric for the equation of the ellipse
  if(ellipse_metric(center,xwidth,ywidth,orient,point1) <= 1.){
    return 1;
  }
  else if(ellipse_metric(center,xwidth,ywidth,orient,point2) <= 1.){
    return 1;
  }
  else{
    orient *= ang_to_rad;
    double k1 = ((point1[0] - point2[0])*cos(orient) - (point1[1] - point2[1])*sin(orient))/xwidth;
    double k2 = ((point1[0] - point2[0])*sin(orient) + (point1[1] - point2[1])*cos(orient))/ywidth;
    double f1 = (point2[0]*cos(orient) - point2[1]*sin(orient) - center[0])/xwidth;
    double f2 = (point2[0]*sin(orient) + point2[1]*cos(orient) - center[1])/ywidth;
    double t = -(k1*f1 + k2*f2)/(k1*k1 + k2*k2);

    //cout << "t = " << t << endl;

    if(t < 0 || t > 1){
      return 0;
    }
    else {
      double *point = new double [2];
      point[0] = t*point1[0] + (1. - t)*point2[0];
      point[1] = t*point1[1] + (1. - t)*point2[1];

      //cout << ellipse_metric(center,xwidth,ywidth,orient/ang_to_rad,point) << endl;

      if(ellipse_metric(center,xwidth,ywidth,orient/ang_to_rad,point) <= 1){
	delete [] point;
	return 1;
      }
      else{
	delete [] point;
	return 0;
      }
    }
  }
}
*/
  ###CPP### ###CUDA### ###HOST### double ellipse_metric(double *center,double xwidth,double ywidth,double orient,double *point){
    orient *= ang_to_rad;
    return std::pow(2*((point[0] - center[0])*cos(orient) - (point[1] - center[1])*sin(orient))/xwidth,2.) + std::pow(2*((point[0] - center[0])*sin(orient) + (point[1] - center[1])*cos(orient))/ywidth,2.);
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_is_line_segment_touch_ellipse(double *center,double xwidth,double ywidth,double orient,double *point1,double *point2){
    //refers to ellipse_metric for the equation of the ellipse
    if(ellipse_metric(center,xwidth,ywidth,orient,point1) <= 1.){
      return 1;
    }
    else if(ellipse_metric(center,xwidth,ywidth,orient,point2) <= 1.){
      return 1;
    }
    else{
      orient *= ang_to_rad;
      double k1 = ((point1[0] - point2[0])*cos(orient) - (point1[1] - point2[1])*sin(orient))/xwidth;
      double k2 = ((point1[0] - point2[0])*sin(orient) + (point1[1] - point2[1])*cos(orient))/ywidth;
      double f1 = ((point2[0] - center[0])*cos(orient) - (point2[1] - center[1])*sin(orient))/xwidth;
      double f2 = ((point2[0] - center[0])*sin(orient) + (point2[1] - center[1])*cos(orient))/ywidth;
      double t = -(k1*f1 + k2*f2)/(k1*k1 + k2*k2);
      
      if(t < 0 || t > 1){
	return 0;
      }
      else {
	double *point = new double [2];
	point[0] = t*point1[0] + (1. - t)*point2[0];
	point[1] = t*point1[1] + (1. - t)*point2[1];
	
	if(ellipse_metric(center,xwidth,ywidth,orient/ang_to_rad,point) <= 1){
	  delete [] point;
	  return 1;
	}
	else{
	  delete [] point;
	  return 0;
	}
      }
    }
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_is_ellipse_overlap_convex_polygon(int nside,double **vertices,double *center,double xwidth,double ywidth,double orient){
    //(2*(x cos theta - y sin theta - xcenter)/xwidth)^2 + ((2*(x sin theta - y cos theta - ycenter)/xwidth)^2 = 1
    
    if(geometry_is_pt_inside_convex_polygon(nside,vertices,center)==-1){ //check if the center of the ellipse is inside the polygon
      return 1;
    }
    
    int i;
    
    double *vec1 = new double [2];
    double *vec2 = new double [2];
    bool inside = 0;
    //if not the above case, find the minimum in the ellipse metric and check if it lies between the two vertices and see if it is inside the ellipse
    for(i=0;i<nside;i++){
      vec1[0] = vertices[i][0];
      vec1[1] = vertices[i][1];
      
      if(i!=(nside-1)){
	vec2[0] = vertices[i+1][0];
	vec2[1] = vertices[i+1][1];
      }
      else{
	vec2[0] = vertices[0][0];
	vec2[1] = vertices[0][1];
      }
      
      inside = geometry_is_line_segment_touch_ellipse(center,xwidth,ywidth,orient,vec1,vec2);
      if(inside){
	break;
      }
    }
    
    delete [] vec1;
    delete [] vec2;
    return inside;
  }
  ###CPP### ###CUDA### ###HOST### double** geometry_cal_polygon_enclose_polygon(int num_vertices,double **polygon_be_enclosed,double **polygon_enclosing){
    int i,j,k,m;
    int back_index,cur_index,fore_index;
    
    double ***direction = new double **[2];
    direction[0] = new double *[2];
    direction[1] = new double *[2];
    direction[0][0] = new double [2];
    direction[0][1] = new double [2];
    direction[1][0] = new double [2];
    direction[1][1] = new double [2];
    
    double **polygon_dir = new double* [2];
    polygon_dir[0] = new double [2];
    polygon_dir[1] = new double [2];
    
    double **polygon_pt = new double* [2];
    polygon_pt[0] = new double [2];
    polygon_pt[1] = new double [2];
    
    for(i=0;i<num_vertices;i++){
      for(m=0;m<2;m++){
	back_index = i+m-1;
	while(back_index < 0){
	  back_index += num_vertices;
	}
	fore_index = i+m+1;
	while(fore_index >= num_vertices){
	  fore_index -= num_vertices;
	}
	cur_index = i+m;
	while(cur_index >= num_vertices){
	  cur_index -= num_vertices;
	}
	
	for(j=0;j<2;j++){
	  direction[m][0][j] = polygon_be_enclosed[fore_index][j] - polygon_be_enclosed[cur_index][j];
	  direction[m][1][j] = polygon_be_enclosed[cur_index][j] - polygon_be_enclosed[back_index][j];
	}
	for(j=0;j<2;j++){
	  double nom = std::pow(vector_dot_pro(2,direction[m][j],direction[m][j]),0.5);
	  
	  for(k=0;k<2;k++){
	    direction[m][j][k] /= nom;
	  }
	}
	
	for(j=0;j<2;j++){
	  polygon_dir[m][j] = 0.5*(direction[m][0][j] + direction[m][1][j]);
	  polygon_pt[m][j] = polygon_be_enclosed[cur_index][j];
	}
      }
      
      polygon_enclosing[i] = geometry_cal_2d_line_intersect(polygon_pt[0],polygon_dir[0],polygon_pt[1],polygon_dir[1],polygon_enclosing[i]);
    }
    
    delete [] direction[0][0];
    delete [] direction[0][1];
    delete [] direction[1][0];
    delete [] direction[1][1];
    delete [] direction[0];
    delete [] direction[1];
    delete [] direction;
    
    delete [] polygon_dir[0];
    delete [] polygon_dir[1];
    delete [] polygon_dir;
    
    delete [] polygon_pt[0];
    delete [] polygon_pt[1];
    delete [] polygon_pt;
    
    return polygon_enclosing;
  }
  
  ###CPP### ###CUDA### ###HOST### double *geometry_cal_2d_line_intersect(double *line1_pt,double *line1_dir,double *line2_pt,double *line2_dir,double *result){
    double b[2], solution[2];
    
    int i;
    for(i=0;i<2;i++){
      b[i] = line1_pt[i] - line2_pt[i];
    }
    
    double det= -line1_dir[0]*line2_dir[1] + line1_dir[1]*line2_dir[0];
    solution[0] = (b[0]*line2_dir[1] - b[1]*line2_dir[0])/det;
    
    for(i=0;i<2;i++){
      result[i] = line1_pt[i] + solution[0]*line1_dir[i];
    }
    //solution[1] = (-line1_dir[0]*b[1] + line1_dir[1]*b[0])/det;
    
    return result;
  }

  ###CPP### ###CUDA### ###HOST### double *geometry_cal_2d_line_segs_intersect(double *line1pt1,double *line1pt2,double *line2pt1,double* line2pt2,double *result){
    if(geometry_is_line_segs_intersect(line1pt1,line1pt2,line2pt1,line2pt2)){
      double *line1dir = new double [2];
      double *line2dir = new double [2];
      
      int i;
      for(i=0;i<2;i++){
	line1dir[i] = line1pt2[i] - line1pt1[i];
	line2dir[i] = line2pt2[i] - line2pt1[i];
      }
      
      geometry_cal_2d_line_intersect(line1pt1,line1dir,line2pt1,line2dir,result);
      
      delete [] line1dir;
      delete [] line2dir;
      
      return result;
    }
    else{
      return NULL;
    }
  }

  ###CPP### ###CUDA### ###HOST### bool geometry_is_lines_intersect_between(double *line1pt1,double *line1_dir,double *line2pt1,double* line2pt2){
    double *line2_dir = new double [2];

    int i;
    for(i=0;i<2;i++){
      line2_dir[i] = line2pt2[i] - line2pt1[i];
    }
    double det= -line1_dir[0]*line2_dir[1] + line1_dir[1]*line2_dir[0];
    bool result = true;

    if(fabs(det) < 1e-10){
      result = false;
    }
    /*
    double *intersect = new double [2];
    geometry_cal_2d_line_intersect(line1pt1,line1_dir,line2pt1,line2_dir,intersect);

    double value = (intersect[0] - line2pt2[0])/(line2pt1[0] - line2pt2[0]);


    bool result;
    if(value >= 0 && value <= 1){
      result = true;
    }
    else{
      result = false;
    }
    */
    if(result){
      double value1 = line1_dir[1]*line2pt1[0] - line1_dir[0]*line2pt1[1] - line1pt1[0]*line1_dir[1] + line1pt1[1]*line1_dir[0];
      double value2 = line1_dir[1]*line2pt2[0] - line1_dir[0]*line2pt2[1] - line1pt1[0]*line1_dir[1] + line1pt1[1]*line1_dir[0];

      if(value1*value2>0){
	result = false;
      }
    }

    delete [] line2_dir;
    //delete [] intersect;
    return result;
  }

  ###CPP### ###CUDA### ###HOST### bool geometry_is_line_segs_intersect(double *line1pt1,double *line1pt2,double *line2pt1,double* line2pt2){
    double *linedir = new double [2];
    
    bool result = false;
    int i;
    for(i=0;i<2;i++){
      linedir[i] = line1pt2[i] - line1pt1[i];
    }
    result = geometry_is_lines_intersect_between(line1pt1,linedir,line2pt1,line2pt2);
    
    if(result){
      for(i=0;i<2;i++){
	linedir[i] = line2pt2[i] - line2pt1[i];
      }
      result = geometry_is_lines_intersect_between(line2pt1,linedir,line1pt1,line1pt2);
    }
    
    delete [] linedir;
    return result;
  }
/*
  ###CUDA### ###HOST### bool have_contour_point(const grid_data_field* in,int value,int minx,int maxx,int miny,int maxy,int minz,int maxz){
    if(in->get_d_ngrid() > 0){
      if(in->d_max() < value || in->d_min() > value){
	return false;
      }
      else{
	return true;
      }
    }
    else{ 
      if(in->max(minx,maxx,miny,maxy,minz,maxz) < value || in->min(minx,maxx,miny,maxy,minz,maxz) > value){
	return false;
      }
      else{
	return true;
      }
    }
  }
*/
  ###CPP### ###CUDA### ###HOST### bool have_contour_point(const grid_data_field* in,int value,int minx,int maxx,int miny,int maxy,int minz,int maxz){
    if(in->max(minx,maxx,miny,maxy,minz,maxz) < value || in->min(minx,maxx,miny,maxy,minz,maxz) > value){
      return false;
    }
    else{
      return true;
    }
  }

  ###CPP### ###CUDA### ###HOST### int map_out_contour_segments(const grid_data_field* in,int z_index,double value,int &num_lines,double ***lines){
    int i,j;

    num_lines = 0;
    for(j=0;j<in->get_ny()-1;j++){ //map out all line segments of the contour
      for(i=0;i<in->get_nx()-1;i++){
	if(!have_root(*(in->get_data(i,j,z_index)),*(in->get_data(i+1,j,z_index)),*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){
	  continue;
	}

	if(*(in->get_data(i,j,z_index))==value || have_root(*(in->get_data(i,j,z_index)),*(in->get_data(i+1,j,z_index)),value)){ //one line segment found
	  lines[num_lines][0][0] = i+cal_frac(value,*(in->get_data(i,j,z_index)),*(in->get_data(i+1,j,z_index)));
	  //(value - *(in->get_data(i,j,z_index)))/(*(in->get_data(i+1,j,z_index)) - *(in->get_data(i,j,z_index)));
	  lines[num_lines][0][1] = j;
	  //fout << i << "\t" << j << "\t" << lines[num_lines][0][0] << "\t" << lines[num_lines][0][1] << "\t" << in->get_x(lines[num_lines][0][0],lines[num_lines][0][1],0.) << "\t" <<  in->get_y(lines[num_lines][0][0],lines[num_lines][0][1],0.);
	  
	  if(*(in->get_data(i,j+1,z_index))==value || *(in->get_data(i+1,j+1,z_index))==value || have_root(*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){ 
	    if(have_root(*(in->get_data(i,j,z_index)),*(in->get_data(i,j+1,z_index)),value)){
	      //std::cout << "+2 called: " << num_lines << " " << i << " " << j << " " << *(in->get_data(i,j,z_index)) << " " << *(in->get_data(i+1,j,z_index)) << " " << *(in->get_data(i,j+1,z_index)) << " " << *(in->get_data(i+1,j+1,z_index)) << endl;
	      lines[num_lines][1][0] = i;
	      lines[num_lines][1][1] = j+cal_frac(value,*(in->get_data(i,j,z_index)),*(in->get_data(i,j+1,z_index)));
		//(value - *(in->get_data(i,j,z_index)))/(*(in->get_data(i,j+1,z_index)) - *(in->get_data(i,j,z_index)));
	      //fout << "\t" << lines[num_lines][1][0] << "\t" << lines[num_lines][1][1] << "\t" << in->get_x(lines[num_lines][1][0],lines[num_lines][1][1],0.) << "\t" << in->get_y(lines[num_lines][1][0],lines[num_lines][1][1],0.) << endl;
	      
	      lines[num_lines+1][0][0] = i+cal_frac(value,*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)));
//(value - *(in->get_data(i,j+1,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i,j+1,z_index)));
	      lines[num_lines+1][0][1] = j+1;
	      
	      lines[num_lines+1][1][0] = i+1;
	      lines[num_lines+1][1][1] = j+cal_frac(value,*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)));
//(value - *(in->get_data(i+1,j,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i+1,j,z_index)));
	      //fout << i << "\t" << j << "\t" << lines[num_lines+1][0][0] << "\t" << lines[num_lines+1][0][1] << "\t" << in->get_x(lines[num_lines+1][0][0],lines[num_lines+1][0][1],0.) << "\t" <<  in->get_y(lines[num_lines+1][0][0],lines[num_lines+1][0][1],0.) << "\t" << lines[num_lines+1][1][0] << "\t" << lines[num_lines+1][1][1] << "\t" << in->get_x(lines[num_lines+1][1][0],lines[num_lines+1][1][1],0.) << "\t" << in->get_y(lines[num_lines+1][1][0],lines[num_lines+1][1][1],0.) << endl;
	      
	      num_lines+=2;
	    }
	    else{
	      lines[num_lines][1][0] = i+cal_frac(value,*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)));
		//(value - *(in->get_data(i,j+1,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i,j+1,z_index)));
	      lines[num_lines][1][1] = j+1;
	      //fout << "\t" << lines[num_lines][1][0] << "\t" << lines[num_lines][1][1] << "\t" << in->get_x(lines[num_lines][1][0],lines[num_lines][1][1],0.) << "\t" << in->get_y(lines[num_lines][1][0],lines[num_lines][1][1],0.) << endl;
	      
	      num_lines+=1;
	    }
	  }
	  else{
	    if(*(in->get_data(i+1,j,z_index))==value || *(in->get_data(i+1,j+1,z_index))==value || have_root(*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){
	      lines[num_lines][1][0] = i+1;
	      lines[num_lines][1][1] = j+cal_frac(value,*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)));
		//(value - *(in->get_data(i+1,j,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i+1,j,z_index)));
	    }
	    else{
	      lines[num_lines][1][0] = i;
	      lines[num_lines][1][1] = j+cal_frac(value,*(in->get_data(i,j,z_index)),*(in->get_data(i,j+1,z_index)));
	      //(value - *(in->get_data(i,j,z_index)))/(*(in->get_data(i,j+1,z_index)) - *(in->get_data(i,j,z_index)));
	    } 
	    //fout << "\t" << lines[num_lines][1][0] << "\t" << lines[num_lines][1][1] << "\t" << in->get_x(lines[num_lines][1][0],lines[num_lines][1][1],0.) << "\t" << in->get_y(lines[num_lines][1][0],lines[num_lines][1][1],0.) << endl;
	    
	    num_lines+=1;
	  }
	}
	else if(have_root(*(in->get_data(i,j,z_index)),*(in->get_data(i,j+1,z_index)),value)){
	  lines[num_lines][0][0] = i;
	  lines[num_lines][0][1] = j+cal_frac(value,*(in->get_data(i,j,z_index)),*(in->get_data(i,j+1,z_index)));
	    //(value - *(in->get_data(i,j,z_index)))/(*(in->get_data(i,j+1,z_index)) - *(in->get_data(i,j,z_index)));
	  if(*(in->get_data(i+1,j,z_index))==value || *(in->get_data(i+1,j+1,z_index))==value || have_root(*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){
	    lines[num_lines][1][0] = i+1;
	    lines[num_lines][1][1] = j+cal_frac(value,*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)));
	      //(value - *(in->get_data(i+1,j,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i+1,j,z_index)));
	  }
	  else{
	    lines[num_lines][1][0] = i+cal_frac(value,*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)));
	      //(value - *(in->get_data(i,j+1,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i,j+1,z_index)));
	    lines[num_lines][1][1] = j+1;
	  }
	  //fout << i << "\t" << j << "\t" << lines[num_lines][0][0] << "\t" << lines[num_lines][0][1] << "\t" << in->get_x(lines[num_lines][0][0],lines[num_lines][0][1],0.) << "\t" << in->get_y(lines[num_lines][0][0],lines[num_lines][0][1],0.) << "\t" << lines[num_lines][1][0] << "\t" << lines[num_lines][1][1] << "\t" << in->get_x(lines[num_lines][1][0],lines[num_lines][1][1],0.) << "\t" << in->get_y(lines[num_lines][1][0],lines[num_lines][1][1],0.) << endl;
	  num_lines+=1;
	}
	else if(*(in->get_data(i,j+1,z_index))==value || have_root(*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){
	  if(*(in->get_data(i+1,j,z_index))==value || *(in->get_data(i+1,j+1,z_index))==value || have_root(*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)),value)){
	    lines[num_lines][0][0] = i+cal_frac(value,*(in->get_data(i,j+1,z_index)),*(in->get_data(i+1,j+1,z_index)));
	      //(value - *(in->get_data(i,j+1,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i,j+1,z_index)));
	    lines[num_lines][0][1] = j+1;
	    
	    lines[num_lines][1][0] = i+1;
	    lines[num_lines][1][1] = j+cal_frac(value,*(in->get_data(i+1,j,z_index)),*(in->get_data(i+1,j+1,z_index)));
	      //(value - *(in->get_data(i+1,j,z_index)))/(*(in->get_data(i+1,j+1,z_index)) - *(in->get_data(i+1,j,z_index)));
	    //fout << i << "\t" << j << "\t" << lines[num_lines][0][0] << "\t" << lines[num_lines][0][1] << "\t" << in->get_x(lines[num_lines][0][0],lines[num_lines][0][1],0.) << "\t" << in->get_y(lines[num_lines][0][0],lines[num_lines][0][1],0.) << "\t" << lines[num_lines][1][0] << "\t" << lines[num_lines][1][1] << "\t" << in->get_x(lines[num_lines][1][0],lines[num_lines][1][1],0.) << "\t" << in->get_y(lines[num_lines][1][0],lines[num_lines][1][1],0.) << endl;
	    
	    num_lines+=1;
	  }
	}
	
	if(num_lines > 0 && lines[num_lines-1][0][0] == lines[num_lines-1][1][0] && lines[num_lines-1][0][1] == lines[num_lines-1][1][1]){
	  num_lines--;
	}
	
      }
    }

    return _ERRORCODE_NOERROR;
  }

  ###CUDA### ###GLOBAL### void geometry_extract_contour_cal_contour_pts_map_kernel(int nx,int ny,int nz,int ndim,int dim_index,double *data_grid,double value,int *contour_pts_map,int *contour_num_map){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int x_index = (i/(ny-1))%(nx-1);
    int y_index = (i)%(ny-1);
    int z_index = i/((nx-1)*(ny-1));

    if(z_index < nz){
      int bottom,top,left,right;
      
      bottom = ((value <= data_grid[((x_index+1)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index]) && (value >= data_grid[((x_index)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index])) || ((value >= data_grid[((x_index+1)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index]) && (value <= data_grid[((x_index)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index]));
      top = ((value <= data_grid[((x_index+1)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value >= data_grid[((x_index)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index])) || ((value >= data_grid[((x_index+1)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value <= data_grid[((x_index)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]));
      left = ((value <= data_grid[((x_index)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value >= data_grid[((x_index)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index])) || ((value >= data_grid[((x_index)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value <= data_grid[((x_index)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index]));
      right = ((value <= data_grid[((x_index+1)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value >= data_grid[((x_index+1)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index])) || ((value >= data_grid[((x_index+1)*ny*nz + (y_index+1)*nz + z_index)*ndim+dim_index]) && (value <= data_grid[((x_index+1)*ny*nz + (y_index)*nz + z_index)*ndim+dim_index]));

      contour_pts_map[i] = (bottom*8 + top*2 + left*4 + right);
      contour_num_map[i] = (bottom + top + left + right)/2;
    }
  }
  ###CUDA### ###HOST### int geometry_extract_contour_set_src_pts(const grid_data_field* in,double *x4line_pts,double *y4line_pts,double *src_value,int *h_contour_map){
    if((in->get_d_nx() != in->get_nx()) || (in->get_d_ny() != in->get_ny()) || (in->get_d_nz() != in->get_nz())){
      return _ERRORCODE_INPUTINCONSISTENCE;
    }
    
    int i;
    int line_index,struct_index;
    int x_index,y_index,z_index;
    for(i=0;i<(in->get_d_nx()-1)*(in->get_d_ny()-1)*in->get_d_nz();i++){
      line_index = h_contour_map[i]/100;
      struct_index = h_contour_map[i]%100;
      
      if(struct_index > 0){
	x_index = (i/((in->get_d_ny()-1)))%(in->get_d_nx()-1);
	y_index = (i)%(in->get_d_ny()-1);
	z_index = i/((in->get_d_ny()-1)*(in->get_d_nx()-1));

	int flag = 0;
	if(struct_index >= 8){ //bottom
	  x4line_pts[line_index*4] = in->get_x(x_index,y_index,z_index);
	  x4line_pts[line_index*4+1] = in->get_x(x_index+1,y_index,z_index);
	  
	  y4line_pts[line_index*4] = in->get_y(x_index,y_index,z_index);
	  y4line_pts[line_index*4+1] = in->get_y(x_index+1,y_index,z_index);
	  
	  src_value[line_index*4] = *in->get_data(x_index,y_index,z_index);
	  src_value[line_index*4+1] = *in->get_data(x_index+1,y_index,z_index);
	  flag += 2;
	  struct_index = struct_index%8;
	}
	if(struct_index >= 4){ //left
	  x4line_pts[line_index*4+flag] = in->get_x(x_index,y_index,z_index);
	  x4line_pts[line_index*4+flag+1] = in->get_x(x_index,y_index+1,z_index);
	  
	  y4line_pts[line_index*4+flag] = in->get_y(x_index,y_index,z_index);
	  y4line_pts[line_index*4+flag+1] = in->get_y(x_index,y_index+1,z_index);
	  
	  src_value[line_index*4+flag] = *in->get_data(x_index,y_index,z_index);
	  src_value[line_index*4+flag+1] = *in->get_data(x_index,y_index+1,z_index);
	  flag += 2;
	  struct_index = struct_index%4;
	}
	if(struct_index >= 2){ //top
	  x4line_pts[line_index*4+flag] = in->get_x(x_index,y_index+1,z_index);
	  x4line_pts[line_index*4+flag+1] = in->get_x(x_index+1,y_index+1,z_index);
	  
	  y4line_pts[line_index*4+flag] = in->get_y(x_index,y_index+1,z_index);
	  y4line_pts[line_index*4+flag+1] = in->get_y(x_index+1,y_index+1,z_index);
	  
	  src_value[line_index*4+flag] = *in->get_data(x_index,y_index+1,z_index);
	  src_value[line_index*4+flag+1] = *in->get_data(x_index+1,y_index+1,z_index);
	  flag += 2;
	  struct_index = struct_index%2;
	}
	if(struct_index >= 1){ //right
	  x4line_pts[line_index*4+flag] = in->get_x(x_index+1,y_index,z_index);
	  x4line_pts[line_index*4+flag+1] = in->get_x(x_index+1,y_index+1,z_index);
	  
	  y4line_pts[line_index*4+flag] = in->get_y(x_index+1,y_index,z_index);
	  y4line_pts[line_index*4+flag+1] = in->get_y(x_index+1,y_index+1,z_index);
	  
	  src_value[line_index*4+flag] = *in->get_data(x_index+1,y_index,z_index);
	  src_value[line_index*4+flag+1] = *in->get_data(x_index+1,y_index+1,z_index);
	}
      }
    }
    return _ERRORCODE_NOERROR;
  }

  ###CUDA### ###GLOBAL### void geometry_extract_contour_cal_line_pts(int num_line,double *x_line_src_pts,double *y_line_src_pts,double *src_value,double value,double *x_line_pts,double *y_line_pts){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int task_index = i/(num_line*2);
    int pt_index = i%(num_line*2);
    
    if(task_index < 2){
      double frac = (value - src_value[pt_index*2+1])/(src_value[pt_index*2] - src_value[pt_index*2+1]);
      if(task_index == 0){
	x_line_pts[pt_index] = x_line_src_pts[pt_index*2]*frac + (1-frac)*x_line_src_pts[pt_index*2+1];
      }
      else{
	y_line_pts[pt_index] = y_line_src_pts[pt_index*2]*frac + (1-frac)*y_line_src_pts[pt_index*2+1];
      }
    }
  }
  ###CUDA### ###GLOBAL### void geometry_line_is_zero_legnth(int num_lines,double *x_line_pts,double *y_line_pts,bool *is_zero_legnth){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    if(i<num_lines){
      is_zero_legnth[i] = ((x_line_pts[2*i] == x_line_pts[2*i+1]) && (y_line_pts[2*i] == y_line_pts[2*i+1]));
    }
  }

  ###CUDA### ###GLOBAL### void geometry_extract_contour_match_lines(int max_num_line_in_level,int nlevel,int match_index,int *num_lines_in_level,int *offset,double *x_line_pts,double *y_line_pts,bool* is_zero_length,int *contour_mapping){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    int task_index = i/(max_num_line_in_level*nlevel);
    int line_pt_index = task_index%2;
    int match_pt_index = task_index/2;

    int line_index = i%(max_num_line_in_level*nlevel);
    int level_index = line_index/max_num_line_in_level;
    line_index = line_index%max_num_line_in_level;

    if(match_pt_index < 2){
      if(line_index < num_lines_in_level[level_index] && match_index < num_lines_in_level[level_index]){
	if(!is_zero_length[match_index+offset[level_index]] && !is_zero_length[line_index+offset[level_index]]){
	  if(line_index != match_index){
	    if(x_line_pts[(line_index+offset[level_index])*2+line_pt_index]==x_line_pts[(match_index+offset[level_index])*2+match_pt_index] && y_line_pts[(line_index+offset[level_index])*2+line_pt_index]==y_line_pts[(match_index+offset[level_index])*2+match_pt_index]){
	      if(contour_mapping[(line_index+offset[level_index])*2+line_pt_index]==-1){
		contour_mapping[(line_index+offset[level_index])*2+line_pt_index] = 2*(match_index+offset[level_index])+match_pt_index;
	      }
	      else{
		contour_mapping[(line_index+offset[level_index])*2+line_pt_index] = -2;
	      }
	    }
	  }
	}
      }
    }
  }

  ###CUDA### ###GLOBAL### void geometry_extract_contour_match_lines(int nx,int ny,int nz,int *contour_map,int *contour_mapping){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    int task_index = i/((nx-1)*(ny-1)*(nz));

    int pt_index = i;
    int y_index = pt_index%(ny-1);
    int x_index = (pt_index/(ny-1))%(nx-1);

    int line_index = contour_map[pt_index]/100;
    int struct_index = contour_map[pt_index]%100;
    int target_index, target_struct, match_index;
    if(task_index < 1 && struct_index > 0){
      int flag = 0;

      if(struct_index >= 8){ //bottom
	if(y_index > 0){
	  target_index = pt_index - 1;
	  target_struct = contour_map[target_index]%100;
	  match_index = target_struct/8 + (target_struct%8)/4;
	  contour_mapping[2*line_index] = 2*(contour_map[target_index]/100)+match_index;
	}

	flag += 1;
	struct_index = struct_index%8;
      }
      if(struct_index >= 4){ //left
	if(x_index > 0){
	  target_index = pt_index - (ny-1);
	  target_struct = contour_map[target_index]%100;
	  match_index = target_struct/8 + (target_struct%8)/4 + (target_struct%4)/2;
	  contour_mapping[2*line_index+flag] = 2*(contour_map[target_index]/100)+match_index;
	}

	flag += 1;
	struct_index = struct_index%4;
      }
      if(struct_index >= 2){ //top
	if(y_index < ny-2){
	  target_index = pt_index + 1;
	  contour_mapping[2*line_index+flag] = 2*(contour_map[target_index]/100);
	}

	flag += 1;
	struct_index = struct_index%2;
      }
      if(struct_index >= 1){ //right
	if(x_index < nx-2){
	  target_index = pt_index + (ny-1);
	  target_struct = contour_map[target_index]%100;
	  match_index = target_struct/8;
	  contour_mapping[2*line_index+flag] = 2*(contour_map[target_index]/100)+match_index;
	}
      }
    }
  }

  ###CUDA### ###HOST### int geometry_extract_contour(const grid_data_field* in,int num_zindex,int *z_index,int num_value,double *value,int **num_polygon,polygon<double>***& contours){
    //This subroutine assume you can store the whole data array onto the GPU. If not, please get a better GPU or upgrade this code.  The code assume the data has been moved to the GPU by the user before calling this subroutine
    int i,j,k,m,n;
    for(i=0;i<num_zindex;i++){
      if(z_index[i] < 0 || z_index[i] >= in->get_d_nz()){
	return _ERRORCODE_INPUTOUTOFRANGE;
      }
    }

    if((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()) <= 0){
      //cout << "Error! GPU data missing." << endl;
      return _ERRORCODE_GPUDATAYETTOBEINITIATED;
    }

    int *contour_map, *contour_num_map;
    int *h_contour_map, *h_contour_num_map;
    cudaMalloc(&contour_num_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int));
    cudaMalloc(&contour_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int));
    cudaHostAlloc(&h_contour_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int),cudaHostAllocDefault);
    cudaHostAlloc(&h_contour_num_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int),cudaHostAllocDefault);

    int numthreads = cuda_setting::get_numthreads();
    dim3 grid;
    int num_lines;

    int *num_lines_in_level, *h_offset;
    cudaHostAlloc(&num_lines_in_level,in->get_d_nz()*sizeof(int),cudaHostAllocDefault);
    cudaHostAlloc(&h_offset,in->get_d_nz()*sizeof(int),cudaHostAllocDefault);
    int *d_num_lines_in_level,*offset;
    cudaMalloc(&d_num_lines_in_level,in->get_d_nz()*sizeof(int));
    cudaMalloc(&offset,in->get_d_nz()*sizeof(int));

    double *h_x_line_src_pts,*x_line_src_pts;
    double *h_src_value,*src_value;
    //This memory allocation may not be enough. It is only half of the worst case
    cudaHostAlloc(&h_x_line_src_pts,8*((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(double),cudaHostAllocDefault);
//cudaHostAlloc(&h_x_line_src_pts,4*((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(double),cudaHostAllocDefault);
    cudaHostAlloc(&h_src_value,4*((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(double),cudaHostAllocDefault);
    double *h_y_line_src_pts,*y_line_src_pts;

    double *x_line_pts, *y_line_pts;
    double *h_x_line_pts, *h_y_line_pts;
    double *temp_vertex1 = new double [2];
    double *temp_vertex2 = new double [2];

    int segment_index,vertex_index,new_segment_index,new_vertex_index;

    int error = _ERRORCODE_NOERROR;

    bool* is_zero_length;
    int *contour_mapping, *h_contour_mapping,max_num_line_in_level;

    for(i=0;i<num_value;i++){ //working on individual contour values
      grid.x = (int) ceil(((double) ((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz())))/numthreads);

      geometry_extract_contour_cal_contour_pts_map_kernel<<<grid,numthreads>>>(in->get_d_nx(),in->get_d_ny(),in->get_d_nz(),in->get_grid_data()->get_d_ndim(),in->get_dim_index(),in->get_grid_data()->get_d_data(),value[i],contour_map,contour_num_map);
      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed@geometry_extract_contour.geometry_extract_contour_cal_contour_pts_map_kernel. " << cudaGetErrorString(cudaGetLastError()) << endl;
      
      num_lines = cuda_reduce(((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz())),contour_num_map);
      if(num_lines > ((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))){
	//cout << "Error! Code not designed to allocate enough memory for this case." << endl;
	return _ERRORCODE_NOTIMPLEMENTED;
      }
      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed@geometry_extract_contour.cuda_reduce " << cudaGetErrorString(cudaGetLastError()) << endl;
      //cout << "Contour value: " << value[i] << " number of lines = " << num_lines << endl;//"\n";

      if(num_lines > 0){
	cudaMemcpy(h_contour_map,contour_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int),cudaMemcpyDeviceToHost);
	cudaMemcpy(h_contour_num_map,contour_num_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int),cudaMemcpyDeviceToHost);
	k=0;
	for(j=0;j<((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()));j++){
	  h_contour_map[j]+=k*100;
	  k+=h_contour_num_map[j];
	  //if(h_contour_num_map[j] > 0){
	  //cout << j/((in->get_d_nx()-1)*(in->get_d_ny()-1)) << " " << (j/(in->get_d_ny()-1))%(in->get_d_nx()-1) << " " << j%(in->get_d_ny()-1) << " " << h_contour_map[j] << endl;;
	  //}
	}
	//cout << endl;
	cudaMemcpy(contour_map,h_contour_map,((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz()))*sizeof(int),cudaMemcpyHostToDevice);
	
	h_y_line_src_pts = h_x_line_src_pts+4*num_lines;
	
	error = geometry_extract_contour_set_src_pts(in,h_x_line_src_pts,h_y_line_src_pts,h_src_value,h_contour_map);
	if(error == _ERRORCODE_INPUTINCONSISTENCE){
	  cout << "Error! Dimension of GPU data different from CPU data." << endl;
	  return error;
	}
	//cout << "Done host src points set." << endl;
	
	cudaMalloc(&x_line_src_pts,8*num_lines*sizeof(double));
	cudaMalloc(&src_value,4*num_lines*sizeof(double));
	y_line_src_pts = x_line_src_pts+4*num_lines;
	cudaMemcpy(x_line_src_pts,h_x_line_src_pts,8*num_lines*sizeof(double),cudaMemcpyHostToDevice);
	cudaMemcpy(src_value,h_src_value,4*num_lines*sizeof(double),cudaMemcpyHostToDevice);
	
	//for(k=0;k<4*num_lines;k++){
	  //cout << h_x_line_src_pts[k] << " " << h_y_line_src_pts[k] << " " << h_src_value[k] << endl;
	//}
	
	//cout << "Done memcpy to device." << endl;
	
	cudaMalloc(&x_line_pts,2*num_lines*sizeof(double));
	cudaMalloc(&y_line_pts,2*num_lines*sizeof(double));
	
	grid.x = (int) ceil(((double) (4*num_lines)/numthreads));
	geometry_extract_contour_cal_line_pts<<<grid,numthreads>>>(num_lines,x_line_src_pts,y_line_src_pts,src_value,value[i],x_line_pts,y_line_pts);
	cudaFree(x_line_src_pts);
	cudaFree(src_value);

	h_x_line_pts = new double [2*num_lines];
	h_y_line_pts = new double [2*num_lines];
	
	cudaMemcpy(h_x_line_pts,x_line_pts,2*num_lines*sizeof(double),cudaMemcpyDeviceToHost);
	cudaMemcpy(h_y_line_pts,y_line_pts,2*num_lines*sizeof(double),cudaMemcpyDeviceToHost);
	
	//for(k=0;k<2*num_lines;k++){
	  //cout << h_x_line_pts[k] << " " << h_y_line_pts[k] << endl;
	//}
	
	//grid.x = (int) ceil(((double) (num_lines)/numthreads));
	//cudaMalloc(&is_zero_length,num_lines*sizeof(bool));
	//geometry_line_is_zero_legnth<<<grid,numthreads>>>(num_lines,x_line_pts,y_line_pts,is_zero_length);
	
	//cout << "Done calculate line points" << endl;
	max_num_line_in_level = 0;
	h_offset[0] = 0;
	for(k=0;k<(in->get_d_nz());k++){
	  num_lines_in_level[k]=0;
	  for(j=0;j<((in->get_d_nx()-1)*(in->get_d_ny()-1));j++){
	    num_lines_in_level[k]+=h_contour_num_map[k*((in->get_d_nx()-1)*(in->get_d_ny()-1)) + j];
	  }
	  if(num_lines_in_level[k] > max_num_line_in_level){
	    max_num_line_in_level = num_lines_in_level[k];
	  }
	  if(k!=(in->get_d_nz()-1)){
	    h_offset[k+1] = h_offset[k]+num_lines_in_level[k];
	  }
	}
	//cout << "Done calculating max_num_line_in_level = " << max_num_line_in_level << endl;
	
	//cudaMemcpy(d_num_lines_in_level,num_lines_in_level,in->get_d_nz()*sizeof(int),cudaMemcpyHostToDevice);
	//cudaMemcpy(offset,h_offset,in->get_d_nz()*sizeof(int),cudaMemcpyHostToDevice);
	//cout << "Done copying data back to Host." << endl;

	cudaMalloc(&contour_mapping,num_lines*2*sizeof(int));
	grid.x = (int) ceil(((double) (num_lines*2))/numthreads);
	cuda_set_value<<<grid,numthreads>>>(num_lines*2,contour_mapping,-1);

	/*
	grid.x = (int) ceil(((double) (max_num_line_in_level*(in->get_d_nz())*4))/numthreads);
	for(j=0;j<max_num_line_in_level;j++){
	  geometry_extract_contour_match_lines<<<grid,numthreads>>>(max_num_line_in_level,in->get_d_nz(),j,d_num_lines_in_level,offset,x_line_pts,y_line_pts,is_zero_length,contour_mapping);
	}
	*/
	
	grid.x = (int) ceil(((double) ((in->get_d_nx()-1)*(in->get_d_ny()-1)*(in->get_d_nz())))/numthreads);
	geometry_extract_contour_match_lines<<<grid,numthreads>>>(in->get_d_nx(),in->get_d_ny(),in->get_d_nz(),contour_map,contour_mapping);
	
	//cout << "Done contour matching." << endl;

	//cudaFree(is_zero_length);
	cudaFree(x_line_pts);
	cudaFree(y_line_pts);

	h_contour_mapping = new int[num_lines*2];
	cudaMemcpy(h_contour_mapping,contour_mapping,2*num_lines*sizeof(int),cudaMemcpyDeviceToHost);

	cudaFree(contour_mapping);

	//cout << "Translating matching map to polygons." << endl;

	bool workon;
	for(j=0;j<in->get_d_nz();j++){
	  workon = false;
	  for(k=0;k<num_zindex;k++){
	    if(z_index[k]==j){
	      workon = true;
	      break;
	    }
	  }

	  if(workon){
	    if(num_lines_in_level[j]>0){
	      int temp_num_polygon = 1000;
	      int curr_num_polygon = 0;
	      
	      if(contours[i][k] != NULL){
		//cout << "Deleting previously allocated memory." << endl;
		delete [] contours[i][k];
	      }
	      polygon<double> *temp_contours = new polygon<double> [temp_num_polygon];
	      //contours[i][k] = new polygon<double> [temp_num_polygon];
	      //cout << j << " " << num_lines_in_level[j] << endl;
	      bool *used = new bool [num_lines_in_level[j]];
	      for(m=0;m<num_lines_in_level[j];m++){ //keep track of usage of individual segment
		used[m] = false;
		/*
		if((h_x_line_pts[(h_offset[j]+m)*2] == h_x_line_pts[(h_offset[j]+m)*2+1]) && (h_y_line_pts[(h_offset[j]+m)*2] == h_y_line_pts[(h_offset[j]+m)*2+1])){
		  used[m] = true;
		}
		*/
	      }

	      //cout << "Done checking for lines with zero length" << endl;
	      
	      for(m=0;m<num_lines_in_level[j];m++){
		if(used[m]){
		  continue;
		}

		//cout << "Working on: " << curr_num_polygon << " " << m << "/" << num_lines_in_level[j] << endl;
		
		temp_vertex1[0] = h_x_line_pts[(h_offset[j]+m)*2];
		temp_vertex1[1] = h_y_line_pts[(h_offset[j]+m)*2];
		temp_contours[curr_num_polygon].add_vertex(0,temp_vertex1);
		temp_vertex2[0] = h_x_line_pts[(h_offset[j]+m)*2+1];
		temp_vertex2[1] = h_y_line_pts[(h_offset[j]+m)*2+1];
		temp_contours[curr_num_polygon].add_vertex(-1,temp_vertex2);    
		
		used[m] = true;
		vertex_index = 0;
		segment_index = m;
		while(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] != -1){
		  /*
		  if(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] <= -2){
		    cout << "Bug found in matching lines. Please check." << endl;
		  }
		  else if(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] >= 2*num_lines){
		    cout << "Bug found in matching lines (Pointing out of bound). Please check." << endl;
		    cout << "----------------Debug info----------------" << endl;
		    cout << num_lines << " " << h_offset[j]+segment_index << " " << vertex_index << " " << h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] << endl;
		    cout << num_lines << " " << h_offset[j]+segment_index << " " << !vertex_index << " " << h_contour_mapping[(h_offset[j]+segment_index)*2+(!vertex_index)] << endl;
		  }
		  */
		  new_segment_index = h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index]/2 - h_offset[j];
		  if(used[new_segment_index]){
		    break;
		  }
		  new_vertex_index = !(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index]%2);
		  segment_index = new_segment_index;
		  vertex_index = new_vertex_index;
		  
		  temp_vertex1[0] = h_x_line_pts[(h_offset[j]+segment_index)*2+vertex_index];
		  temp_vertex1[1] = h_y_line_pts[(h_offset[j]+segment_index)*2+vertex_index];
		  temp_contours[curr_num_polygon].add_vertex(0,temp_vertex1);
		  used[segment_index] = true;
		}
		
		segment_index = m;
		vertex_index = 1;
		while(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] != -1){
		  /*
		  if(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] <= -2){
		    cout << "Bug found in matching lines. Please check." << endl;
		  }
		  else if(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] >= 2*num_lines){
		    cout << "Bug found in matching lines (Pointing out of bound). Please check." << endl;
		    cout << "----------------Debug info----------------" << endl;
		    cout << num_lines << " " << h_offset[j]+segment_index << " " << vertex_index << " " << h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index] << endl;
		    cout << num_lines << " " << h_offset[j]+segment_index << " " << !vertex_index << " " << h_contour_mapping[(h_offset[j]+segment_index)*2+(!vertex_index)] << endl;
		  }
		  */
		  new_segment_index = h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index]/2 - h_offset[j];
		  if(used[new_segment_index]){
		    break;
		  }
		  new_vertex_index = !(h_contour_mapping[(h_offset[j]+segment_index)*2+vertex_index]%2);
		  segment_index = new_segment_index;
		  vertex_index = new_vertex_index;
		  
		  temp_vertex1[0] = h_x_line_pts[(h_offset[j]+segment_index)*2+vertex_index];
		  temp_vertex1[1] = h_y_line_pts[(h_offset[j]+segment_index)*2+vertex_index];
		  
		  temp_contours[curr_num_polygon].add_vertex(-1,temp_vertex1);
		  used[segment_index] = true;
		}

		curr_num_polygon++;
		if(curr_num_polygon == temp_num_polygon){ //memory space doubling
		  //cout << "Doubling the polygon memory space" << endl;
		  polygon<double> *new_contour = new polygon<double> [2*temp_num_polygon];
		  for(n=0;n<curr_num_polygon;n++){
		    new_contour[n] = temp_contours[n];
		  }
		  delete [] temp_contours;
		  temp_contours = new_contour;
		  temp_num_polygon *= 2;
		}
	      }
	      num_polygon[i][k] = curr_num_polygon;
	      //cout << "Trimming polygon memory space." << endl;
	      
	      contours[i][k] = new polygon<double> [num_polygon[i][k]];
	      for(n=0;n<num_polygon[i][k];n++){
		contours[i][k][n] = temp_contours[n];
	      }
	      
	      delete [] temp_contours;
	      
	      delete [] used;
	      //cout << "Done trimming memory space." << endl;
	    }
	    else{
	      num_polygon[i][k] = 0;
	    }

	  }
	}
	
	//cout << "Done copying back to host." << endl;
	delete [] h_x_line_pts;
	delete [] h_y_line_pts;
	delete [] h_contour_mapping;
      }
      else{
	for(k=0;k<num_zindex;k++){
	  num_polygon[i][k] = 0;
	}
      }
    }

    cudaFreeHost(num_lines_in_level);
    cudaFree(d_num_lines_in_level);
    delete [] temp_vertex1;
    delete [] temp_vertex2;
    
    cudaFreeHost(h_offset);
    cudaFree(offset);

    cudaFreeHost(h_src_value);
    cudaFreeHost(h_x_line_src_pts);
    cudaFreeHost(h_contour_map);
    cudaFreeHost(h_contour_num_map);
    cudaFree(contour_map);
    cudaFree(contour_num_map);
/*
    cudaFree(d_x);
    cudaFree(d_y);
    cudaFree(d_z);
*/
//cudaFree(x);
//cudaFree(y);
     
    return error;
  }
  ###CPP### ###CUDA### ###HOST### int geometry_extract_contour(const grid_data_field* in,double value,int &num_polygon,polygon<double>*& contours){
    return geometry_extract_contour(in,0,value,num_polygon,contours);
  }
  ###CPP### ###CUDA### ###HOST### int geometry_extract_contour(const grid_data_field* in,int z_index,double value,int &num_polygon,polygon<double>*& contours){
    if(z_index < 0 || z_index >= in->get_nz()){
      return _ERRORCODE_INPUTOUTOFRANGE;
    }
    if(contours!=NULL){
      delete [] contours;
      contours = NULL;
    }
    
    if(!have_contour_point(in,value,0,in->get_nx()-1,0,in->get_ny()-1,z_index,z_index)){
      num_polygon = 0; //no contour found. Just return
    }
    else{
      int i,j,k,m;
      int temp_num_polygon = 1000;
      int curr_num_polygon = 0;
      //bool repeat;
      polygon<double> *temp_contour = new polygon<double> [temp_num_polygon];
      
      double ***lines = new double **[(in->get_nx()-1)*(in->get_ny()-1)];
      for(i=0;i<(in->get_nx()-1)*(in->get_ny()-1);i++){
	lines[i] = new double *[2];
	for(j=0;j<2;j++){
	  lines[i][j] = new double [2];
	}
      }

      //std::ofstream fout;
      //fout.open("geometry.extract_polygon.log");
      int num_lines;
      map_out_contour_segments(in,z_index,value,num_lines,lines);
      //fout.close();
      //cout << num_lines << endl;
      
      bool *used = new bool [num_lines];
      for(i=0;i<num_lines;i++){ //keep track of usage of individual segment
	used[i] = false;
      }
      
      //bool done = false;
      bool found = false;
      //int min_unused = 0, max_unused = num_lines-1;
      for(j=0;j<num_lines;j++){
	//while(!done){ //assemble
	//for(i=j;i<num_lines;i++){
	  //	for(i=min_unused;i<=max_unused;i++){
	  if(used[j]){
	    continue;
	  }
	  //}
	
	temp_contour[curr_num_polygon].add_vertex(0,lines[j][0]);
	temp_contour[curr_num_polygon].add_vertex(1,lines[j][1]);
	//      cout << temp_contour[curr_num_polygon].get_vertices(0)[0] << " " << temp_contour[curr_num_polygon].get_vertices(0)[1] << endl;
	//      cout << temp_contour[curr_num_polygon].get_vertices(-1)[0] << " " << temp_contour[curr_num_polygon].get_vertices(-1)[1] << endl;
	//      cout << "---------------- " << curr_num_polygon << " ----------------" << endl;
	used[j] = true;
	
	do{
	  found = false;
	  for(i=0;i<num_lines;i++){
	  //for(i=min_unused;i<=max_unused;i++){
	    if(!used[i]){
	      //cout << i << " " << lines[i][0][0] << " " << lines[i][0][1] << endl;
	      //cout << i << " " << lines[i][1][0] << " " << lines[i][1][1] << endl;
	      if(vector_isequal(2,lines[i][0],temp_contour[curr_num_polygon].get_vertices(0))){
		m = 1; //line segment point index
		k = 0; //matching vertex index
		found = true;
	      }
	      else if(vector_isequal(2,lines[i][0],temp_contour[curr_num_polygon].get_vertices(-1))){
		m = 1; //line segment point index
		k = -1; //matching vertex index
		found = true;
	      }
	      else if(vector_isequal(2,lines[i][1],temp_contour[curr_num_polygon].get_vertices(0))){
		m = 0; //line segment point index
		k = 0; //matching vertex index
		found = true;
	      }
	      else if(vector_isequal(2,lines[i][1],temp_contour[curr_num_polygon].get_vertices(-1))){
		m = 0; //line segment point index
		k = -1; //matching vertex index
		found = true;
	      }
	      
	      if(found){
		//cout << "found: " << i << " " << m << " " << k << endl;
		temp_contour[curr_num_polygon].add_vertex(k,lines[i][m]);
		used[i] = true;
		break;
	      }
	    }
	  }
	}while(found);
	
	curr_num_polygon++;
	if(curr_num_polygon == temp_num_polygon){ //memory space doubling
	  polygon<double> *new_contour = new polygon<double> [2*temp_num_polygon];
	  for(i=0;i<curr_num_polygon;i++){
	    new_contour[i] = temp_contour[i];
	  }
	  delete [] temp_contour;
	  temp_contour = new_contour;
	  temp_num_polygon *= 2;
	}
	/*
	for(i=min_unused;i<=max_unused;i++){
	  if(!used[i]){
	    min_unused = i;
	    break;
	  }
	}
	for(i=max_unused;i>=min_unused;i--){
	  if(!used[i]){
	    max_unused = i;
	    break;
	  }
	}
	*/
	/*
	done = true;
	for(i=0;i<num_lines;i++){
	  //for(i=min_unused;i<=max_unused;i++){
	  if(!used[i]){
	    done = false;
	  }
	}
	*/
      }
      
      for(i=0;i<(in->get_nx()-1)*(in->get_ny()-1);i++){
	for(j=0;j<2;j++){
	  delete [] lines[i][j];
	}
	delete [] lines[i];
      }
      delete [] lines;
      delete [] used;
      
      double *vertex = new double [2];
      contours = new polygon<double> [curr_num_polygon];
      for(i=0;i<curr_num_polygon;i++){ //translation from integer indexing to real coordinates
	for(j=0;j<temp_contour[i].get_num_vertices();j++){
	  /*
	    if((temp_contour[i].get_vertices(j))[0]%2){
	    vertex[0] = 0.5*(in->get_x((temp_contour[i].get_vertices(j))[0]/2,(temp_contour[i].get_vertices(j))[1]/2,0) + in->get_x((temp_contour[i].get_vertices(j))[0]/2+1,(temp_contour[i].get_vertices(j))[1]/2,0));
	    }
	    else{
	    vertex[0] = in->get_x((temp_contour[i].get_vertices(j))[0]/2,(temp_contour[i].get_vertices(j))[1]/2,0);
	    }
	    if((temp_contour[i].get_vertices(j))[1]%2){
	    vertex[1] = 0.5*(in->get_y((temp_contour[i].get_vertices(j))[0]/2,(temp_contour[i].get_vertices(j))[1]/2,0) + in->get_y((temp_contour[i].get_vertices(j))[0]/2,(temp_contour[i].get_vertices(j))[1]/2+1,0));
	    }
	    else{
	    vertex[1] = in->get_y((temp_contour[i].get_vertices(j))[0]/2,(temp_contour[i].get_vertices(j))[1]/2,0);
	    }
	  */
	  //std::cout << (temp_contour[i].get_vertices(j))[0] << " " << (temp_contour[i].get_vertices(j))[1] << endl;
	  vertex[0] = in->get_x((temp_contour[i].get_vertices(j))[0],(temp_contour[i].get_vertices(j))[1],(double) z_index);
	  vertex[1] = in->get_y((temp_contour[i].get_vertices(j))[0],(temp_contour[i].get_vertices(j))[1],(double) z_index);
	  contours[i].add_vertex(-1,vertex);
	}
	//std::cout << endl;
      }
      delete [] vertex;  
      
      delete [] temp_contour;
      
      num_polygon = curr_num_polygon;
    }
    
    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int geometry_cal_winding_number(double *point,const polygon<double>& polygon){
    int wn = 0;

    int i;
    double pass_pt;
    int end_pt;
//if(polygon.is_closed()){
//      end_pt = polygon.get_num_vertices()-1;
//    }
//    else{
      end_pt = polygon.get_num_vertices();
//    }
    for(i=0;i<end_pt;i++){
      if((polygon.get_vertices(i)[1] - point[1])*(polygon.get_vertices(i-1)[1] - point[1]) <= 0){
	if(polygon.get_vertices(i)[1] != polygon.get_vertices(i-1)[1]){
	  pass_pt = polygon.get_vertices(i-1)[0] + (point[1] - polygon.get_vertices(i-1)[1])*(polygon.get_vertices(i)[0] - polygon.get_vertices(i-1)[0])/(polygon.get_vertices(i)[1] - polygon.get_vertices(i-1)[1]);
	  if(pass_pt == point[0]){
	    return -1;
	  }
	  if(pass_pt > point[0]){
	    if(polygon.get_vertices(i)[1] > point[1] && polygon.get_vertices(i-1)[1] <= point[1]){
	      wn++;
	    }
	    else if(polygon.get_vertices(i)[1] <= point[1] && polygon.get_vertices(i-1)[1] > point[1]){
	      wn--;
	    }
	  }
	}
      }
    }

    return wn;
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_is_pt_inside_polygon(const polygon<double>& polygon1,double *pt){
    if(polygon1.get_num_vertices()==0){
      return false;
    }
    if(geometry_cal_winding_number(pt,polygon1)==0){
      return false;
    }
    return true;
  }

###CPP### ###CUDA### ###HOST### bool geometry_is_pt_on_polygon(const polygon<double>& polygon1,double *pt){ //to do
    int i;
    if(polygon1.get_num_vertices()==0){
      return false;
    }
    for(i=0;i<polygon1.get_num_vertices();i++){
      
    }
    return false;
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_is_polygon_inside_polygon(const polygon<double>& polygon1,const polygon<double>& polygon2){
    int i;
    if(polygon1.get_num_vertices()==0){
      return false;
    }
    for(i=0;i<polygon1.get_num_vertices();i++){
      if(geometry_cal_winding_number(polygon1.get_vertices(i),polygon2)==0){
	return false;
      }
    }
    return true;
  } //return true if polygon1 is inside polygon2

  ###CPP### ###CUDA### ###HOST### bool geometry_is_polygon_intersect_polygon(const polygon<double>& polygon1,const polygon<double>& polygon2){
    bool result = false;
    if(geometry_is_polygon_inside_polygon(polygon1,polygon2) || geometry_is_polygon_inside_polygon(polygon2,polygon1)){
      return false;
    }
    
    int i,j;
    for(i=0;i<polygon1.get_num_vertices();i++){
      result = geometry_is_pt_inside_polygon(polygon2,polygon1.get_vertices(i));
      if(result){
	break;
      }
    }

    if(!result){
      for(i=0;i<polygon2.get_num_vertices();i++){
	result = geometry_is_pt_inside_polygon(polygon1,polygon2.get_vertices(i));
	if(result){
	  break;
	}
      }

      if(!result){
	for(i=1;i<polygon1.get_num_vertices();i++){
	  for(j=1;j<polygon2.get_num_vertices();j++){
	    result = geometry_is_line_segs_intersect(polygon1.get_vertices(i),polygon1.get_vertices(i-1),polygon2.get_vertices(j),polygon2.get_vertices(j-1));
	    if(result){
	      break;
	    }
	  }
	}
      }
    }
    
    return result;
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_is_line_cut_polygon(const polygon<double>& polygon1,double *line_pt,double *line_dir){ //line in 2d vector form
    int i;
    if(polygon1.get_num_vertices()==0){
      return false;
    }

    for(i=1;i<polygon1.get_num_vertices();i++){
      if(geometry_is_lines_intersect_between(line_pt,line_dir,polygon1.get_vertices(i),polygon1.get_vertices(i-1))){
	return true;
      }
    }
    return false;
  }
  ###CPP### ###CUDA### ###HOST### int geometry_simplify_polygon_by_angle(polygon<double>& polygon,double threshold){
    if(threshold <= 0 || threshold >1){
      return _ERRORCODE_INPUTOUTOFRANGE;
    }
    if(polygon.get_num_vertices()<=2){ //single point or empty polygon. Cannot be simplified
      //cout << "Empty. Just end." << endl;
      return _ERRORCODE_NOERROR;
    }
    if(!polygon.is_closed()){
      //cout << "Polygon not closed." << endl;
      return _ERRORCODE_INPUTERROR;
    }

    double *corr=new double [polygon.get_num_vertices()-2];
    double meanx, meany;
    double varx, vary;
    corr--;
    int i,j;
    for(i=1;i<polygon.get_num_vertices()-1;i++){
      meanx = 0.;
      meany = 0.;
      for(j=-1;j<=1;j++){
	meanx += polygon.get_vertices(i+j)[0];
	meany += polygon.get_vertices(i+j)[1];
      }
      meanx /= 3.;
      meany /= 3.;
      
      corr[i] = 0.;
      varx = 0.;
      vary = 0.;
      for(j=-1;j<=1;j++){
	corr[i] += (polygon.get_vertices(i+j)[0] - meanx)*(polygon.get_vertices(i+j)[1] - meany);
	varx += (polygon.get_vertices(i+j)[0] - meanx)*(polygon.get_vertices(i+j)[0] - meanx);
	vary += (polygon.get_vertices(i+j)[1] - meany)*(polygon.get_vertices(i+j)[1] - meany);
      }
      
      corr[i] /= 3.;
      varx /= 3.;
      vary /= 3.;
      
      if(varx == 0. || vary == 0.){
	corr[i] = 1.;
      }
      else{
	corr[i] /= std::pow(varx*vary,0.5);
      }
      corr[i] = fabs(corr[i]);
    }
    
    for(i=polygon.get_num_vertices()-2;i>=1;i--){
      if(corr[i] >= threshold){
	if((corr[i-1] < threshold)){
	  polygon.delete_vertex(i);
	}
	else if(corr[i-1] >= threshold){
	  polygon.delete_vertex(i);
	  i--;
	}
      }
    }
    
    corr++;
    delete [] corr;
    
    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int geometry_simplify_polygon_by_area(polygon<double>& inout,double threshold){ 
    return geometry_simplify_polygon_by_area(inout,threshold,50);
  }
  ###CPP### ###CUDA### ###HOST### int geometry_simplify_polygon_by_area(polygon<double>& inout,double threshold,int cross_check_every){
    if(cross_check_every <= 0){
      cross_check_every = 1;
    }
    if(threshold <= 0){
      return _ERRORCODE_INPUTOUTOFRANGE;
    }
    if(!inout.is_closed()){
      //cout << "Polygon not closed." << endl;
      return _ERRORCODE_INPUTERROR;
    }

    int i,j;
    bool done=false;
    double *area = new double [inout.get_num_vertices()-2];
    bool *blacklist = new bool [inout.get_num_vertices()-2];
    polygon<double> temp_polygon;
    for(i=0;i<inout.get_num_vertices()-2;i++){
      blacklist[i] = false;
    }
    double min_area;
    int min_loc;
    double *vec1 = new double [3];
    vec1[2] = 0.;
    double *vec2 = new double [3];
    double *vec3 = new double [3];
    vec2[2] = 0.;
    int count,count_check = 0, lesscount;
    int *vertex2delete = new int [cross_check_every];
    temp_polygon = inout;
    while(!done){
      count = 0;
      for(i=2;i<temp_polygon.get_num_vertices();i++){
	if(!blacklist[i-2] || temp_polygon.get_num_vertices()==4){
	  for(j=0;j<2;j++){
	    vec1[j] = temp_polygon.get_vertices(i-2)[j] - temp_polygon.get_vertices(i-1)[j];
	    vec2[j] = temp_polygon.get_vertices(i)[j] - temp_polygon.get_vertices(i-1)[j];
	  }
	  vector_cross_pro(vec1,vec2,vec3);
	  area[i-2] = fabs(vec3[2])/2;
	  if(count==0 || area[i-2] < min_area){
	    min_area = area[i-2];
	    min_loc = i;
	  }
	  count++;
	}
      }
      //cout << min_loc << " " << min_area << " " << temp_polygon.get_num_vertices() << endl;

      if(count==0){//all blacklisted
	done=true;
      }

      if(min_area < threshold){
	temp_polygon.delete_vertex(min_loc-1);

	vertex2delete[count_check] = min_loc;
	count_check++;
	if(count_check == cross_check_every){
	  if(geometry_polygon_check_self_crossing(temp_polygon) && temp_polygon.get_num_vertices()!=3){ //roll back and blacklist
	    //std::cout << "Crossing from simplification. Roll back." << endl;
	    temp_polygon = inout;
	    for(i=0;i<cross_check_every;i++){
	      lesscount = 0;
	      for(j=0;j<i;j++){
		if(vertex2delete[j] >=  vertex2delete[i]){
		  lesscount++;
		}
	      }
	      blacklist[vertex2delete[i]-2+lesscount] = true;
	    }
	  }
	  else{ //commit deletion
	    //std::cout << "Committing changes in simplifications." << endl;
	    for(i=0;i<temp_polygon.get_num_vertices()-2;i++){
	      blacklist[i] = false;
	    }
	    for(i=0;i<cross_check_every;i++){
	      inout.delete_vertex(vertex2delete[i]-1);
	    }
	  }
	  count_check=0;
	}
      }
      else{
	done = true;
      }
      if(temp_polygon.get_num_vertices()<=3){
	done = true;
      }

      if(done){
	if(!geometry_polygon_check_self_crossing(temp_polygon)){
	  inout = temp_polygon;
	}
      }
    }

    if(inout.get_num_vertices()<=3){ //line polygon, just remove
      inout.destroy();
    }

    delete [] vec1;
    delete [] vec2;
    delete [] vec3;
    delete [] area;
    delete [] blacklist;

    delete [] vertex2delete;

    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### void geometry_cal_mindist_between_polygons(polygon<double>& polygon1,polygon<double>& polygon2,int &loc1,int &loc2,double &mindist){
    int m,n;
    
    double dist;
    int loc_m, loc_n;

    polygon1.open();
    polygon2.open();
    for(m=0;m<polygon2.get_num_vertices();m++){
      for(n=0;n<polygon1.get_num_vertices();n++){
	dist = (polygon2.get_vertices(m)[0] - polygon1.get_vertices(n)[0])*(polygon2.get_vertices(m)[0] - polygon1.get_vertices(n)[0]) + (polygon2.get_vertices(m)[1] - polygon1.get_vertices(n)[1])*(polygon2.get_vertices(m)[1] - polygon1.get_vertices(n)[1]);
	if((dist < mindist) || (m==0 && n==0)){
	  loc_m = m;
	  loc_n = n;
	  mindist = dist;
	}
      }
    }

    loc1 = loc_n;
    loc2 = loc_m;

    polygon1.close();
    polygon2.close();
  }

  ###CPP### ###CUDA### ###HOST### void merge_polygons(polygon<double>& polygon1,polygon<double>& polygon2,double gap,double *xbounds,double *ybounds,double tolerance){
    //polygon2 will be merged into polygon1. Memory allocated will be freed.
    if(polygon2.get_num_vertices()>0){
      int m,n;
      
      int loc_m, loc_n, ori_loc_n;
      double min_dist;
      
      polygon1.open();
      polygon2.open();
      
      geometry_cal_mindist_between_polygons(polygon1,polygon2,loc_n,loc_m,min_dist);
      ori_loc_n = loc_n;
      
      if(gap > 0){
	bool onedge, increase;
	if(xbounds!=NULL){
	  if(xbounds[1] > xbounds[0]){
	    increase = true;
	  }
	  else{
	    increase = false;
	  }
	  
	  onedge = false;
	  for(m=0;m<polygon1.get_num_vertices()&&!onedge;m++){
	    if(fabs(polygon1.get_vertices(m)[0]-xbounds[0]) < tolerance){
	      for(n=0;n<polygon2.get_num_vertices()&&!onedge;n++){
		if(fabs(polygon2.get_vertices(n)[0]-xbounds[0]) < tolerance){
		  onedge = true;
		  break;
		}
	      }
	    }
	  }
	  
	  if(onedge){
	    for(m=0;m<polygon1.get_num_vertices();m++){
	      if(fabs(polygon1.get_vertices(m)[0]-xbounds[0])<tolerance){
		if(increase){
		  polygon1.get_vertices(m)[0]-=gap;
		}
		else{
		  polygon1.get_vertices(m)[0]+=gap;
		}
	      }
	    }
	    for(n=0;n<polygon2.get_num_vertices();n++){
	      if(fabs(polygon2.get_vertices(n)[0]-xbounds[0])<tolerance){
		if(increase){
		  polygon2.get_vertices(n)[0]+=gap;
		}
		else{
		  polygon2.get_vertices(n)[0]-=gap;
		}
	      }
	    }
	  }
	  
	  onedge = false;
	  for(m=0;m<polygon1.get_num_vertices()&&!onedge;m++){
	    if(polygon1.get_vertices(m)[0] == xbounds[1]){
	      for(n=0;n<polygon2.get_num_vertices()&&!onedge;n++){
		if(fabs(polygon2.get_vertices(n)[0]-xbounds[1])<tolerance){
		  onedge = true;
		  break;
		}
	      }
	    }
	  }
	  
	  if(onedge){
	    for(m=0;m<polygon1.get_num_vertices();m++){
	      if(fabs(polygon1.get_vertices(m)[0]-xbounds[1])<tolerance){
		if(increase){
		  polygon1.get_vertices(m)[0]+=gap;
		}
		else{
		  polygon1.get_vertices(m)[0]-=gap;
		}
	      }
	    }
	    for(n=0;n<polygon2.get_num_vertices();n++){
	      if(fabs(polygon2.get_vertices(n)[0]-xbounds[1])<tolerance){
		if(increase){
		  polygon2.get_vertices(n)[0]-=gap;
		}
		else{
		  polygon2.get_vertices(n)[0]+=gap;
		}
	      }
	    }
	  }
	}
	
	if(ybounds!=NULL){
	  if(ybounds[1] > ybounds[0]){
	    increase = true;
	  }
	  else{
	    increase = false;
	  }
	  
	  onedge = false;
	  for(m=0;m<polygon1.get_num_vertices()&&!onedge;m++){
	    if(fabs(polygon1.get_vertices(m)[1]-ybounds[0])<tolerance){
	      for(n=0;n<polygon2.get_num_vertices()&&!onedge;n++){
		if(fabs(polygon2.get_vertices(n)[1]-ybounds[0])<tolerance){
		  onedge = true;
		  break;
		}
	      }
	    }
	  }
	  
	  if(onedge){
	    for(m=0;m<polygon1.get_num_vertices();m++){
	      if(fabs(polygon1.get_vertices(m)[1]-ybounds[0])<tolerance){
		if(increase){
		  polygon1.get_vertices(m)[1]-=gap;
		}
		else{
		  polygon1.get_vertices(m)[1]+=gap;
		}
	      }
	    }
	    for(n=0;n<polygon2.get_num_vertices();n++){
	      if(fabs(polygon2.get_vertices(n)[1]-ybounds[0])<tolerance){
		if(increase){
		  polygon2.get_vertices(n)[1]+=gap;
		}
		else{
		  polygon2.get_vertices(n)[1]-=gap;
		}
	      }
	    }
	  }
	  
	  onedge = false;
	  for(m=0;m<polygon1.get_num_vertices()&&!onedge;m++){
	    if(fabs(polygon1.get_vertices(m)[1]-ybounds[1])<tolerance){
	      for(n=0;n<polygon2.get_num_vertices()&&!onedge;n++){
		if(fabs(polygon2.get_vertices(n)[1]-ybounds[1])<tolerance){
		  onedge = true;
		  break;
		}
	      }
	    }
	  }
	  
	  if(onedge){
	    for(m=0;m<polygon1.get_num_vertices();m++){
	      if(fabs(polygon1.get_vertices(m)[1]-ybounds[1])<tolerance){
		if(increase){
		  polygon1.get_vertices(m)[1]+=gap;
		}
		else{
		  polygon1.get_vertices(m)[1]-=gap;
		}
	      }
	    }
	    for(n=0;n<polygon2.get_num_vertices();n++){
	      if(fabs(polygon2.get_vertices(n)[1]-ybounds[1])<tolerance){
		if(increase){
		  polygon2.get_vertices(n)[1]-=gap;
		}
		else{
		  polygon2.get_vertices(n)[1]+=gap;
		}
	      }
	    }
	  }
	}
      }

/*
    double *outer_contour_pt1 = new double [2];
    double *outer_contour_pt2 = new double [2];
    double *inner_contour_pt1 = new double [2];
    double *inner_contour_pt2 = new double [2];
    double *dir1 = new double [2];
    double *dir2 = new double [2];

    vector_mid_pt(2,polygon1.get_vertices(loc_n),polygon1.get_vertices(loc_n-1),outer_contour_pt1);
    if(loc_n == polygon1.get_num_vertices()-1){
      vector_mid_pt(2,polygon1.get_vertices(loc_n),polygon1.get_vertices(0),outer_contour_pt2);
    }
    else{
      vector_mid_pt(2,polygon1.get_vertices(loc_n),polygon1.get_vertices(loc_n+1),outer_contour_pt2);
    }

    vector_mid_pt(2,polygon2.get_vertices(loc_m),polygon2.get_vertices(loc_m-1),inner_contour_pt1);
    if(loc_m == polygon2.get_num_vertices()-1){
      vector_mid_pt(2,polygon2.get_vertices(loc_m),polygon2.get_vertices(0),inner_contour_pt2);
	  }
    else{
      vector_mid_pt(2,polygon2.get_vertices(loc_m),polygon2.get_vertices(loc_m+1),inner_contour_pt2);
    }
    
    for(m=0;m<2;m++){
      dir1[m] = inner_contour_pt1[m] - outer_contour_pt1[m];
      dir2[m] = inner_contour_pt2[m] - outer_contour_pt2[m];
    }


    if(geometry_is_lines_intersect_between(outer_contour_pt1,dir1,inner_contour_pt2,outer_contour_pt2) && geometry_is_lines_intersect_between(outer_contour_pt2,dir2,inner_contour_pt1,outer_contour_pt1)){
      polygon1.add_vertex(loc_n,polygon1.get_vertices(loc_n));
      for(m=loc_m;m<polygon2.get_num_vertices();m++){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
	loc_n++;
      }
      for(m=0;m<=loc_m;m++){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
	loc_n++;
      }
    }
    else{
    */
      polygon1.add_vertex(loc_n+1,polygon1.get_vertices(ori_loc_n));
      for(m=loc_m;m<polygon2.get_num_vertices();m++){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
      }
      for(m=0;m<=loc_m;m++){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
      }
      /*
      for(m=loc_m;m>=0;m--){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
	loc_n++;
      }
      for(m=polygon2.get_num_vertices()-1;m>=loc_m;m--){
	polygon1.add_vertex(loc_n+1,polygon2.get_vertices(m));
	loc_n++;
      }
      polygon1.add_vertex(loc_n+1,polygon1.get_vertices(ori_loc_n));
      */
      //}

//geometry_simplify_polygon_by_area(polygon1,1e-10,polygon1.get_num_vertices());  

      if(gap > 0){
	double *dir1 = new double [2];
	double *dir2 = new double [2];
	for(m=0;m<2;m++){
	  dir1[m] = polygon1.get_vertices(ori_loc_n+1)[m] - polygon1.get_vertices(ori_loc_n)[m];
	}
	
	double norm = pow(vector_dot_pro(2,dir1,dir1),0.5);
	for(m=0;m<2;m++){
	  dir1[m] /= norm;
	}
	
	double vec1[3],vec2[3],vec3[3];
	
	vec2[0] = 0.;
	vec2[1] = 0.;
	vec2[2] = 1.;
	
	vec1[0] = dir1[0];
	vec1[1] = dir1[1];
	vec1[2] = 0.;
	
	vector_cross_pro(vec1,vec2,vec3);
	
	for(m=0;m<2;m++){
	  dir2[m] = polygon1.get_vertices(ori_loc_n-1)[m] - polygon1.get_vertices(ori_loc_n)[m];
	}
	norm = pow(vector_dot_pro(2,dir2,dir2),0.5);
	if(is_nan(norm)){
	  std::cout << "Section 1" << endl;
	  std::cout << "Nan detected. " << ori_loc_n << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n-1)[0] << " " << polygon1.get_vertices(ori_loc_n-1)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n)[0] << " " << polygon1.get_vertices(ori_loc_n)[1] << endl;
	}
	if(norm <= 1e-10){
	  std::cout << "Section 1" << endl;
	  std::cout << "Small norm detected. " << ori_loc_n << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n-1)[0] << " " << polygon1.get_vertices(ori_loc_n-1)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n)[0] << " " << polygon1.get_vertices(ori_loc_n)[1] << endl;
	}
	for(m=0;m<2;m++){
	  dir2[m] /= norm;
	}
	norm = -vector_dot_pro(2,dir2,vec3)*gap;
	for(m=0;m<2;m++){
	  polygon1.get_vertices(ori_loc_n)[m] += norm*dir2[m];
	}
	
	for(m=0;m<2;m++){
	  dir2[m] = polygon1.get_vertices(ori_loc_n+2)[m] - polygon1.get_vertices(ori_loc_n+1)[m];
	}
	norm = pow(vector_dot_pro(2,dir2,dir2),0.5);
	if(is_nan(norm)){
	  std::cout << "Section 2" << endl;
	  std::cout << "Nan detected. " << ori_loc_n+1 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+1)[0] << " " << polygon1.get_vertices(ori_loc_n+1)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+2)[0] << " " << polygon1.get_vertices(ori_loc_n+2)[1] << endl;
	}
	if(norm <= 1e-10){
	  std::cout << "Section 2" << endl;
	  std::cout << "Small norm detected. " << ori_loc_n+1 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+1)[0] << " " << polygon1.get_vertices(ori_loc_n+1)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+2)[0] << " " << polygon1.get_vertices(ori_loc_n+2)[1] << endl;
	}
	for(m=0;m<2;m++){
	  dir2[m] /= norm;
	}
	norm = -vector_dot_pro(2,dir2,vec3)*gap;
	for(m=0;m<2;m++){
	  polygon1.get_vertices(ori_loc_n+1)[m] += norm*dir2[m];
	}
	
	for(m=0;m<2;m++){
	  dir2[m] = polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices())[m] - polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[m];
	}
	norm = pow(vector_dot_pro(2,dir2,dir2),0.5);
	if(is_nan(norm)){
	  std::cout << "Section 3" << endl;
	  std::cout << "Nan detected. " << ori_loc_n+polygon2.get_num_vertices()+1 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices())[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices())[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[1] << endl;
	}
	if(norm <= 1e-10){
	  std::cout << "Section 3" << endl;
	  std::cout << "Small norm detected. " << ori_loc_n+polygon2.get_num_vertices()+1 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices())[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices())[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[1] << endl;
	}
	for(m=0;m<2;m++){
	  dir2[m] /= norm;
	}
	norm = vector_dot_pro(2,dir2,vec3)*gap;
	for(m=0;m<2;m++){
	  polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[m] += norm*dir2[m];
	}
	for(m=0;m<2;m++){
	  dir2[m] = polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+3)[m] - polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[m];
	}
	norm = pow(vector_dot_pro(2,dir2,dir2),0.5);
	if(is_nan(norm)){
	  std::cout << "Section 4" << endl;
	  std::cout << "Nan detected. " << ori_loc_n+polygon2.get_num_vertices()+2 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+3)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+3)[1] << endl;
	}
	if(norm <= 1e-10){
	  std::cout << "Section 4" << endl;
	  std::cout << "Small norm detected. " << ori_loc_n+polygon2.get_num_vertices()+2 << " " << dir2[0] << " " << dir2[1] << " | " << polygon1.get_num_vertices() << " " << polygon2.get_num_vertices() << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[1] << endl;
	  std::cout << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+3)[0] << " " << polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+3)[1] << endl;
	}
	for(m=0;m<2;m++){
	  dir2[m] /= norm;
	}
	norm = vector_dot_pro(2,dir2,vec3)*gap;
	for(m=0;m<2;m++){
	  polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+2)[m] += norm*dir2[m];
	}
      
      /*
      for(m=0;m<2;m++){
	polygon1.get_vertices(ori_loc_n)[m] -= vec3[m]*gap;
	polygon1.get_vertices(ori_loc_n+1)[m] -= vec3[m]*gap;
	polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[m] += vec3[m]*gap;
	polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1+1)[m] += vec3[m]*gap;
      }
      */
      /*
      if(geometry_polygon_check_self_crossing(polygon1)){
	for(m=0;m<2;m++){
	  polygon1.get_vertices(ori_loc_n)[m] += 2.*vec3[m];
	  polygon1.get_vertices(ori_loc_n+1)[m] += 2.*vec3[m];
	  polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1)[m] -= 2.*vec3[m];
	  polygon1.get_vertices(ori_loc_n+polygon2.get_num_vertices()+1+1)[m] -= 2.*vec3[m];
	}
      }
      */
      /*
      if(geometry_polygon_check_self_crossing(polygon1)){
	cout << "Self crossing detected: " << &polygon1 << " " << ori_loc_n << endl;
	cout << "{" << endl;
	cout << "\t\t\t\"type\":\"Polygon\"," << endl;
	cout << "\t\t\t\"coordinates\":[" << endl;
	cout << "\t\t\t\t[" << endl;
	
	for(n=0;n<polygon1.get_num_vertices();n++){
	  cout << "\t\t\t\t\t["<< fixed << setprecision(6) << polygon1.get_vertices(n)[0] << "," << polygon1.get_vertices(n)[1] << "]" << (n==(polygon1.get_num_vertices()-1)?"":",") << endl;
	}
	cout << "\t\t\t\t]" << endl;
	cout << "\t\t\t]" << endl;
	cout << "\t\t}" << endl;
      }
      */
	delete [] dir1;
	delete [] dir2;
      }
      geometry_simplify_polygon_by_area(polygon1,1e-10,polygon1.get_num_vertices());  
/*
    delete [] outer_contour_pt1;
    delete [] outer_contour_pt2;
    delete [] inner_contour_pt1;
    delete [] inner_contour_pt2;
    delete [] dir1;
    delete [] dir2;
*/  
    //polygon2.close();
    //polygon1.make_right_hand();
      polygon1.close();
      polygon2.destroy();

      polygon1.check_short_segment(1e-10,"Check short segement from geometry->merge: ");
    }
  }

  struct polygon_sort_temp{
    int index;
    double dist;
  };
  void polygon_sort_temp_setequal(char *a,char *b){
    ((polygon_sort_temp*) b)->index = ((polygon_sort_temp*) a)->index;
    ((polygon_sort_temp*) b)->dist = ((polygon_sort_temp*) a)->dist;
  }
  bool polygon_sort_temp_isless(char *a,char *b){
    return ((polygon_sort_temp*) b)->dist > ((polygon_sort_temp*) a)->dist;
  }

  ###CPP### ###CUDA### ###HOST### void geometry_merge_with_inside_polygon(int num_polygon,polygon<double> *polygons,double gap){
geometry_merge_with_inside_polygon(num_polygon,polygons,gap,NULL,NULL,0.);
  }

  ###CPP### ###CUDA### ###HOST### void geometry_merge_with_inside_polygon(int num_polygon,polygon<double> *polygons,double gap,double *xbounds,double *ybounds,double tolerance){
    int i,j,k,m,n;
    int itemp;
    int **parent_polygon = new int *[num_polygon];
    int *num_parent_polygon = new int [num_polygon];
    int *num_daughter_polygon = new int [num_polygon];
    for(i=0;i<num_polygon;i++){
      parent_polygon[i] = new int [num_polygon-1];
      for(j=0;j<num_polygon-1;j++){
	parent_polygon[i][j] = -1;
      }
      num_parent_polygon[i] = 0;
      num_daughter_polygon[i] = 0;
    }
    
    for(j=0;j<num_polygon;j++){
      k=0;
      if(polygons[j].get_num_vertices()>0){
	for(i=0;i<num_polygon;i++){
	  if(i!=j && polygons[i].get_num_vertices()>0){
	    if(geometry_is_polygon_inside_polygon(polygons[j],polygons[i])){
	      parent_polygon[j][k] = i;
	      num_parent_polygon[j]++;
	      k++;
	      num_daughter_polygon[i]++;
	    }
	  }
	}
      }
    }
    /*
    for(j=0;j<num_polygon;j++){
      cout << j << " " << num_parent_polygon[j] << " ";
      for(k=0;k<num_polygon-1;k++){
	if(parent_polygon[j][k]!=-1){
	  cout << parent_polygon[j][k] << " ";
	}
	else{
	  break;
	}
      }
      cout << endl;
    }
    */
    bool notdone;
    //for(i=0;i<=num_polygon-1;i+=2){
    for(m=0;m<num_polygon;m++){
      if(num_daughter_polygon[m] > 0 && num_parent_polygon[m]%2 == 0){
	if(num_daughter_polygon[m]==1){ //simple case
	  notdone = true;
	  //std::cout << "Single daughter case." << endl;
	  for(j=0;j<num_polygon&&notdone;j++){
	    if(num_parent_polygon[j]==num_parent_polygon[m]+1){
	      for(k=0;k<num_polygon-1;k++){
		if(parent_polygon[j][k]==m){
		  merge_polygons(polygons[m],polygons[j],gap,xbounds,ybounds,tolerance);
		  notdone=false;
		  break;
		}
		else if(parent_polygon[j][k]==-1 && notdone){
		  //		  std::cout << "Bug detected! Daughter polygon not found for single daughter case." << endl;
		  break;
		}
	      }
	    }
	  }
	  if(notdone){
	    std::cout << "Bug detected! Daughter polygon not found for single daughter case." << endl;
	  }
	}
	else{ //need sorting to avoid crossing
	  //std::cout << "Multi daughter case." << endl;
	  polygon_sort_temp *sort_temp = new polygon_sort_temp [num_daughter_polygon[m]]; //num_daughter_polygon[m] is only a upper bound because only immediate daughter would be merged
	  n=0;
	  for(j=0;j<num_polygon;j++){
	    if(num_parent_polygon[j]==num_parent_polygon[m]+1){
	      for(k=0;k<num_polygon-1;k++){
		if(parent_polygon[j][k]==m){
		  geometry_cal_mindist_between_polygons(polygons[m],polygons[j],itemp,itemp,sort_temp[n].dist);
		  sort_temp[n].index = j;
		  n++;
		  break;
		}
		else if(parent_polygon[j][k]==-1){
		  //		  std::cout << "Bug detected! Daughter polygon not found for multi-daughter case." << endl;
		  break;
		}
	      }
	    }
	  }

	  general_sort(n,sizeof(polygon_sort_temp),(char*) sort_temp,polygon_sort_temp_setequal,polygon_sort_temp_isless);

	  for(j=0;j<n;j++){
	    merge_polygons(polygons[m],polygons[sort_temp[j].index],gap,xbounds,ybounds,tolerance);
	  }

	  delete [] sort_temp;

	}
      }
    }
      //}

    /*
      for(j=0;j<num_polygon;j++){
	if(num_parent_polygon[j] == i){
	  for(k=0;k<num_polygon-1;k++){
	    //cout << i << " " << j << " " << parent_polygon[j][k] << " " << num_parent_polygon[parent_polygon[j][k]] << endl;
	    if(parent_polygon[j][k]!=-1 && num_parent_polygon[parent_polygon[j][k]] == i-1){ //look for a polygon that was enclosed by "all polygons that enclose j" and not enclosed by j
	      //cout << j << " " << parent_polygon[j][k] << endl;
	      merge_polygons(polygons[parent_polygon[j][k]],polygons[j],gap);
	      break;
	    }
	    else if(parent_polygon[j][k]==-1){
	      break;
	    }
	  }
	}
      }
    }
    */
    
    for(i=0;i<num_polygon;i++){
      delete [] parent_polygon[i];
    }
    delete [] parent_polygon;
    delete [] num_parent_polygon;
    delete [] num_daughter_polygon;
  }

  ###CPP### ###CUDA### ###HOST### double geometry_cal_polygon_area(const polygon<double> &in){
    int i;
    double temp1 = 0, temp2 = 0;

    if(in.is_closed()){
      for(i=1;i<in.get_num_vertices();i++){
	temp1 += in.get_vertices(i-1)[0]*in.get_vertices(i)[1];
	temp2 += in.get_vertices(i-1)[1]*in.get_vertices(i)[0];
      }
      double area = 0.5*(temp1 - temp2);
      if(area < 0){
	area = -area;
      }
      return area;
    }
    else{
      return -1;
    }
  }

  ###CPP### ###CUDA### ###HOST### bool geometry_polygon_check_self_crossing(const polygon<double> &in){
    return geometry_polygon_check_self_crossing(in,NULL);
  }
  ###CPP### ###CUDA### ###HOST### bool geometry_polygon_check_self_crossing(const polygon<double> &in,int *location){
    int end_pt;
    if(in.is_closed()){
      end_pt = in.get_num_vertices()-2;
    }
    else{
      end_pt = in.get_num_vertices()-1;
    }
    bool result = false;

    int i,j,k;

    double *temp_dir1 = new double [2];
    double *temp_dir2 = new double [2];
    for(i=0;i<end_pt;i++){
      for(k=0;k<2;k++){
	temp_dir1[k] = in.get_vertices(i+1)[k] - in.get_vertices(i)[k];
      }
      for(j=i+2;j<end_pt;j++){
	for(k=0;k<2;k++){
	  temp_dir2[k] = in.get_vertices(j+1)[k] - in.get_vertices(j)[k];
	}
	if(geometry_is_lines_intersect_between(in.get_vertices(i),temp_dir1,in.get_vertices(j),in.get_vertices(j+1)) && geometry_is_lines_intersect_between(in.get_vertices(j),temp_dir2,in.get_vertices(i),in.get_vertices(i+1))){
	  delete [] temp_dir1;
	  delete [] temp_dir2;
	  if(location != NULL){
	    location[0] = i;
	    location[1] = j+1;
	  }

	  result = true;
	  return result;
	}
      }
    }

    delete [] temp_dir1;
    delete [] temp_dir2;
    return result;
  }

  ###CPP### ###CUDA### ###HOST### double earth_lonlat_geometry_distance_from_line(double *pt_lonlat,double *line_pt1_lonlat,double *line_pt2_lonlat){
    double result;

    double *linept1_cart = new double [3];
    double *linept2_cart = new double [3];

    earth_lonlat_to_unit_cartesian(line_pt1_lonlat,linept1_cart);
    earth_lonlat_to_unit_cartesian(line_pt2_lonlat,linept2_cart);
    double *norm = new double [3];
    vector_cross_pro(linept1_cart,linept2_cart,norm);

    delete [] linept1_cart;
    delete [] linept2_cart;

    if(vector_dot_pro(3,norm,norm)<=1e-10){
      delete [] norm;
      return 0.;
    }
    double norm_norm = pow(vector_dot_pro(3,norm,norm),0.5);

    int i,j;
    for(i=0;i<3;i++){
      norm[i] /= norm_norm;
    }

    double *pt_cart = new double [3];
    double *project_cart = new double [3];
    earth_lonlat_to_unit_cartesian(pt_lonlat,pt_cart);

    norm_norm = vector_dot_pro(3,pt_cart,norm);

    for(i=0;i<3;i++){
      project_cart[i] = pt_cart[i] - norm_norm*norm[i];
    }

    delete [] pt_cart;
    norm_norm = pow(vector_dot_pro(3,project_cart,project_cart),0.5);

    for(i=0;i<3;i++){
      project_cart[i] /= norm_norm;
    }

    double *project = new double [2];
    earth_unit_cartesian_to_lonlat(project_cart,project);
    
    delete [] project_cart;

    result = earth_lonlat2dist(pt_lonlat,project);

    delete [] project;

    return result;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_find_enclose_circle(const polygon<double> &in, double *center, double &radius, int *index_pairs){
    if(in.get_num_vertices()==0){
      return _ERRORCODE_DATAYETTOBEINITIATED;
    }
    else{
      if((in.is_opened() && in.get_num_vertices()==1) || (in.is_closed() && in.get_num_vertices()==2)){ // point polygon
	radius = 0.;
	center[0] = (in.get_vertices(0))[0];
	center[1] = (in.get_vertices(0))[1];
	if(index_pairs != NULL){
	  index_pairs[0] = 0;
	  index_pairs[1] = 0;
	}
      }
      else{
	
      }
    }
    
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_find_enclose_convex_polygon(const polygon<double> &in, int num_vertices, polygon<double>& out){
    polygon<double> temp_polygon = in;

    temp_polygon.remove_duplicate_vertices();
    temp_polygon.make_right_hand();
    temp_polygon.open();

    int i,j;
    bool update = true;
    double vec1[3], vec2[3], vec3[3];
    vec1[2] = 0.;
    vec2[2] = 0.;
    int iteration = 0, retry = 0;
    while(update){
      out.destroy();
      update = false;
      
      for(i=0;i<temp_polygon.get_num_vertices();i++){
	
	for(j=0;j<2;j++){
	  vec1[j] = temp_polygon.get_vertices(i)[j] - temp_polygon.get_vertices(i-1)[j];
	  vec2[j] = temp_polygon.get_vertices(i+1)[j] - temp_polygon.get_vertices(i)[j];
	}
	vector_cross_pro(vec1,vec2,vec3);
      
	if(vec3[2]>0){
	  out.add_vertex(-1,temp_polygon.get_vertices(i));
	}
	else{
	  update = true;
	}
      }
    
    /*
      for(i=0;i<temp_polygon.get_num_vertices();i++){
      out.add_vertex(-1,temp_polygon.get_vertices(i));
      
      if(i<temp_polygon.get_num_vertices()-2){
	  for(j=0;j<2;j++){
	    vec1[j] = temp_polygon.get_vertices(i+1)[j] - temp_polygon.get_vertices(i)[j];
	    vec2[j] = temp_polygon.get_vertices(i+2)[j] - temp_polygon.get_vertices(i+1)[j];
	  }
	  vector_cross_pro(vec1,vec2,vec3);
	  if(vec3[2]<= 0.){
	    update = true;
	    i++;
	  }
	}
      }
      
      //geometry_simplify_polygon_by_angle(out,0.000000001);
      if(!geometry_polygon_check_self_crossing(out)){
	temp_polygon = out;
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Polygon num_vertices " << temp_polygon.get_num_vertices() << " Iteration " << iteration << " Retry " << retry << " success" << std::endl;
	  iteration++;
	}
	retry = 0;
      }
      else{
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Polygon num_vertices " << temp_polygon.get_num_vertices() << " Iteration " << iteration << " Retry " << retry << " failed for self-crossing" << std::endl;
	}
	retry ++;

	out.destroy();
	for(i=1;i<temp_polygon.get_num_vertices();i++){
	  out.add_vertex(-1,temp_polygon.get_vertices(i));
	}
	out.add_vertex(-1,temp_polygon.get_vertices(0));
	out.close();

	//geometry_simplify_polygon_by_angle(out,0.000000001);
	temp_polygon = out;
      }
      if(retry >= temp_polygon.get_num_vertices()){
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Failed to find enclosing polygon for" << std::endl;
	  std::cout << temp_polygon << std::endl;
	}
	break;
      }
      */
      
      temp_polygon = out;
      temp_polygon.remove_duplicate_vertices();

      iteration++;
      if(temp_polygon.get_num_vertices() < num_vertices){
	break;
      }
    }
    
    out.open();
  
    double *dir1, *dir2, *dir3;
    dir1 = new double [3];
    dir2 = new double [3];
    dir3 = new double [2];
    dir1[2] = 0.;
    dir2[2] = 0.;
    
    bool no_progress;
    while(out.get_num_vertices() >= num_vertices+1){
      double min_area = -1;
      int loc;
      no_progress = true;

      for(i=0;i<out.get_num_vertices();i++){
	for(j=0;j<2;j++){
	  dir1[j] = out.get_vertices(i)[j] - out.get_vertices(i-1)[j];
	  dir2[j] = out.get_vertices(i+1)[j] - out.get_vertices(i+2)[j];
	  dir3[j] = out.get_vertices(i+1)[j] - out.get_vertices(i)[j];
	}
	
	if(vector_dot_pro(2,dir1,dir3) >= 0 && vector_dot_pro(2,dir2,dir3) <= 0){
	  geometry_cal_2d_line_intersect(out.get_vertices(i),dir1,out.get_vertices(i+1),dir2,vec2);

	  if(!is_nan(vec2[0]) && !is_nan(vec2[1])){
	    for(j=0;j<2;j++){
	      dir1[j] = out.get_vertices(i)[j] - vec2[j];
	      dir2[j] = out.get_vertices(i+1)[j] - vec2[j];
	    }
	  
	    vector_cross_pro(dir1,dir2,vec3);
	  
	    if(min_area < 0 || fabs(vec3[2]) < min_area){
	      no_progress = false;
	      min_area = fabs(vec3[2]);
	      for(j=0;j<2;j++){
		vec1[j] = vec2[j];
	      }
	      loc = i;
	    }
	  }
	}
      }
      
      if(!no_progress){
	out.add_vertex(loc,vec1);
	out.delete_vertex(loc+1);
	out.delete_vertex(loc+1);
      }
      else{
	break;
      }
    }
    
    delete [] dir1;
    delete [] dir2;
    delete [] dir3;
    out.close();
    if(no_progress){
      return _ERRORCODE_NOTIMPLEMENTED;
    }
    else{
      return _ERRORCODE_NOERROR;
    }
  }

  struct vertex_sort{
    int index;
    double delta_area;
    double replacement[2];
  }; 

  void vertex_sort_setequal(char *a,char *b){
    *((vertex_sort*) b) = *((vertex_sort*) a);
  }
  bool vertex_sort_isless(char *a,char *b){
    return ((vertex_sort*) a)->delta_area < ((vertex_sort*) b)->delta_area;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_find_enclose_polygon(const polygon<double> &in, int num_vertices, polygon<double>& out){
    polygon<double> temp_polygon = in;

    temp_polygon.remove_duplicate_vertices();
    temp_polygon.make_right_hand();
    temp_polygon.open();

    int i,j;
    double vec1[3], vec2[3], vec3[3];
    vec1[2] = 0.;
    vec2[2] = 0.;
    out = temp_polygon;
    /*
    double vertex_delete_delta_area;
    double vertex_replace_delta_area;
    */
    double temp_area;
    //int vertex_delete_target, vertex_replace_target;

    double *dir1, *dir2, *dir3;
    dir1 = new double [3];
    dir2 = new double [3];
    dir3 = new double [2];
    dir1[2] = 0.;
    dir2[2] = 0.;

    int store_size = out.get_num_vertices();

    vertex_sort *vertex_delete_sort = new vertex_sort [store_size];
    vertex_sort *vertex_replace_sort = new vertex_sort [store_size];

    while(out.get_num_vertices() > num_vertices){
      //std::cout << out.get_num_vertices() << std::endl;
      i=0;
      vertex_delete_sort[i].delta_area = -1;
      vertex_delete_sort[i].index = -1;
      vertex_replace_sort[i].delta_area = -1;
      vertex_replace_sort[i].index = -1;

      for(i=0;i<out.get_num_vertices();i++){
	for(j=0;j<2;j++){
	  vec1[j] = out.get_vertices(i)[j] - out.get_vertices(i-1)[j];
	  vec2[j] = out.get_vertices(i+1)[j] - out.get_vertices(i)[j];
	}
	vector_cross_pro(vec1,vec2,vec3);
      
	if(vec3[2]<0){
	  temp_area = fabs(vec3[2]);

	  if(vertex_delete_sort[0].delta_area < 0 || temp_area < vertex_delete_sort[0].delta_area){
	    vertex_delete_sort[0].delta_area = temp_area;
	    vertex_delete_sort[0].index = i;
	  }
	}
      }

      for(i=0;i<out.get_num_vertices();i++){
	for(j=0;j<2;j++){
	  dir1[j] = out.get_vertices(i)[j] - out.get_vertices(i-1)[j];
	  dir2[j] = out.get_vertices(i+1)[j] - out.get_vertices(i+2)[j];
	  dir3[j] = out.get_vertices(i+1)[j] - out.get_vertices(i)[j];
	}

	temp_area = -1;
	vector_cross_pro(dir1,dir2,vec3);
	if(vec3[2] != 0.){
	  vector_cross_pro(dir1,dir3,vec3);
	  if(vec3[2] > 0){
	    vector_cross_pro(dir2,dir3,vec3);
	    if(vec3[2] > 0){
	      if(vector_dot_pro(2,dir1,dir3) >= 0 && vector_dot_pro(2,dir2,dir3) <= 0){
		geometry_cal_2d_line_intersect(out.get_vertices(i),dir1,out.get_vertices(i+1),dir2,vec2);
		
		if(!is_nan(vec2[0]) && !is_nan(vec2[1])){
		  for(j=0;j<2;j++){
		    dir1[j] = out.get_vertices(i)[j] - vec2[j];
		    dir2[j] = out.get_vertices(i+1)[j] - vec2[j];
		  }
		  
		  vector_cross_pro(dir1,dir2,vec3);
		  
		  temp_area = fabs(vec3[2]);
		  
		  if(vertex_replace_sort[0].delta_area < 0 || temp_area < vertex_replace_sort[0].delta_area){
		    vertex_replace_sort[0].delta_area = temp_area;
		    vertex_replace_sort[0].index = i;
		    for(j=0;j<2;j++){
		      vertex_replace_sort[0].replacement[j] = vec2[j];
		    }
		  }
		}
	      }
	    }
	  }
	}
      }

      //std::cout << vertex_replace_delta_area << " " << vertex_delete_delta_area << std::endl;

      if(vertex_replace_sort[0].delta_area < 0 && vertex_delete_sort[0].delta_area < 0){
	break;
      }
      else if(vertex_replace_sort[0].delta_area < 0 || vertex_delete_sort[0].delta_area <= vertex_replace_sort[0].delta_area){
	out.delete_vertex(vertex_delete_sort[0].index);
      }
      else if(vertex_delete_sort[0].delta_area < 0 || vertex_replace_sort[0].delta_area < vertex_delete_sort[0].delta_area){
	out.add_vertex(vertex_replace_sort[0].index,vertex_replace_sort[0].replacement);
	out.delete_vertex(vertex_replace_sort[0].index+1);
	out.delete_vertex(vertex_replace_sort[0].index+1);

      }
      else{
	std::cout << "You should not get here. " << vertex_replace_sort[0].delta_area << " " << vertex_delete_sort[0].delta_area << std::endl;
      }
    }
/*
    int location[2];
    while(geometry_polygon_check_self_crossing(out,location)){
      for(i=location[1]-1;i>location[0];i--){
	out.delete_vertex(i);
      }
    }
*/

    if(geometry_polygon_check_self_crossing(out)){
      temp_polygon = in;

      temp_polygon.remove_duplicate_vertices();
      temp_polygon.make_right_hand();
      temp_polygon.open();

      out = temp_polygon;

      while(out.get_num_vertices() > num_vertices){
	//std::cout << out.get_num_vertices() << std::endl;
	for(i=0;i<out.get_num_vertices();i++){
	  vertex_delete_sort[i].delta_area = -1;
	  vertex_delete_sort[i].index = -1;
	  vertex_replace_sort[i].delta_area = -1;
	  vertex_replace_sort[i].index = -1;
	}

	for(i=0;i<out.get_num_vertices();i++){
	  for(j=0;j<2;j++){
	    vec1[j] = out.get_vertices(i)[j] - out.get_vertices(i-1)[j];
	    vec2[j] = out.get_vertices(i+1)[j] - out.get_vertices(i)[j];
	  }
	  vector_cross_pro(vec1,vec2,vec3);
	  
	  if(vec3[2]<0){
	    temp_area = fabs(vec3[2]);
	    
	    //if(vertex_delete_delta_area < 0 || temp_area < vertex_delete_delta_area){
	    vertex_delete_sort[i].delta_area = temp_area;
	    vertex_delete_sort[i].index = i;
	    //}
	  }
	}
	
	for(i=0;i<out.get_num_vertices();i++){
	  for(j=0;j<2;j++){
	    dir1[j] = out.get_vertices(i)[j] - out.get_vertices(i-1)[j];
	    dir2[j] = out.get_vertices(i+1)[j] - out.get_vertices(i+2)[j];
	    dir3[j] = out.get_vertices(i+1)[j] - out.get_vertices(i)[j];
	  }
	  
	  temp_area = -1;
	  vector_cross_pro(dir1,dir2,vec3);
	  if(vec3[2] != 0.){
	    vector_cross_pro(dir1,dir3,vec3);
	    if(vec3[2] > 0){
	      vector_cross_pro(dir2,dir3,vec3);
	      if(vec3[2] > 0){
		if(vector_dot_pro(2,dir1,dir3) >= 0 && vector_dot_pro(2,dir2,dir3) <= 0){
		  geometry_cal_2d_line_intersect(out.get_vertices(i),dir1,out.get_vertices(i+1),dir2,vec2);
		  
		  if(!is_nan(vec2[0]) && !is_nan(vec2[1])){
		    for(j=0;j<2;j++){
		      dir1[j] = out.get_vertices(i)[j] - vec2[j];
		      dir2[j] = out.get_vertices(i+1)[j] - vec2[j];
		    }
		    
		    vector_cross_pro(dir1,dir2,vec3);
		    
		    temp_area = fabs(vec3[2]);
		    
		    //if(vertex_replace_delta_area < 0 || temp_area < vertex_replace_delta_area){
		    vertex_replace_sort[i].delta_area = temp_area;
		    vertex_replace_sort[i].index = i;
		    for(j=0;j<2;j++){
		      vertex_replace_sort[i].replacement[j] = vec2[j];
		    }
		    //}
		  }
		}
	      }
	    }
	  }
	}
	
	//std::cout << vertex_replace_delta_area << " " << vertex_delete_delta_area << std::endl;
	general_sort(out.get_num_vertices(),sizeof(vertex_sort),(char *) vertex_delete_sort,vertex_sort_setequal,vertex_sort_isless);
	general_sort(out.get_num_vertices(),sizeof(vertex_sort),(char *) vertex_replace_sort,vertex_sort_setequal,vertex_sort_isless);
	
	int delete_index, replace_index;
	for(delete_index=0;delete_index<out.get_num_vertices();delete_index++){
	  if(vertex_delete_sort[delete_index].index >= 0){
	    break;
	  }
	}
	for(replace_index=0;replace_index<out.get_num_vertices();replace_index++){
	  if(vertex_replace_sort[replace_index].index >= 0){
	    break;
	  }
	}
	
	if(replace_index == out.get_num_vertices() && delete_index == out.get_num_vertices()){
	  break;
	}
	
	bool notdone = true;
	while(notdone){
	  temp_polygon = out;
	  if(replace_index >= out.get_num_vertices() && delete_index >= out.get_num_vertices()){
	    notdone = false;
	  }
	  else if(replace_index == out.get_num_vertices() || vertex_delete_sort[delete_index].delta_area <= vertex_replace_sort[replace_index].delta_area){
	    out.delete_vertex(vertex_delete_sort[delete_index].index);
	    
	    if(geometry_polygon_check_self_crossing(out)){
	      out = temp_polygon;
	      delete_index++;
	    }
	    else{
	      notdone = false;
	    }
	  }
	  else if(delete_index == out.get_num_vertices() || vertex_replace_sort[replace_index].delta_area < vertex_delete_sort[delete_index].delta_area){
	    out.add_vertex(vertex_replace_sort[replace_index].index,vertex_replace_sort[replace_index].replacement);
	    out.delete_vertex(vertex_replace_sort[replace_index].index+1);
	    out.delete_vertex(vertex_replace_sort[replace_index].index+1);
	    
	    if(geometry_polygon_check_self_crossing(out)){
	      out = temp_polygon;
	      replace_index++;
	    }
	    else{
	      notdone = false;
	    }
	  }
	  else{
	    std::cout << "You should not get here. " << vertex_replace_sort[replace_index].delta_area << " " << vertex_delete_sort[delete_index].delta_area << std::endl;
	  }
	}
	
	if(replace_index == out.get_num_vertices() && delete_index == out.get_num_vertices()){
	  break;
	}
      }
    }

    delete [] vertex_replace_sort;
    delete [] vertex_delete_sort;

    delete [] dir1;
    delete [] dir2;
    delete [] dir3;

    out.close();

    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_merge_polygon(polygon<double> in,polygon<double> to_merge,polygon<double> &out){
    int i,j,k,n;
    bool update = false;

    in.open();
    to_merge.open();

    int max_intersect = in.get_num_vertices();
    if(to_merge.get_num_vertices() > max_intersect){
      max_intersect = to_merge.get_num_vertices();
    }
    int **intersect_index = new int *[max_intersect];
    for(i=0;i<max_intersect;i++){
      intersect_index[i] = new int [2];
    }
    int intersect_count = 0;

    out.destroy();
    double *temp_vertex = new double [2];
    
    for(i=1;i<in.get_num_vertices();i++){
      for(j=1;j<to_merge.get_num_vertices();j++){
	if(geometry_is_line_segs_intersect(in.get_vertices(i),in.get_vertices(i-1),to_merge.get_vertices(j),to_merge.get_vertices(j-1))){
	  intersect_index[intersect_count][0] = i;
	  intersect_index[intersect_count][1] = j;
	  
	  intersect_count++;
	}
      }
    }

    if(libjeff::debug_setting::get_debug_mode_debug_message()){
      for(k=intersect_count-1;k>=0;k--){
	std::cout << intersect_index[k][0] << " " << intersect_index[k][1] << std::endl;
      }
      std::cout << endl;
    }

    bool degenerate = true;
    int degenerate_index, degenerate_dim;
    while(degenerate){
      degenerate = false;
      for(i=0;i<intersect_count&&!degenerate;i++){
	for(j=i+1;j<intersect_count&&!degenerate;j++){
	  for(k=0;k<2;k++){
	    if(intersect_index[i][k] == intersect_index[j][k]){
	      degenerate = true;
	      degenerate_index = intersect_index[i][k];
	      degenerate_dim = k;
	      break;
	    }
	  }
	}
      }

      if(degenerate){
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Degeneracy detected!" << std::endl;
	  std::cout << "Input modified to:" << std::endl;
	}

	for(i=0;i<max_intersect;i++){
	  delete [] intersect_index[i];
	}
	delete [] intersect_index;

	if(degenerate_dim == 0){
	  for(k=0;k<2;k++){
	    temp_vertex[k] = 0.5*(in.get_vertices(degenerate_index)[k] + in.get_vertices(degenerate_index-1)[k]);
	  }
	  in.add_vertex(degenerate_index,temp_vertex);
	}
	else{
	  for(k=0;k<2;k++){
	    temp_vertex[k] = 0.5*(to_merge.get_vertices(degenerate_index)[k] + to_merge.get_vertices(degenerate_index-1)[k]);
	  }
	  to_merge.add_vertex(degenerate_index,temp_vertex);
	}

	max_intersect = in.get_num_vertices();
	if(to_merge.get_num_vertices() > max_intersect){
	  max_intersect = to_merge.get_num_vertices();
	}
	intersect_index = new int *[max_intersect];
	for(i=0;i<max_intersect;i++){
	  intersect_index[i] = new int [2];
	}
	intersect_count = 0;

	for(i=1;i<in.get_num_vertices();i++){
	  for(j=1;j<to_merge.get_num_vertices();j++){
	    if(geometry_is_line_segs_intersect(in.get_vertices(i),in.get_vertices(i-1),to_merge.get_vertices(j),to_merge.get_vertices(j-1))){
	      intersect_index[intersect_count][0] = i;
	      intersect_index[intersect_count][1] = j;
	      
	      intersect_count++;
	    }
	  }
	}
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << in << std::endl;
	  std::cout << to_merge << std::endl;
	}
      }
    }

    if(intersect_count > 0){
      update = true;
      
      int inside_index;
      k = intersect_count-1;
      int itemp;
      // > 0 means the line seg is going inside of a polygon from -1 to 0
      // abs value of 1 means in is going inside, abs value of 2 means to_merge is going inside
      if(geometry_is_pt_inside_polygon(in,to_merge.get_vertices(intersect_index[k][1]))){
	inside_index = 2;
      }
      else if(geometry_is_pt_inside_polygon(in,to_merge.get_vertices(intersect_index[k][1]-1))){
	inside_index = -2;
      }
      else if(geometry_is_pt_inside_polygon(to_merge,in.get_vertices(intersect_index[k][0]))){
	inside_index = 1;
      }
      else if(geometry_is_pt_inside_polygon(to_merge,in.get_vertices(intersect_index[k][0]-1))){
	inside_index = -1;
      }
      else{
	std::cout<< "Bug Detected in geometry_polygon_merge_polygon" << std::endl;
      }
      
      if(inside_index < 0){
	n = intersect_count-2;
	for(k=intersect_count-3;k>=0;k--){
	  if(intersect_index[k][abs(inside_index) -1] < intersect_index[intersect_count-1][abs(inside_index) -1]){
	    if(intersect_index[n][abs(inside_index) -1] < intersect_index[k][abs(inside_index) -1]){
	      n = k;
	    }
	  }
	}
	for(i=0;i<2;i++){
	  itemp = intersect_index[intersect_count-1][i];
	  intersect_index[intersect_count-1][i] = intersect_index[n][i];
	  intersect_index[n][i] = itemp;
	}
      }
      inside_index = abs(inside_index) -1;
      
      for(k=intersect_count-2;k>=0;k--){
	if(intersect_index[k][inside_index] > intersect_index[intersect_count-1][inside_index]){
	  if(inside_index==1){
	    intersect_index[k][inside_index] -= to_merge.get_num_vertices();
	  }
	  else{
	    intersect_index[k][inside_index] -= in.get_num_vertices();
	  }
	}
      }
      
      for(k=intersect_count-2;k>=0;k--){
	for(n=k-1;n>=0;n--){
	  if(intersect_index[k][inside_index] < intersect_index[n][inside_index]){
	    for(i=0;i<2;i++){
	      itemp = intersect_index[k][i];
	      intersect_index[k][i] = intersect_index[n][i];
	      intersect_index[n][i] = itemp;
	    }
	  }
	}
      }
      
      for(k=intersect_count-2;k>=0;k--){
	if(intersect_index[k][inside_index] < 0){
	  if(inside_index==1){
	    intersect_index[k][inside_index] += to_merge.get_num_vertices();
	  }
	  else{
	    intersect_index[k][inside_index] += in.get_num_vertices();
	  }
	}
      }

      //
      if(libjeff::debug_setting::get_debug_mode_debug_message()){
	for(k=intersect_count-1;k>=0;k--){
	  std::cout << "Intersection list: " << inside_index << " " << intersect_index[k][0] << " " << intersect_index[k][1] << std::endl;
	}
      }

      bool *used = new bool [intersect_count];
      for(k=0;k<intersect_count;k++){
	used[k] = false;
      }

      bool done = false;
      bool topology_change = false;
      i = intersect_count-1;
      while(!done){
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Track of tracing: " << inside_index << " " << i << " " << intersect_index[i][inside_index]-1 << std::endl;
	}
	used[i] = true;
	if(inside_index==1){
	  out.add_vertex(-1,to_merge.get_vertices(intersect_index[i][inside_index]-1));
	  geometry_cal_2d_line_segs_intersect(in.get_vertices(intersect_index[i][0]),in.get_vertices(intersect_index[i][0]-1),to_merge.get_vertices(intersect_index[i][1]),to_merge.get_vertices(intersect_index[i][1]-1),temp_vertex);
	  out.add_vertex(-1,temp_vertex);
	  
	  done = false;
	  j = intersect_index[i][1-inside_index];
	  while(!done){
	    if(libjeff::debug_setting::get_debug_mode_debug_message()){
	      std::cout << 0 << " " << j << std::endl;
	    }
	    out.add_vertex(-1,in.get_vertices(j));
	    j++;
	    if(j==in.get_num_vertices()){
	      j=0;
	    }
	    
	    for(n=0;n<intersect_count;n++){
	      if(j==intersect_index[n][1-inside_index]){
		done = true;
		i = n;
		if(used[n]){
		  topology_change = true;
		}
	      }
	    }
	  }
	  inside_index = 0;
	}
	else{
	  out.add_vertex(-1,in.get_vertices(intersect_index[i][inside_index]-1));
	  geometry_cal_2d_line_segs_intersect(in.get_vertices(intersect_index[i][0]),in.get_vertices(intersect_index[i][0]-1),to_merge.get_vertices(intersect_index[i][1]),to_merge.get_vertices(intersect_index[i][1]-1),temp_vertex);
	  out.add_vertex(-1,temp_vertex);
	  
	  done = false;
	  j = intersect_index[i][1-inside_index];
	  while(!done){
	    if(libjeff::debug_setting::get_debug_mode_debug_message()){
	      std::cout << 0 << " " << j << std::endl;
	    }
	    out.add_vertex(-1,to_merge.get_vertices(j));
	    j++;
	    if(j==to_merge.get_num_vertices()){
	      j=0;
	    }
	    
	    for(n=0;n<intersect_count;n++){
	      if(j==intersect_index[n][1-inside_index]){
		done = true;
		i = n;
		if(used[n]){
		  topology_change = true;
		}
	      }
	    }
	  }
	  inside_index = 1;
	}

	done = true;
	for(k=0;k<intersect_count;k++){
	  if(!used[k]){
	    done = false;
	    break;
	  }
	}

	if(topology_change){
	  if(libjeff::debug_setting::get_debug_mode_debug_message()){
	    std::cout << "Change in topology " <<  i << std::endl;
	    std::cout << "Status of all intersection" << std::endl;
	    for(k=intersect_count-1;k>=0;k--){
	      std::cout << "Intersection list: " << inside_index << " " << intersect_index[k][0] << " " << intersect_index[k][1] << " " << used[k] << std::endl;
	    }
	  }
	  topology_change = false;

	  for(k=intersect_count-1;k>=0;k-=2){
	    if(!used[k]){
	      i=k;
	      break;
	    }
	  }
	}
      }

      delete [] used;
    }
    
    for(i=0;i<max_intersect;i++){
      delete [] intersect_index[i];
    }
    delete [] intersect_index;
    delete [] temp_vertex;
    
    if(update){
      return _ERRORCODE_NOERROR;
    }
    else{
      return _ERRORCODE_NOUPDATE;
    }
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_align_centroid(const polygon<double> &align_with,polygon<double> &to_align,double *displacement){
    if(!align_with.is_closed() || !to_align.is_closed()){
      return _ERRORCODE_INPUTERROR;
    }

    double *centroid1 = new double [2];
    double *centroid2 = new double [2];
    int i,j;

    for(j=0;j<2;j++){
      centroid1[j] = 0.;
      centroid2[j] = 0;
    }
    for(i=0;i<align_with.get_num_vertices()-1;i++){
      for(j=0;j<2;j++){
	centroid1[j] += align_with.get_vertices(i)[j];
      }
    }
    
    for(i=0;i<to_align.get_num_vertices()-1;i++){
      for(j=0;j<2;j++){
	centroid2[j] += to_align.get_vertices(i)[j];
      }
    }
    for(j=0;j<2;j++){
      centroid1[j] /= align_with.get_num_vertices()-1;
      centroid2[j] /= to_align.get_num_vertices()-1;
    }
    //std::cout << centroid1[0] << " " << centroid1[1] << std::endl;
    //std::cout << centroid2[0] << " " << centroid2[1] << std::endl;
    
    for(i=0;i<to_align.get_num_vertices();i++){
      for(j=0;j<2;j++){
	(to_align.get_vertices(i))[j] += centroid1[j] - centroid2[j];
      }
    }

    if(displacement != NULL){
      for(j=0;j<2;j++){
	displacement[j] = centroid1[j] - centroid2[j];
      }
    }

    delete [] centroid1;
    delete [] centroid2;
    
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_creating_morphing_pairs(const polygon<double> &st_polygon,const polygon<double> &end_polygon,polygon<double>* &morphing_pairs){
    polygon<double> moved_polygon = end_polygon;
    double *displacement = new double [2];
    int error = geometry_polygon_align_centroid(st_polygon,moved_polygon,displacement);
    if(error){
      delete [] displacement;
      return error;
    }

    if(morphing_pairs != NULL){
      delete [] morphing_pairs;
    }

    polygon<double> rh_st, rh_end;
    rh_st = st_polygon;
    rh_st.make_right_hand();
    rh_end = moved_polygon;
    rh_end.make_right_hand();

    geometry_simplify_polygon_by_area(rh_st,1e-16);
    geometry_simplify_polygon_by_area(rh_end,1e-16);

    int i,j,k;

    if(libjeff::debug_setting::get_debug_mode_debug_message()){
      std::cout << "[[";
      for(i=0;i<rh_st.get_num_vertices();i++){
	for(j=0;j<2;j++){
	  std::cout << (rh_st.get_vertices(i))[j] << (j==0?",":"");
	}
	std::cout << (i==rh_st.get_num_vertices()-1?"]],\n":"],[");
      }
      std::cout << "[[";
      for(i=0;i<rh_end.get_num_vertices();i++){
	for(j=0;j<2;j++){
	  std::cout << (rh_end.get_vertices(i))[j] << (j==0?",":"");
	}
	std::cout << (i==rh_end.get_num_vertices()-1?"]],\n":"],[");
      }
    }
    
    rh_st.open();
    rh_end.open();

    morphing_pairs = new polygon<double> [2];
    int **index = new int *[rh_end.get_num_vertices()];
    double **control_points = new double *[rh_end.get_num_vertices()];
    bool *used = new bool [rh_end.get_num_vertices()];
    int *matching = new int [rh_st.get_num_vertices()+rh_end.get_num_vertices()];
    int *vertex_map_vertex = new int [rh_end.get_num_vertices()];

    for(i=0;i<rh_end.get_num_vertices();i++){
      used[i] = false;
      vertex_map_vertex[i] = -1;
      index[i] = new int [2];
      control_points[i] = new double [2];
      geometry_pt_to_polygon_distance(rh_st,rh_end.get_vertices(i),control_points[i],index[i]);
      for(j=0;j<rh_st.get_num_vertices();j++){
	if(control_points[i][0] == rh_st.get_vertices(j)[0] && control_points[i][1] == rh_st.get_vertices(j)[1]){
	  vertex_map_vertex[i] = j;
	  break;
	}
      }
      //std::cout << index[i][0] << " " << control_points[i][0] << " " << control_points[i][1] << std::endl;
    }
    k=0;
    for(i=0;i<rh_st.get_num_vertices();i++){
      bool vertex_map = false;
      for(j=0;j<rh_end.get_num_vertices();j++){
	if(vertex_map_vertex[j]==i){
	  vertex_map = true;
	  break;
	}
      }

      if(vertex_map){
	for(j=0;j<rh_end.get_num_vertices();j++){
	  if(vertex_map_vertex[j]==i && !used[j]){
	    morphing_pairs[0].add_vertex(-1,control_points[j]);
	    matching[k++] = -j-1;
	    used[j] = true;
	  }
	}
      }
      else{
	for(j=0;j<rh_end.get_num_vertices();j++){
	  if(index[j][0] == i && !used[j] && control_points[j][0] == rh_st.get_vertices(i)[0] && control_points[j][1] == rh_st.get_vertices(i)[1]){
	    morphing_pairs[0].add_vertex(-1,control_points[j]); //control_point due to rh_end
	    matching[k++] = -j-1;
	    used[j] = true;
	  }
	}
	
	morphing_pairs[0].add_vertex(-1,rh_st.get_vertices(i)); //rh_st vertex
	matching[k++] = i;
	for(j=0;j<rh_end.get_num_vertices();j++){
	  if(index[j][0] == i && !used[j]){
	    morphing_pairs[0].add_vertex(-1,control_points[j]); //control_point due to rh_end
	    matching[k++] = -j-1;
	    used[j] = true;
	  }
	}
      }
    }
    for(i=0;i<rh_end.get_num_vertices()-1;i++){
      delete [] index[i];
      delete [] control_points[i];
    }
    delete [] vertex_map_vertex;
    delete [] index;
    delete [] control_points;
    delete [] used;

    index = new int *[morphing_pairs[0].get_num_vertices()];
    control_points = new double *[morphing_pairs[0].get_num_vertices()];
    for(i=0;i<morphing_pairs[0].get_num_vertices();i++){
      index[i] = new int [2];
      control_points[i] = new double [2];
      
      if(matching[i] >= 0){
	geometry_pt_to_polygon_distance(rh_end,rh_st.get_vertices(matching[i]),control_points[i],index[i]);
	for(j=0;j<morphing_pairs[0].get_num_vertices()-1;j++){
	  if(j!=i || j!=i+1){
	    //if(geometry_is_line_segs_intersect(control_points[i],
	  }
	}
	morphing_pairs[1].add_vertex(-1,control_points[i]);
      }
      else{
	morphing_pairs[1].add_vertex(-1,rh_end.get_vertices(-matching[i]-1));
      }
    }
    for(i=0;i<morphing_pairs[0].get_num_vertices();i++){
      delete [] index[i];
      delete [] control_points[i];
    }
    delete [] index;
    delete [] control_points;
    delete [] matching;

    morphing_pairs[0].add_vertex(-1,morphing_pairs[0].get_vertices(0));
    morphing_pairs[1].add_vertex(-1,morphing_pairs[1].get_vertices(0));

    double *temp_cp1 = new double [2];
    double *temp_cp2 = new double [2];
/*
    //checking if there would be any crossing
    for(i=0;i<morphing_pairs[0].get_num_vertices()-1;i++){
      if(morphing_pairs[0].get_vertices(i)[0] == morphing_pairs[0].get_vertices(i+1)[0] && morphing_pairs[0].get_vertices(i)[1] == morphing_pairs[0].get_vertices(i+1)[1]){
	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	    std::cout << "Checking activated." << std::endl;
	  }
	for(j=0;j<2;j++){
	  temp_cp1[j] = 0.5*(morphing_pairs[0].get_vertices(i)[j] + morphing_pairs[1].get_vertices(i)[j]);
	  temp_cp2[j] = 0.5*(morphing_pairs[0].get_vertices(i+1)[j] + morphing_pairs[1].get_vertices(i+1)[j]);
	}

	if(geometry_is_line_segs_intersect(temp_cp1,morphing_pairs[1].get_vertices(i),temp_cp2,morphing_pairs[1].get_vertices(i+1))){
	  if(libjeff::debug_setting::get_debug_mode_debug_message()){
	    std::cout << "Crossing detected." << std::endl;
	  }
	  for(j=0;j<2;j++){
	    temp_cp1[j] = morphing_pairs[1].get_vertices(i)[j];
	    morphing_pairs[1].get_vertices(i)[j] = morphing_pairs[1].get_vertices(i+1)[j];
	    morphing_pairs[1].get_vertices(i+1)[j] = temp_cp1[j];
	  }
	}
      }
      else if(morphing_pairs[1].get_vertices(i)[0] == morphing_pairs[1].get_vertices(i+1)[0] && morphing_pairs[1].get_vertices(i)[1] == morphing_pairs[1].get_vertices(i+1)[1]){
	for(j=0;j<2;j++){
	  temp_cp1[j] = 0.5*(morphing_pairs[0].get_vertices(i)[j] + morphing_pairs[1].get_vertices(i)[j]);
	  temp_cp2[j] = 0.5*(morphing_pairs[0].get_vertices(i+1)[j] + morphing_pairs[1].get_vertices(i+1)[j]);
	}

	if(geometry_is_line_segs_intersect(temp_cp1,morphing_pairs[0].get_vertices(i),temp_cp2,morphing_pairs[0].get_vertices(i+1))){
	  for(j=0;j<2;j++){
	    temp_cp1[j] = morphing_pairs[0].get_vertices(i)[j];
	    morphing_pairs[0].get_vertices(i)[j] = morphing_pairs[0].get_vertices(i+1)[j];
	    morphing_pairs[0].get_vertices(i+1)[j] = temp_cp1[j];
	  }
	}
      }
    }
*/
if(libjeff::debug_setting::get_debug_mode_debug_message()){
  std::cout << "[[";
  for(i=0;i<morphing_pairs[0].get_num_vertices();i++){
      for(j=0;j<2;j++){
	std::cout << (morphing_pairs[0].get_vertices(i))[j] << (j==0?",":"");
      }
      std::cout << (i==morphing_pairs[0].get_num_vertices()-1?"]],\n":"],[");
  }
std::cout << "[[";
  for(i=0;i<morphing_pairs[1].get_num_vertices();i++){
      for(j=0;j<2;j++){
	std::cout << (morphing_pairs[1].get_vertices(i))[j] << (j==0?",":"");
      }
      std::cout << (i==morphing_pairs[1].get_num_vertices()-1?"]],\n":"],[");
  }
}

    for(i=0;i<morphing_pairs[1].get_num_vertices();i++){
      for(j=0;j<2;j++){
	(morphing_pairs[1].get_vertices(i))[j] -= displacement[j];
      }
    }

if(libjeff::debug_setting::get_debug_mode_debug_message()){
  std::cout << "[[";
  for(i=0;i<morphing_pairs[1].get_num_vertices();i++){
      for(j=0;j<2;j++){
	std::cout << (morphing_pairs[1].get_vertices(i))[j] << (j==0?",":"");
      }
      std::cout << (i==morphing_pairs[1].get_num_vertices()-1?"]],\n":"],[");
  }
}
    
    delete [] displacement;
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_polygon_interpolate(int npairs,const polygon<double> *st_polygon,date_time *st_time,int noutput,date_time *target_time,polygon<double> *out,int coordinate_sys){
    if(npairs == 1 && noutput == 1){
      out[0] = st_polygon[0];
      return _ERRORCODE_NOERROR;
    }
    else if(npairs < 2 || noutput < 1){
      return _ERRORCODE_INPUTOUTOFRANGE;
    }

    bool *done = new bool [noutput];

    libjeff::polygon<double> *morphing_pairs = NULL;

    int i,j,k;
    for(i=0;i<noutput;i++){
      done[i] = false;
    }

    int error = _ERRORCODE_NOERROR;

    for(i=0;i<noutput;i++){
      if(!done[i]){
	//std::cout << i << " : ";
	for(j=1;j<npairs;j++){
	  if(target_time[i] >= st_time[j-1] && target_time[i] <= st_time[j]){
	    break;
	  }
	}

	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << j << " : " << st_time[j-1] << " " << st_time[j] << std::endl;
	}

	geometry_polygon_creating_morphing_pairs(st_polygon[j-1],st_polygon[j],morphing_pairs);

	double ratio = target_time[i].get_ratio_between(st_time[j-1],st_time[j]);
	geometry_create_polygon_from_morphing_pairs(morphing_pairs,ratio,out[i]);
	done[i] = true;

	for(k=0;k<i;k++){
	  if(!done[k]){
	    if(target_time[k] >= st_time[j-1] && target_time[k] <= st_time[j]){
	      ratio = target_time[k].get_ratio_between(st_time[j-1],st_time[j]);
	      geometry_create_polygon_from_morphing_pairs(morphing_pairs,ratio,out[k]);
	      done[k] = true;
	      //std::cout << k << " ";
	    }
	  }
	}
	for(k=i+1;k<noutput;k++){
	  if(!done[k]){
	    if(target_time[k] >= st_time[j-1] && target_time[k] <= st_time[j]){
	      ratio = target_time[k].get_ratio_between(st_time[j-1],st_time[j]);
	      geometry_create_polygon_from_morphing_pairs(morphing_pairs,ratio,out[k]);
	      done[k] = true;
	      //std::cout << k << " ";
	    }
	  }
	}
	//std::cout << endl;
      
      }
    }

    delete [] morphing_pairs;


    return error;
  }

  ###CPP### ###CUDA### ###HOST### int geometry_create_polygon_from_morphing_pairs(const polygon<double>* morphing_pairs,double time,polygon<double> &out){
    out.destroy();

    double *vertex = new double [2];
    
    int i,j;
    for(i=0;i<morphing_pairs[0].get_num_vertices();i++){
      for(j=0;j<2;j++){
	vertex[j] = (1-time)*(morphing_pairs[0].get_vertices(i)[j]) + time*(morphing_pairs[1].get_vertices(i)[j]);
      }
      out.add_vertex(-1,vertex);
    }
    
    delete [] vertex;
  
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### double geometry_pt_distance_from_line_seg(double *pt,double *line_pt1,double *line_pt2,double *nearest_pt){
    double *temp_vec1, *temp_vec2;

    temp_vec1 = new double [2];
    temp_vec2 = new double [2];
    double *line_dir = new double [3];

    int i;
    for(i=0;i<2;i++){
      temp_vec1[i] = line_pt1[i] - pt[i];
      temp_vec2[i] = line_pt2[i] - pt[i];
      line_dir[i] = line_pt2[i] - line_pt1[i];
    }
    
    double results;
    if(vector_dot_pro(2,temp_vec1,line_dir)*vector_dot_pro(2,temp_vec2,line_dir) < 0){
      line_dir[2] = 0.;
      double mag;
      mag = pow(vector_dot_pro(2,line_dir,line_dir),0.5);
      for(i=0;i<2;i++){
	line_dir[i] /= mag;
      }
      
      double *pt_line = new double [3];
      for(i=0;i<2;i++){
	pt_line[i] = pt[i] - line_pt1[i];
      }
      pt_line[2] = 0.;
      
      double *temp = new double [3];
      vector_cross_pro(line_dir,pt_line,temp);
      
      results = fabs(temp[2]);

      if(nearest_pt != NULL){
	mag = vector_dot_pro(2,pt_line,line_dir);
	for(i=0;i<2;i++){
	  nearest_pt[i] = line_pt1[i] + mag*line_dir[i];
	}
      }
      
      delete [] temp;
      delete [] pt_line;
    }
    else{
      results = pow(vector_dot_pro(2,temp_vec1,temp_vec1),0.5);
      if(nearest_pt != NULL){
	for(i=0;i<2;i++){
	  nearest_pt[i] = line_pt1[i];
	}
      }
      double temp_results = pow(vector_dot_pro(2,temp_vec2,temp_vec2),0.5);
      if(temp_results < results){
	results = temp_results;
	if(nearest_pt != NULL){
	  for(i=0;i<2;i++){
	    nearest_pt[i] = line_pt2[i];
	  }
	}
      }
    }

    delete [] temp_vec1;
    delete [] temp_vec2;
    delete [] line_dir;
    
    return results;
  }
  ###CPP### ###CUDA### ###HOST### double geometry_pt_to_polygon_distance(const polygon<double> &poly,double *pt,double *nearest_pt,int *index){
    int i,j;

    double results, temp_results;
    double *temp_pt = NULL;
    results = geometry_pt_distance_from_line_seg(pt,poly.get_vertices(0),poly.get_vertices(1),nearest_pt);
    if(nearest_pt != NULL){
      temp_pt = new double [2];
      index[0] = 0;
      index[1] = 1;
    }
    for(i=1;i<poly.get_num_vertices()-1;i++){
      temp_results = geometry_pt_distance_from_line_seg(pt,poly.get_vertices(i),poly.get_vertices(i+1),temp_pt);
      if(temp_results < results){
	results = temp_results;
	if(nearest_pt != NULL){
	  for(j=0;j<2;j++){
	    nearest_pt[j] = temp_pt[j];
	  }
	  index[0] = i;
	  index[1] = i+1;
	}
      }
    }
    if(nearest_pt != NULL){
      delete [] temp_pt;
    }

    return results;
  }
/*
  ###CPP### ###CUDA### ###HOST### int geometry_polygon_clipping_sutherland_hodgman(const polygon<double> &clip,const polygon<double> &subject,polygon<double>& out){
    if(!subject.is_closed() || !clip.is_closed()){
      return _ERRORCODE_INPUTERROR;
    }
    out.destroy();

    int i,j,k;
    /*
    double *st_vertex = NULL, *temp_vertex;
    int st_index;
    for(i=0;i<subject.get_num_vertices()-1;i++){
      if(geometry_is_pt_inside_polygon(clip,subject.get_vertices(i))){
	st_vertex = subject.get_vertices(i);
	st_index = i;
	break;
      }
    }

    double *intersect = new double [2];

    if(st_vertex == NULL){
      double *dir_s = new double [2];
      double *dir_c = new double [2];
      for(i=0;i<subject.get_num_vertices()-1&&st_vertex==NULL;i++){
	for(j=0;j<2;j++){
	  dir_s[j] = subject.get_vertices(i+1)[j] - subject.get_vertices(i)[j];
	}
	if(geometry_is_line_cut_polygon(clip,subject.get_vertices(i),dir_s)){
	  for(j=0;j<clip.get_num_vertices()-1;j++){
	    for(k=0;k<2;k++){
	      dir_c[k] = clip.get_vertices(j+1)[k] - subject.get_vertices(j)[k];
	    }
	    if(geometry_is_lines_intersect_between(clip.get_vertices(j),dir_c,subject.get_vertices(i),subject.get_vertices(i+1))){
	      geometry_cal_2d_line_intersect(clip.get_vertices(j),dir_c,subject.get_vertices(i),subject.get_vertices(i+1),intersect);
	      st_vertex = intersect;
	      st_index = i;
	      break;
	    }
	  }
	}
      }
      delete [] dir_s;
      delete [] dir_c;
    }

    bool in;
    in = true;
    if(st_vertex != NULL){
      for(i=st_index+1;i<subject.get_num_vertices()-1;i++){
	if(in){
	  for(j=0;j<2;j++){
	    dir_s[j] = subject.get_vertices(i+1)[j] - subject.get_vertices(i)[j];
	  }
	  if(geometry_is_line_cut_polygon(clip,
	}
	else{
	  
	}
      }
    }

    delete [] intersect;
    
    out = subject;
    polygon<double> temp_polygon;
    double *temp_vertex;
    double *dir_s = new double [2];
    double *dir_c = new double [2];
    for(i=0;i<clip.get_num_vertices()-1;i++){
      temp_polygon = out;
      out.destroy();
      for(k=0;k<2;k++){
	dir_c[k] = clip.get_vertices(i+1)[k] - subject.get_vertices(i)[k];
      }

      temp_vertex = temp_polygon.get_vertices(-1);
      for(j=0;j<temp_polygon.get_num_vertices()-1;j++){
	if(
      }
    }

    return _ERRORCODE_NOERROR;
  }
*/

  namespace triangulation{
    template <class vertice_type> triangulation<vertice_type>::triangulation(){
      ntriangles = 0;
      triangles = NULL;
    }
    template <class vertice_type> triangulation<vertice_type>::~triangulation(){
      this->destroy();
    }
    
    template <class vertice_type> int triangulation<vertice_type>::create(int ntriangles){
      if(ntriangles <= 0){
	return _ERRORCODE_INPUTOUTOFRANGE;
      }

      this->destroy();

      triangles = new polygon<vertice_type> [ntriangles];
      this->ntriangles = ntriangles;

      return _ERRORCODE_NOERROR;
    }
    template <class vertice_type> int triangulation<vertice_type>::destroy(){
      if(ntriangles > 0){
	delete [] triangles;
      }
      ntriangles = 0;

      return _ERRORCODE_NOERROR;
    }

    template <class vertice_type> polygon<vertice_type> *triangulation<vertice_type>::get_triangles(int index){
      if(index >= 0 && index < ntriangles){
	return triangles[index];
      }
      else{
	return NULL;
      }
    }
    template <class vertice_type> int triangulation<vertice_type>::set_triangles(int index,polygon<vertice_type> in){
      

      return _ERRORCODE_NOERROR;
    }

    template <class vertice_type> int delaunay_triangulation(int npt,double **pts,triangulation<vertice_type> *out){
    }
  };

}
