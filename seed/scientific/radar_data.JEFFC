###CUDA####include<cuda.h>
#include<iostream>
#include<fstream>
#include<stdint.h>
#include<cmath>
#include<cstring>
#include<gsl/gsl_wavelet.h>
#include<gsl/gsl_wavelet2d.h>
using namespace std;

#include "cinrad_header.h"
###CUDA####include "cuda_setting.h"
#include "date_time.h"
#include "debug_mode.h"
#include "earth.h"
#include "error_code.h"
#include "file_check.h"
#include "file_handler.h"
#include "grid_data.h"
#include "iris_header.h"
#include "mapTo2DGrid.h"
#include "melco_lidar_header.h"
#include "meteorology.h"
#include "physics_constants.h"
#include "radar_data.h"
#include "regular_grid.h"
#include "sorting.h"
#include "string_man.h"
#include "tags.h"
#include "tools.h"
#include "unstructured_grid.h"
#include "vector.h"

#define FILENAMEBUFFSIZE 4096
#define BUFFSIZE 4096

#define RADARPPI2CAPPIFGFILE "./ppi2cappi.fg"

int cinrad_radar_site_list::num_site = 0;
cinrad_radar_site* cinrad_radar_site_list::list = NULL;
cinrad_radar_site_list::cinrad_radar_site_list(){
  int error = this->create("./cinrad_site_list.csv");
  if(error){
    std::cout << "Failed to read the CINRAD site list." << std::endl;
  }
}
cinrad_radar_site_list::cinrad_radar_site_list(char* filename){
  int error = this->create(filename);
  if(error){
    std::cout << "Failed to read the CINRAD site list." << std::endl;
  }
}

int cinrad_radar_site_list::create(char* filename){
  num_site = libjeff::file_check_length(filename);

  if(num_site > 0){
    list = new cinrad_radar_site [num_site];
    int i;
    ifstream fin;
    char *ctemp = new char [BUFFSIZE];
    fin.open(filename);
    for(i=0;i<num_site;i++){
      fin.getline(ctemp,100,',');
      strcpy(list[i].sitecode,ctemp);
      fin.getline(ctemp,100,',');
      strcpy(list[i].sitename,ctemp);
      fin.getline(ctemp,100,',');
      list[i].lat = atof(ctemp);
      fin.getline(ctemp,100,',');
      list[i].lon = atof(ctemp);
      fin.getline(ctemp,100);
      list[i].height = atof(ctemp);
    }
    delete [] ctemp;
    fin.close();
  }
  else{
    return _ERRORCODE_FILEREADERROR;
  }

  return _ERRORCODE_NOERROR;
}

cinrad_radar_site* cinrad_radar_site_list::get_site_by_code(char* code){
  int i;
  for(i=0;i<num_site;i++){
    if(strcmp(list[i].sitecode,code)==0){
      return list+i;
    }
  }
  return NULL;
}
cinrad_radar_site* cinrad_radar_site_list::get_site_by_name(char* name){
  int i;
  for(i=0;i<num_site;i++){
    if(strcmp(list[i].sitename,name)==0){
      return list+i;
    }
  }
  return NULL;
}
bool cinrad_radar_site_list::is_initialized(){
  if(num_site > 0){
    return true;
  }
  else{
    return false;
  }
}

cinrad_header cinrad_header_convert(const cinrad_read_header& in){ //unit conversion and decoding
  cinrad_header out;

  out.UnambiguousRange = in.UnambiguousRange*100;
  out.AzimuthAngle = (in.AzimuthAngle >> 3)*0.043945;
  out.ElevationAngle = (in.ElevationAngle >> 3)*0.043945;
  out.FirstGateRangeOfRef = in.FirstGateRangeOfRef;
  out.FirstGateRangeOfDoppler = in.FirstGateRangeOfDoppler;
  out.RefGateSize = in.RefGateSize; 
  out.DopplerGateSize = in.DopplerGateSize;
  out.RefGates = in.RefGates;
  out.DopplerGates = in.DopplerGates;
  strncpy(out.FraCheSeq,in.FraCheSeq,4);

  out.RefPoint = in.RefPoint;
  out.VelPoint = in.VelPoint;
  out.SWPoint = in.SWPoint;
  out.VelResolution = in.VelResolution;
  out.RefPlaybackPoint = in.RefPlaybackPoint;
  out.VelPlaybackPoint = in.VelPlaybackPoint;
  out.SWPlaybackPoint = in.SWPlaybackPoint;

  return out;
}

char* drawline(char* temp){
  strcpy(temp,"#------------------------------------------------------------------#");
  return temp;
}
char* radarinfoline(char *temp,char *sitename,double lat,double lon,double height,date_time obstime,int num_data_location,int max_lev){
  char head[2048];
  strcpy(head,"RADAR  ");
  int numblank = 12 - strlen(sitename);
  int i;
  for(i=0;i<numblank;i++){
    strcat(head," ");
  }
  strcat(head,sitename);
  sprintf(temp,"%8.3f  %8.3f  %8.1f  ",lon,lat,height);
  strcat(head,temp);
  obstime.get_time("yyyy-mm-dd_hh:mm:ss",temp);
  strcat(head,temp);
  sprintf(temp,"%6d%6d",num_data_location,max_lev);
  strcat(head,temp);

  strcpy(temp,head);

  return temp;
}
char* radardataheaderline(char* temp,date_time obstime,double lat,double lon,double radar_height,int nlev){
  char head[2048];
  strcpy(head,"FM-128 RADAR   ");
  obstime.get_time("yyyy-mm-dd_hh:mm:ss",temp);
  strcat(head,temp);
  sprintf(temp,"  %12.3f  %12.3f  ",lat,lon);
  strcat(head,temp);
  sprintf(temp,"%8.1f  %6d",radar_height,nlev);
  strcat(head,temp);

  strcpy(temp,head);

  return temp;
}
char* radardataline(char* temp,double height,double vel,int velqc,double velerror,double dbz,int dbzqc,double dbzerror){
  char head[2048];
  strcpy(head,"   ");

  sprintf(temp,"%12.1f",height);
  strcat(head,temp);
  sprintf(temp,"%12.3f%4d%12.3f  %12.3f%4d%12.3f   ",vel,velqc,velerror,dbz,dbzqc,dbzerror);
  strcat(head,temp);

  strcpy(temp,head);

  return temp;
}

###CPP### ###CUDA### ###HOST### IRIS_Header* read_iris_product_header(libjeff::file_handler *file,IRIS_Header *fileheader){
  file->read((char*) fileheader,sizeof(IRIS_Header));

  return fileheader;
}

###CPP### ###CUDA### ###HOST### int set_with_iris_product_header(IRIS_Header *fileheader,grid_data* data_grid){
  if(fileheader==NULL){
    return _ERRORCODE_INPUTERROR;
  }
  data_grid->create((int) fileheader->ProductConfigurationStructure.XSizeArray,(int) fileheader->ProductConfigurationStructure.YSizeArray,(int) fileheader->ProductConfigurationStructure.ZSizeArray,1);

  double *x, *y, *z;
  x = new double [fileheader->ProductConfigurationStructure.XSizeArray];
  y = new double [fileheader->ProductConfigurationStructure.YSizeArray];
  z = new double [fileheader->ProductConfigurationStructure.ZSizeArray];
  
  double center_latlon[2], temp_latlon[2][2], delta[2];
  double xmin, ymin;
  center_latlon[0] = binaryangle2double(fileheader->ProductEndStructure.CenterLatitude);
  center_latlon[1] = binaryangle2double(fileheader->ProductEndStructure.Centerlongitude);

  libjeff::earth_cal_latlon_from_dist_bearing(center_latlon,(fileheader->ProductConfigurationStructure.XSizeArray*0.5 - 0.5)*fileheader->ProductConfigurationStructure.Xscale/100.,270.,temp_latlon[0]);
  libjeff::earth_cal_latlon_from_dist_bearing(center_latlon,(fileheader->ProductConfigurationStructure.XSizeArray*0.5 - 0.5 - 1.)*fileheader->ProductConfigurationStructure.Xscale/100.,270.,temp_latlon[1]);
  delta[0] = temp_latlon[1][1] - temp_latlon[0][1];
  xmin = temp_latlon[0][1];
  libjeff::earth_cal_latlon_from_dist_bearing(center_latlon,(fileheader->ProductConfigurationStructure.YSizeArray*0.5 - 0.5)*fileheader->ProductConfigurationStructure.Yscale/100.,180.,temp_latlon[0]);
  libjeff::earth_cal_latlon_from_dist_bearing(center_latlon,(fileheader->ProductConfigurationStructure.YSizeArray*0.5 - 0.5 -1.)*fileheader->ProductConfigurationStructure.Yscale/100.,180.,temp_latlon[1]);
  delta[1] = temp_latlon[1][0] - temp_latlon[0][0];
  ymin = temp_latlon[0][0];

  int i;
  for(i=0;i<fileheader->ProductConfigurationStructure.ZSizeArray;i++){
    z[i] = (((struct ndop_psi_struct *) &fileheader->ProductConfigurationStructure.productInfo)->CAPPIHeight + i*fileheader->ProductConfigurationStructure.Zscale)/100;
  }
  for(i=0;i<fileheader->ProductConfigurationStructure.YSizeArray;i++){
    y[i] = ymin+i*delta[1];
  }
  for(i=0;i<fileheader->ProductConfigurationStructure.XSizeArray;i++){
    x[i] = xmin+i*delta[0];
  }

  data_grid->set_x(x);
  data_grid->set_y(y);
  data_grid->set_z(z);

  delete [] x;
  delete [] y;
  delete [] z;

  return _ERRORCODE_NOERROR;
}

###CPP### ###CUDA### ###HOST### int read_melco_lidar_los(libjeff::file_handler *file,grid_data* data_grid){
  ME_LIDAR_File_Header file_header;
  ME_LIDAR_Data_Header data_header;

  int error = file->read((char*) &file_header,sizeof(ME_LIDAR_File_Header));
  
  int i,j,k;
  float* in_los_data;
  double *los_data;
  in_los_data = new float [file_header.dataNum*file_header.ucrngnum*8];
  los_data = new double [file_header.dataNum*file_header.ucrngnum*8];
 
  double *az = new double [file_header.dataNum];
  double *el = new double [file_header.dataNum];

  if(libjeff::debug_setting::get_debug_mode_debug_message()){
    std::cout << "Number of data: " << file_header.dataNum << std::endl;
  }

  for(i=0;i<file_header.dataNum;i++){
    file->read((char*) &data_header,sizeof(ME_LIDAR_Data_Header));

    az[i] = data_header.averageAz;
    el[i] = data_header.averageEl;

    file->read((char *) (in_los_data+i*file_header.ucrngnum*8),file_header.ucrngnum*8*sizeof(float));
  }

  for(i=0;i<file_header.dataNum;i++){
    for(j=0;j<file_header.ucrngnum;j++){
      for(k=0;k<4;k++){
	los_data[i*file_header.ucrngnum*8+j*8+k] = in_los_data[i*file_header.ucrngnum*8+k*file_header.ucrngnum+j];
      }
      for(k=4;k<8;k++){
	los_data[i*file_header.ucrngnum*8+j*8+k] = ((int*) in_los_data)[i*file_header.ucrngnum*8+k*file_header.ucrngnum+j];
      }
    }
  }
  delete [] in_los_data;

  double *range= new double [file_header.ucrngnum];
  for(i=0;i<file_header.ucrngnum;i++){
    range[i] = file_header.rmin + i*file_header.rngbin;
  }

  data_grid->create(file_header.dataNum,1,file_header.ucrngnum,8); //assuming mapTo2DGrid, y dimension is ignored in allocation
  data_grid->set_x(el);
  data_grid->set_y(az);
  data_grid->set_z(range);
  data_grid->set_data(los_data);
  delete [] los_data;
  delete [] az;
  delete [] el;
  delete [] range;

  return error;
}

###CPP### ###CUDA### ###HOST### void set_iris_raw_product(double &to_set,int data_type,uint8_t value,double nyquist,double wavelength){
  if(value!=0){
    switch(data_type){
    case 1:
    case 2:
      to_set = byte2reflectivity(value);
      break;
    case 3:
      to_set = byte2velocity(value,nyquist);
      break;
    case 4:
      to_set = byte2width(value);
      break;
    case 5:
      to_set = byte2ZDR(value);
      break;
    case 14:
      to_set = byte2KDP(value,wavelength);
      break;
    case 16:
      to_set = byte2PhiDP(value);
      break;
    case 17:
      to_set = byte2velocity(value,75.);
      break;
    case 18:
      to_set = byte2SQI(value);
      break;
    case 19:
      to_set = byte2RhoHV(value);
      break;
    case 55:
      
      break;
    default:
      cout << "You should not get here. There is bug." << endl;
      break;
    }
  }
}

###CPP### ###CUDA### ###HOST### ###DEVICE### double binaryangle2double(uint32_t in){
  return 360.*(in)/pow(2.,32.);
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double binaryangle2double(uint16_t in){
  return 360.*(in)/pow(2.,16.);
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double twobyte2vel(uint16_t in,double missing){
  if(in==0 || in==65535){
    return missing;
  }
  else{
    return (in-32768.)/100.;
  }
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double twobyte2reflectivity(uint16_t in,double missing){
  if(in==0 || in==65535){
    return missing;
  }
  else{
    return (in-32768.)/100.;
  }
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double twobyte2rainfall(uint16_t in,double missing){
  if(in==0 || in==65535){
    return missing;
  }
  else{
    uint8_t exp = in >> 12;
    int mantissa = ((int) ((uint16_t) in << 4) >> 4);

    if(exp==0){
      return ((double) mantissa)*0.0001;
    }
    else{
      return ((double) (mantissa << (exp - 1)))*0.0001;
    }
  }
}
// ------------------------------------------------------------------
// This section of code is provided by 2015 A2 summer intern Cherry
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2velocity(uint8_t in,double Nyquist){
  return ((double) (in-128.)/127.)*Nyquist;
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2reflectivity(uint8_t in){
  return ((in)-64.)/2.;
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2width(uint8_t in){
  return (in)/256.;
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2ZDR(uint8_t in){
  return ((in)-128.)/16.;
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2KDP(uint8_t in,double wavelength){
  if ((in) > 128.) return (0.25*600.*(((in)-129.)/126.))/(wavelength);
  else return (-0.25*600.*((127.-(in))/126.))/(wavelength);
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2PhiDP(uint8_t in){
  return (180.*(((in)-1.)/254.));
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2VELC(uint8_t in){
  return (((in)-128.)/127.)*75.;
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2SQI(uint8_t in){
  return sqrt(((in)-1)/253.);
}
###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2RhoHV(uint8_t in){
  return sqrt(((in)-1)/253.);
}
// ------------------------------------------------------------------
namespace cinrad{
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2reflectivity(uint8_t in, double missing_value){
    if(in==0 || in==1){
      return missing_value;
    }
    else{
      return (((double) in) - 2)/2. - 32.;
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double byte2velocity(uint8_t in,short int velRes, double missing_value){
    if(in==0 || in==1){
      return missing_value;
    }
    else{
      switch(velRes){
      case 2:
	return (((double) in) - 2)/2. - 63.5;
	break;
      case 4:
	return (((double) in) - 2) - 127.0;
	break;
      }
    }
  }
};
###CPP### ###CUDA### ###HOST### radar_data::radar_data(){
  ndim = 0;
  data_grid = NULL;
  missing_value = -9999.;
  coordSys = 0;
  dbz_index = -1;
  dv_index = -1;
  zdr_index = -1;
  kdp_index = -1;
  phidp_index = -1;
  rhoHV_index = -1;
}
###CPP### ###CUDA### ###HOST### radar_data::~radar_data(){
  this->destroy();
}
###CPP### ###CUDA### ###HOST### void radar_data::destroy(){
  if(ndim > 1){
    delete [] data_grid;
  }
  else if(ndim == 1){
    delete data_grid;
  }
  ndim = 0;
  dbz_index = -1;
  dv_index = -1;
  zdr_index = -1;
  kdp_index = -1;
  phidp_index = -1;
  rhoHV_index = -1;
}


//-------------------------------------------
date_time get_time_melco_LIDAR_filename(char *filename){
  date_time result;
  
  char *ctemp = new char [FILENAMEBUFFSIZE];
  if(strstr(filename,"_")!=NULL){
    strcpy(ctemp,strstr(filename,"_")+1);
	  //std::cout << ctemp << std::endl;
    if(strstr(ctemp,"_")!=NULL){
      *strstr(ctemp,"_") ='\0';
    }
    result.set_time(ctemp);
  }
  delete [] ctemp;

  return result;
}

void melco_LIDAR_filename_set_equal(char *a,char *b){
  std::strcpy(b,a);
}
bool melco_LIDAR_filename_is_earlier(char *a,char *b){
  return (get_time_melco_LIDAR_filename(a) < get_time_melco_LIDAR_filename(b));
}

//-------------------------------------------
###CPP### ###CUDA### ###HOST### int radar_data::read_melco_lidar_los_ppi(char *filename){
  libjeff::file_handler *file = NULL;
  int error_code = _ERRORCODE_NOERROR;
  
  grid_data* temp_data = new mapTo2DGrid;
  openfile(file,filename);
  int temp_error = read_melco_lidar_los(file,temp_data);
  if(temp_error != _ERRORCODE_NOERROR){
    error_code = temp_error;
  }
  file->close();

  if(error_code == _ERRORCODE_NOERROR){
    if(ndim > 1){
      delete [] data_grid;
    }
    else if(ndim == 1){
      delete data_grid;
    }
    ndim = 1;
    data_grid = new mapTo2DGrid;
    this->coordSys = 2;
    int num_az = temp_data->get_nx(); 

    char *file_name = new char [FILENAMEBUFFSIZE];
    string_reverse(filename,file_name);
    if(strstr(file_name,"/")!=NULL){
      *strstr(file_name,"/")='\0';
    }
    string_reverse(file_name,file_name);
    this->scan_time = get_time_melco_LIDAR_filename(file_name);
    delete [] file_name;
    
    if(num_az > 0 && temp_data->get_nz() > 0){
      data_grid->create(num_az,1,temp_data->get_nz(),8);
      data_grid->set_data(temp_data->get_data());
      data_grid->set_z(temp_data->get_z());
      data_grid->set_x(temp_data->get_x());
      data_grid->set_y(temp_data->get_y());
    }
  }
  else{
    error_code = _ERRORCODE_FILEREADERROR;
  }
  
  delete temp_data;

  if(file != NULL){
    delete file;
  }
  
  return error_code;
}
###CPP### ###CUDA### ###HOST### int radar_data::read_melco_lidar_los_ppi(char *data_path,char *scan_type,date_time scan_time,date_time tolerance){
  int* num_file = new int [3];
  char ***filename = new char **[3];;
  char *ctemp = new char [FILENAMEBUFFSIZE];
  char *ctemp2 = new char [FILENAMEBUFFSIZE];
  date_time temp_time;

  tags t_obstime("obs time");

  int i,j,k;
  for(j=0;j<3;j++){
    std::strcpy(ctemp2,data_path);
    //std::strcat(ctemp2,"/");
    switch(j){
    case 0:
      temp_time = scan_time - ONE_DAY;
      break;
    case 1:
      temp_time = scan_time;
      break;
    case 2:
      temp_time = scan_time + ONE_DAY;
      break;
    }
    //std::strcat(ctemp2,temp_time.get_time("yyyymmdd",ctemp));
    t_obstime.replace(ctemp2,temp_time);

    libjeff::file_check_list_item(ctemp2,filename[j],num_file[j]);

    if(libjeff::debug_setting::get_debug_mode_debug_message()){
      if(num_file[j] > 0){
	for(i=0;i<num_file[j];i++){
	  std::cout << filename[j][i] << std::endl;
	}
      }
      else{
	std::cout << "No file found in " << ctemp2 << std::endl;
      }
    }
  }

  int num_match_file = 0;
  bool **match=new bool* [3];
  for(j=0;j<3;j++){
    if(num_file[j] > 0){
      match[j] = new bool [num_file[j]];
    }
    for(i=0;i<num_file[j];i++){
      match[j][i] = false;
      if(strstr(filename[j][i],scan_type)!=NULL){
	if(strstr(filename[j][i],"_")!=NULL){
	  strcpy(ctemp,strstr(filename[j][i],"_")+1);
	  //std::cout << ctemp << std::endl;

	  if(ctemp[15]=='_' && strncmp(ctemp+16,scan_type,strlen(scan_type))==0){
	    ctemp[15]='\0';
	    temp_time.set_time(ctemp);
	    if(libjeff::debug_setting::get_debug_mode_debug_message()){
	      std::cout << filename[j][i] << " " << temp_time << " ";
	    }
	    if(temp_time <= scan_time + tolerance && temp_time >= scan_time - tolerance){
	      match[j][i] = true;
	      num_match_file++;
	      if(libjeff::debug_setting::get_debug_mode_debug_message()){
		std::cout << "match." << std::endl;
	      }
	    }
	    else if(libjeff::debug_setting::get_debug_mode_debug_message()){
	      std::cout << "not match." << std::endl;
	    }
	  }
	}
      }
    }
  }

  int error_code = _ERRORCODE_NOERROR;
  if(num_match_file>0){
    grid_data **temp_data;
    temp_data = new grid_data* [num_match_file];
    for(i=0;i<num_match_file;i++){
      temp_data[i] = new mapTo2DGrid;
    }
    
    char *temp_ordered_filename = new char [num_match_file*FILENAMEBUFFSIZE];
    char **ordered_filename = new char* [num_match_file];
    for(i=0;i<num_match_file;i++){
      ordered_filename[i] = new char [FILENAMEBUFFSIZE];
    }
    
    j=0;
    for(k=0;k<3;k++){
      for(i=0;i<num_file[k];i++){
	if(match[k][i]){
	  std::strcpy(temp_ordered_filename+j*FILENAMEBUFFSIZE,filename[k][i]);
	  j++;
	}
      }
    }
    
    general_sort(num_match_file,FILENAMEBUFFSIZE,temp_ordered_filename,melco_LIDAR_filename_set_equal,melco_LIDAR_filename_is_earlier);
    
    for(i=0;i<num_match_file;i++){
      std::strcpy(ordered_filename[i],temp_ordered_filename+i*FILENAMEBUFFSIZE);
      if(libjeff::debug_setting::get_debug_mode_debug_message()){
	std::cout << "Ordered file: " << i << " " << ordered_filename[i] << std::endl;
      }
    }
    delete [] temp_ordered_filename;
    
    libjeff::file_handler *file=NULL;
    for(i=0;i<num_match_file;i++){
      strcpy(ctemp,data_path);
      t_obstime.replace(ctemp,get_time_melco_LIDAR_filename(ordered_filename[i]));
      strcat(ctemp,ordered_filename[i]);
      openfile(file,ctemp);
      // cout << ctemp << endl;
      int temp_error = read_melco_lidar_los(file,temp_data[i]);
      if(temp_error != _ERRORCODE_NOERROR){
	error_code = temp_error;
      }
      file->close();
      
      delete file;
      file = NULL;
    }

    for(i=1;i<num_match_file;i++){
      if(temp_data[i]->get_nz() != temp_data[0]->get_nz()){
	error_code = _ERRORCODE_FILESINCONSISTENCE;
	break;
      }
    }
    
    if(error_code == _ERRORCODE_NOERROR){
      if(ndim > 1){
	delete [] data_grid;
      }
      else if(ndim == 1){
	delete data_grid;
      }
      ndim = 1;
      data_grid = new mapTo2DGrid;
      this->coordSys = 2;
      int num_az = 0;
      this->scan_time = get_time_melco_LIDAR_filename(ordered_filename[0]);
      for(i=0;i<num_match_file;i++){
	num_az += temp_data[i]->get_nx(); 
      }
      
      if(num_az > 0 && temp_data[0]->get_nz() > 0){
	data_grid->create(num_az,1,temp_data[0]->get_nz(),8);
	double *combine_data = new double [num_az*temp_data[0]->get_nz()*8];
	
	k=0;
	for(i=0;i<num_match_file;i++){
	  for(j=0;j<temp_data[i]->get_nx()*temp_data[i]->get_nz()*8;j++){
	    combine_data[k] = (temp_data[i]->get_data())[j];
	    k++;
	  }
	}
	data_grid->set_data(combine_data);
	data_grid->set_z(temp_data[0]->get_z());
	delete [] combine_data;
      
	combine_data = new double [num_az];
	k=0;
	for(i=0;i<num_match_file;i++){
	  for(j=0;j<temp_data[i]->get_nx();j++){
	    combine_data[k] = (temp_data[i]->get_x())[j];
	    k++;
	  }
	}
	data_grid->set_x(combine_data);
	
	k=0;
	for(i=0;i<num_match_file;i++){
	  for(j=0;j<temp_data[i]->get_nx();j++){
	    combine_data[k] = (temp_data[i]->get_y())[j];
	    k++;
	  }
	}
	data_grid->set_y(combine_data);
	delete [] combine_data;
      }
      else{
	error_code = _ERRORCODE_FILEREADERROR;
      }
    }
    
    for(i=0;i<num_match_file;i++){
      delete [] ordered_filename[i];
    }
    delete [] ordered_filename;
    for(i=0;i<num_match_file;i++){
      temp_data[i]->destroy();
      delete temp_data[i];
    }
    delete [] temp_data;
  }
  else{
    error_code = _ERRORCODE_FILENOTFOUND;
  }

  for(j=0;j<3;j++){
    if(num_file[j] > 0){
      for(i=0;i<num_file[j];i++){
	delete [] filename[j][i];
      }
      delete [] match[j];
      delete [] filename[j];
    }
  }
  delete [] filename;
  delete [] match;
  delete [] num_file;

  delete [] ctemp;
  delete [] ctemp2;

  return error_code;
}

###CPP### ###CUDA### ###HOST### int radar_data::read_iris_raw_ppi(char *filename){
  if(ndim > 1){
    delete [] data_grid;
  }
  else if(ndim == 1){
    delete data_grid;
  }

  this->coordSys = 2;

  const int BLOCK_SIZE = 6144;
  ifstream fin;

  IRIS_Header_Block fileheaderblock;
  Ingest_Header_Block ingestheaderblock;

//std::cout << "Filename : " << filename << endl;

  fin.open(filename);
  fin.read((char*) &fileheaderblock,sizeof(IRIS_Header_Block));

  if(fileheaderblock.irisHeader.ProductConfigurationStructure.ProductTypeCode!=15){
    cout << "Error in reading file " << filename << endl << "It is not a raw product." << endl;
    fin.close();
    return 1;
  }
  ndim = 1;
  data_grid = new regular_grid;

  int numblock = fileheaderblock.irisHeader.StructureHeader.NumberOfBytesEntireStructure/BLOCK_SIZE;
  int numBinPerBeam = fileheaderblock.irisHeader.ProductEndStructure.NumberOfOutputBins;
  //cout << fileheaderblock.irisHeader.ProductConfigurationStructure.ProductTypeCode << endl;
  //cout << numblock << " " << numBinPerBeam << " " << ((uint32_t) numBinPerBeam) << endl;
  //reverse_endian(&numBinPerBeam);
  //reverse_endian(&(fileheaderblock.irisHeader.StructureHeader.FormatVersionNumber));
  //cout << fileheaderblock.irisHeader.StructureHeader.StructureIdentifier << " " << fileheaderblock.irisHeader.StructureHeader.FormatVersionNumber <<  endl;

  fin.read((char*) &ingestheaderblock,sizeof(Ingest_Header_Block));
  //cout << ingestheaderblock.ingest_header.StructureHeader.StructureIdentifier << endl;

  this->site_lat = binaryangle2double(ingestheaderblock.ingest_header.ingestConfig.lat);
  this->site_lon = binaryangle2double(ingestheaderblock.ingest_header.ingestConfig.lon);
  this->site_height = ingestheaderblock.ingest_header.ingestConfig.heightOfGround + ingestheaderblock.ingest_header.ingestConfig.heightAboveGround;
  //cout << site_lat << " " << site_lon << " " << site_height << endl;

  int numRay = ingestheaderblock.ingest_header.ingestConfig.numRays;
  int numSweep = ingestheaderblock.ingest_header.taskConfig.scanInfo.numSweep;
    //ingestConfig.numSweep;
  int numElement = ingestheaderblock.ingest_header.ingestConfig.num_assoc_datafile/numSweep;

  //cout << numSweep << " " << numRay << " " << numBinPerBeam << " " << numElement << endl;

  this->data_grid->create(numSweep,numRay,numBinPerBeam,numElement);
  this->fill_missing_value();

  double *range = new double [numBinPerBeam];
  int i,j,k;
  for(i=0;i<numBinPerBeam;i++){
    range[i] = ingestheaderblock.ingest_header.taskConfig.rangeInfo.firstBinRange + (ingestheaderblock.ingest_header.taskConfig.rangeInfo.lastBinRange - ingestheaderblock.ingest_header.taskConfig.rangeInfo.firstBinRange)/(numBinPerBeam - 1.0)*i;
    range[i]*=0.01;
  }
  this->data_grid->set_z(range);
  delete [] range;

  int block_count = 2;

  raw_Prod_bdhr rawProdBhdr;
  Ingest_Data_Header *ingestDataHeader;// = new Ingest_Data_Header [numElement];

  int16_t itemp, numword;
  double wavelength = ingestheaderblock.ingest_header.taskConfig.miscInfo.wavelength*0.01;
  //Nyquist velocity = PRF * wavelength *0.25
  double nyquist = 0.25*ingestheaderblock.ingest_header.taskConfig.dspInfo.prf * (wavelength*0.01);
  switch(ingestheaderblock.ingest_header.taskConfig.dspInfo.prfmodeFlag){
  case 1:
    nyquist*=2.;
    break;
  case 2:
    nyquist*=3.;
    break;
  case 3:
    nyquist*=4.;
    break;
  }

  scan_time.set_time(ingestheaderblock.ingest_header.ingestConfig.scanTime.Year,
		     ingestheaderblock.ingest_header.ingestConfig.scanTime.Month,
		     ingestheaderblock.ingest_header.ingestConfig.scanTime.Day,
		     0,
		     0,
		     ingestheaderblock.ingest_header.ingestConfig.scanTime.SecondsSinceMidnight);
  //date_time hkt2utc(0,0,0,8);
  scan_time -= HKT2UTC;

  uint16_t *uitemp; //= new uint16_t[numBinPerBeam];
  uint8_t *ubtemp; //= (uint8_t*) uitemp;

  double azimuth1, azimuth2;
  double elevation;

  //Please refer to IRIS Programmer Manual for details, if you can understand
  char *block_store = new char [(numblock-2)*BLOCK_SIZE];
  fin.read(block_store,sizeof(char)*(numblock-2)*BLOCK_SIZE);
  fin.close();

  int count=0;
  //remove raw_Prod_bdhr in the memory as they are useless
  for(j=0;j<numblock-2;j++){
    for(i=sizeof(raw_Prod_bdhr);i<BLOCK_SIZE;i++){
      block_store[count] = block_store[j*BLOCK_SIZE+i];
      count++;
    }
  }

  int bin_index = 0, ray_index = 0, sweep_index = 0, data_index=0;
  block_count = 0;
  int read_count = 0;
  while(read_count < (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
    //cout << "Debug index: " << bin_index << " " << data_index << " " << ray_index << " " << sweep_index << endl;
    if(bin_index == 0 && ray_index == 0 && data_index == 0){
      //beginning of a sweep
      ingestDataHeader = (Ingest_Data_Header*) (block_store+read_count);
      read_count += numElement*sizeof(Ingest_Data_Header);
      /*
      for(i=0;i<numElement;i++){
	cout << ingestDataHeader[i].StructureHeader.StructureIdentifier << " " << ingestDataHeader[i].dataType << " " << binaryangle2double(ingestDataHeader[i].sweep_angle) << " " << ingestDataHeader[i].indexOfFirstRay << " " << ingestDataHeader[i].Irtotl << " " << ingestDataHeader[i].Iwritn <<  " " << ingestDataHeader[i].numBitsPerBin << endl;
      }
      */
    }

    if(bin_index == 0){
      numword=*((int16_t *) (block_store+read_count));
      read_count += sizeof(int16_t);
      //cout << "Numword = " << numword << " " << (int16_t) (numword-32768) << endl;
      while(numword==0 && read_count < (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
	numword=*((int16_t *) (block_store+read_count));
	read_count += sizeof(int16_t);
      }
      while(numword==1 && read_count < (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
	numword=*((int16_t *) (block_store+read_count));
	read_count += sizeof(int16_t);

	data_index++;
	if(data_index >= numElement){
	  data_index = 0;
	  ray_index++;
	}
      }
      if(read_count >= (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
	break;
      }
      numword+=32768;
      //cout << "Numword = " << numword << " " << (int16_t) (numword-32768) << endl;
      for(i=0;i<4;i++){
	uitemp=((uint16_t *) (block_store+read_count));
	read_count += sizeof(uint16_t);
	//cout << binaryangle2double(uitemp[0]) << endl;
	switch(i){
	case 0:
	  azimuth1 = binaryangle2double(uitemp[0]);
	  break;
	case 1:
	  elevation = binaryangle2double(uitemp[0]);
	  break;
	case 2:
	  azimuth2 = binaryangle2double(uitemp[0]);
	  break;
	}
      }
      if(azimuth1 > 270. && azimuth2 < 90.){
	azimuth1 -= 360.;
      }
      switch(ingestDataHeader[data_index].dataType){
      case 1:
      case 2:
	dbz_index = data_index;
	break;
      case 3:
	dv_index = data_index;
	break;
      case 5:
	zdr_index = data_index;
	break;
      case 14:
	kdp_index = data_index;
	break;
      case 16:
	phidp_index = data_index;
	break;
      case 19:
	rhoHV_index = data_index;
	break;
      }
      this->set_y(ray_index,0.5*(azimuth1 + azimuth2));
      this->set_x(sweep_index,elevation);
      //itemp=((int16_t *) (block_store+read_count));
      read_count += sizeof(int16_t);
      //uitemp=((uint16_t *) (block_store+read_count));
      read_count += sizeof(uint16_t);
      numword-=6;

      if(numword > 0){
	ubtemp=((uint8_t *) (block_store+read_count));
	read_count += numword*sizeof(uint16_t);
	
	for(i=0;i<numword*2;i++){
	  set_iris_raw_product((this->data_grid->get_data(sweep_index,ray_index,bin_index))[data_index],ingestDataHeader[data_index].dataType,ubtemp[i],nyquist,wavelength);
	  bin_index++;
	}
      }
      else{
	numword=*((int16_t *) (block_store+read_count));
	read_count += sizeof(int16_t);
	if(numword>0){
	  //cout <<  "Skip Numword = " << numword << " " << read_count << " " << (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr)) << endl;
	  if(numword == 1){
	    //end of bins found, next data type
	    //cout << "End of ray reached: " << data_index << " " << bin_index << " " << ray_index << " " << sweep_index << endl;
	    data_index++;
	    bin_index = 0;
	    
	    //check for end of a ray
	    if(data_index >= numElement){
	      data_index = 0;
	      ray_index++;
	    }
	    
	    //check for end of sweep
	    if(ray_index >= numRay){
	      ray_index = 0;
	      sweep_index++;

	      numword=*((int16_t *) (block_store+read_count));
	      while(numword==0 && read_count < (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
		read_count += sizeof(int16_t);
		numword=*((int16_t *) (block_store+read_count));
	      }
	      if(read_count >= (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
		break;
	      }
	    }
	  }
	  else if(numword > 2){
	    bin_index+=numword*2;
	  }
	}
	else{
	  numword+=32768;
	  //cout <<  "Read Numword = " << numword << " " << read_count << " " << (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr)) << endl;

	  ubtemp=((uint8_t *) (block_store+read_count));
	  read_count += numword*sizeof(uint16_t);

	  for(i=0;i<numword*2;i++){
	    set_iris_raw_product((this->data_grid->get_data(sweep_index,ray_index,bin_index))[data_index],ingestDataHeader[data_index].dataType,ubtemp[i],nyquist,wavelength);
	    bin_index++;
	  }
	}
      }
    }
    else{
      numword=*((int16_t *) (block_store+read_count));
      read_count += sizeof(int16_t);

      if(numword>0){
	//cout <<  "Skip Numword = " << numword << " " << read_count << " " << (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr)) << endl;
	if(numword == 1){
	  //end of bins found, next data type
	  //cout << "End of ray reached: " << data_index << " " << bin_index << " " << ray_index <<  " " << sweep_index << endl;
	  data_index++;
	  bin_index = 0;
	  
	  //check for end of a ray
	  if(data_index >= numElement){
	    data_index = 0;
	    ray_index++;
	  }
	  
	  //check for end of sweep
	  if(ray_index >= numRay){
	    ray_index = 0;
	    sweep_index++;

	    numword=*((int16_t *) (block_store+read_count));
	    while(numword==0 && read_count < (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
	      read_count += sizeof(int16_t);
	      numword=*((int16_t *) (block_store+read_count));
	    }
	    if(read_count >= (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr))){
	      break;
	    }
	  }
	}
	else if(numword > 2){
	  bin_index+=numword*2;
	}
      }
      else{
	numword+=32768;
	//cout <<  "Read Numword = " << numword << " " << read_count << " " << (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr)) << endl;
	
	ubtemp=((uint8_t *) (block_store+read_count));
	read_count += numword*sizeof(uint16_t);
	
	for(i=0;i<numword*2;i++){
	  set_iris_raw_product((this->data_grid->get_data(sweep_index,ray_index,bin_index))[data_index],ingestDataHeader[data_index].dataType,ubtemp[i],nyquist,wavelength);
	  bin_index++;
	}
      }
    }
  }
  //cout << "Final check: " << read_count << " " << (numblock-2)*(BLOCK_SIZE - sizeof(raw_Prod_bdhr)) << endl;

  delete [] block_store;
  fin.close();
  
  this->data_grid->set_y_periodic();
  this->data_grid->set_y_period(360.);
  
  return 0;
}

###CPP### ###CUDA### ###HOST### int radar_data::read_cinrad_raw_ppi(char *sitename,char *sitecode,char *nameformat,date_time scantime,char *timeformat){
  this->scan_time = scantime;

  if(!cinrad_radar_site_list::is_initialized()){
    cinrad_radar_site_list stnlist;
  }

  tags tagsscantime("scan time");
  tags tagssitecode("site code");

  cinrad_radar_site* stn = NULL;
  if(sitename != NULL){
    stn = cinrad_radar_site_list::get_site_by_name(sitename);
  }
  else if(sitecode != NULL){
    stn = cinrad_radar_site_list::get_site_by_code(sitecode);
  }
  else{
    return _ERRORCODE_INPUTERROR;
  }

  if(stn!=NULL){
    char *ctemp = new char [BUFFSIZE];
    char *filename = new char [BUFFSIZE];
    
    strcpy(filename,nameformat);
    tagssitecode.replace(filename,stn->sitecode);
    tagsscantime.replace(filename,scantime.get_time(timeformat,ctemp));

    this->read_cinrad_raw_ppi(filename);
    this->site_lat = stn->lat;
    this->site_lon = stn->lon;
    this->site_height = stn->height;
    
    delete [] filename;
    delete [] ctemp;
  }
  else{
    return _ERRORCODE_INPUTERROR;
  }

  return _ERRORCODE_NOERROR;
}
###CPP### ###CUDA### ###HOST### int radar_data::read_cinrad_raw_ppi(char *filename){
  if(ndim > 1){
    delete [] data_grid;
  }
  else if(ndim == 1){
    delete data_grid;
  }

  this->coordSys = 2;

  ifstream fin;

  cinrad_read_header tempheader;
  cinrad_header fileheader;

libjeff::file_handler *file = new libjeff::pseudo_file;
  file->open(filename);
  int num_data = libjeff::file_check_size(filename)/sizeof(cinrad_read_header);
  if(libjeff::file_check_size(filename)%sizeof(cinrad_read_header) != 0){
    std::cout << "File size not a multiple of cinrad_read_header size." << std::endl;
    return _ERRORCODE_FILEREADERROR;
  }
  int i,j;
  char *ctemp = new char [4096];
//std::cout << "Num data = " << num_data << std::endl;
  int num_ref_beam = 0, num_vel_beam = 0;
  int max_ref_gate = 0, max_vel_gate = 0;
  int ref_gate, vel_gate;
  int ref_index = 0, vel_index = 0;
  this->dbz_index = 0;
  this->dv_index = 1;
  for(i=0;i<num_data;i++){
    file->read((char*) &tempheader,sizeof(cinrad_read_header));
    if(tempheader.RefGates > 0){
      if(num_ref_beam==0){
	ref_gate = tempheader.RefGateSize;
      }
      else if(ref_gate != tempheader.RefGateSize){
	std::cout << "Error! Change in gate size for reflectivity!" << std::endl;
	return _ERRORCODE_FILEREADERROR;
      }
      num_ref_beam++;
      if(tempheader.RefGates > max_ref_gate){
	max_ref_gate = tempheader.RefGates;
      }
    }
    if(tempheader.DopplerGates > 0){
      if(num_vel_beam==0){
	vel_gate = tempheader.DopplerGateSize;
      }
      else if(vel_gate != tempheader.DopplerGateSize){
	std::cout << "Error! Change in gate size for doppler velocity!" << std::endl;
	return _ERRORCODE_FILEREADERROR;
      }
      num_vel_beam++;
      if(tempheader.DopplerGates > max_vel_gate){
	max_vel_gate = tempheader.DopplerGates;
      }
    }
  }
  /*
  std::cout << "Number of Reflectivity beam: " << num_ref_beam << " max gate: " << max_ref_gate << std::endl;
  std::cout << "Number of Velocity beam: " << num_vel_beam << " max gate: " << max_vel_gate << std::endl;
  */
  
  file->seek(0);
  ndim = 2;
  data_grid = new mapTo2DGrid [ndim];
  data_grid[dbz_index].create(num_ref_beam,num_ref_beam,max_ref_gate,1);
  data_grid[dv_index].create(num_vel_beam,num_vel_beam,max_vel_gate,1);
  for(i=0;i<num_data;i++){
    file->read((char*) &tempheader,sizeof(cinrad_read_header));
  /*
  if(fileheaderblock.irisHeader.ProductConfigurationStructure.ProductTypeCode!=15){
    cout << "Error in reading file " << filename << endl << "It is not a raw product." << endl;
    return 1;
  }
  */
  //data_grid = new regular_grid;
    fileheader = cinrad_header_convert(tempheader);
    /*
    std::cout << fileheader.UnambiguousRange << " " << fileheader.AzimuthAngle  << " " << fileheader.ElevationAngle << std::endl;
    std::cout << fileheader.AzimuthNumber << " " << fileheader.ElevationNumber << std::endl;
    std::cout << fileheader.FirstGateRangeOfRef << " " << fileheader.FirstGateRangeOfDoppler << " " << fileheader.RefGateSize << " " << fileheader.RefGates << " " << fileheader.DopplerGateSize << " " << fileheader.DopplerGates << std::endl;
    std::cout << fileheader.RefPoint << " " << fileheader.RefPlaybackPoint << std::endl;
    std::cout << fileheader.VelPoint << " " << fileheader.VelPlaybackPoint << std::endl;
    */
    if(tempheader.RefGates > 0){
      if(ref_index==0){
	for(j=0;j<max_ref_gate;j++){
	  data_grid[dbz_index].set_z(ref_index,ref_index,j,fileheader.FirstGateRangeOfRef+j*fileheader.RefGateSize);
	}
      }
      data_grid[dbz_index].set_x(ref_index,ref_index,0,fileheader.ElevationAngle);
      data_grid[dbz_index].set_y(ref_index,ref_index,0,fileheader.AzimuthAngle);
      for(j=0;j<fileheader.RefGates;j++){
	if(data_grid[dbz_index].get_z(ref_index,ref_index,j)>=200. && data_grid[dbz_index].get_z(ref_index,ref_index,j)<=fileheader.UnambiguousRange){
	  *(data_grid[dbz_index].get_data(ref_index,ref_index,j)) = cinrad::byte2reflectivity(tempheader.RVSDen[j+fileheader.RefPoint-100],this->missing_value);
	}
	else{
	  *(data_grid[dbz_index].get_data(ref_index,ref_index,j)) = this->missing_value;
	}
      }

      for(j=fileheader.RefGates;j<max_ref_gate;j++){
	*(data_grid[dbz_index].get_data(ref_index,ref_index,j)) = this->missing_value;
      }
      
      ref_index++;
    }
    if(tempheader.DopplerGates > 0){
      if(vel_index==0){
	for(j=0;j<max_vel_gate;j++){
	  data_grid[dv_index].set_z(vel_index,vel_index,j,fileheader.FirstGateRangeOfDoppler+j*fileheader.DopplerGateSize);
	}
      }
      data_grid[dv_index].set_x(vel_index,vel_index,0,fileheader.ElevationAngle);
      data_grid[dv_index].set_y(vel_index,vel_index,0,fileheader.AzimuthAngle);
      for(j=0;j<fileheader.DopplerGates;j++){
	if(data_grid[dv_index].get_z(vel_index,vel_index,j)>=200. && data_grid[dv_index].get_z(vel_index,vel_index,j)<=fileheader.UnambiguousRange){
	  *(data_grid[dv_index].get_data(vel_index,vel_index,j)) = cinrad::byte2velocity(tempheader.RVSDen[j+fileheader.VelPoint-100],tempheader.VelResolution,this->missing_value);
	}
	else{
	  *(data_grid[dv_index].get_data(vel_index,vel_index,j)) = this->missing_value;
	}
      }

      for(j=fileheader.DopplerGates;j<max_vel_gate;j++){
	*(data_grid[dv_index].get_data(vel_index,vel_index,j)) = this->missing_value;
      }
      
      vel_index++;
    }

    //std::cout << drawline(ctemp) << std::endl;
  }

delete [] ctemp;

  return _ERRORCODE_NOERROR;
}

###CPP### ###CUDA### ###HOST### int radar_data::read_iris_cappi_product(char *filename){
  int error = _ERRORCODE_NOERROR;
  libjeff::file_handler* file = NULL;
  openfile(file,filename);

  switch(file->get_error()){
  case BZ_CONFIG_ERROR:
    cout << "Error! Library mis-compiled." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_PARAM_ERROR:
    cout << "Error! Parameter error." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_IO_ERROR:
    cout << "IO error." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_MEM_ERROR:
    cout << "Mem error." << endl;
    return _ERRORCODE_BZERROR;
  default:
    break;
  }
  coordSys = 1;
  if(data_grid != NULL){
    delete data_grid;
  }
  data_grid = new regular_grid;
  IRIS_Header *fileheader = new IRIS_Header;
  read_iris_product_header(file,fileheader);
  if(libjeff::debug_setting::get_debug_mode_debug_message()){
    std::cout << "Information from IRIS Header:" << std::endl;
    std::cout << "----- Structure Header ---------------------" << std::endl;
    std::cout << "Structure Identifier: " << fileheader->StructureHeader.StructureIdentifier << std::endl;
    std::cout << "Format version: " << fileheader->StructureHeader.FormatVersionNumber << std::endl;
    std::cout << "Size of the file: " << fileheader->StructureHeader.NumberOfBytesEntireStructure << std::endl;

    std::cout << "----- Configuration Header ---------------------" << std::endl;
    std::cout << "Size: " << fileheader->ProductConfigurationStructure.StructureHeader.NumberOfBytesEntireStructure << std::endl;
    std::cout << "Product Type Code: " << fileheader->ProductConfigurationStructure.ProductTypeCode << std::endl;
    std::cout << "Data Type Code: " << fileheader->ProductConfigurationStructure.DataTypeGenerated << std::endl;
    std::cout << "ZR Constants: " << fileheader->ProductConfigurationStructure.ZRRelationshipConstant << " " << fileheader->ProductConfigurationStructure.ZRRelationshipExponent << std::endl;

    std::cout << "----- Product End Header ---------------------" << std::endl;


    std::cout << "----------------------------------------------" << std::endl;
  }
  set_with_iris_product_header(fileheader,this->data_grid);

  int i,j,k;
  double *ref_data = new double [this->data_grid->get_ngrid()];
  int datatype = fileheader->ProductConfigurationStructure.DataTypeGenerated;
  if(datatype==2){
    uint8_t* temp_data = new uint8_t [this->data_grid->get_ngrid()];
    file->read((char *) temp_data,this->data_grid->get_ngrid());

    for(i=0;i<this->data_grid->get_nx();i++){
      for(j=0;j<this->data_grid->get_ny();j++){
	for(k=0;k<this->data_grid->get_nz();k++){
	  if(((int) temp_data[k*this->data_grid->get_nx()*this->data_grid->get_ny()+j*this->data_grid->get_nx()+i] == 255)){
	    ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] = this->missing_value;
	  }
	  else{
	    ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] = byte2reflectivity(temp_data[k*this->data_grid->get_nx()*this->data_grid->get_ny()+j*this->data_grid->get_nx()+i]);
	  }
	}
      }
    }

    delete [] temp_data;
  }    
  else if(datatype==13){
    uint16_t* temp_data = new uint16_t [this->data_grid->get_ngrid()];
    file->read((char *) temp_data,sizeof(uint16_t)*this->data_grid->get_ngrid());

    for(i=0;i<this->data_grid->get_nx();i++){
      for(j=0;j<this->data_grid->get_ny();j++){
        for(k=0;k<this->data_grid->get_nz();k++){
	  /*
          if(((int) temp_data[k*this->data_grid->get_nx()*this->data_grid->get_ny()+j*this->data_grid->get_nx()+i] == 65535)){
            ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] = this->missing_value;
          }
          else{
	  */
	  ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] = twobyte2rainfall(temp_data[k*this->data_grid->get_nx()*this->data_grid->get_ny()+j*this->data_grid->get_nx()+i],this->missing_value);
	  /*
	  if(ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] > 0){
	    ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k] = 10.*log10(fileheader->ProductConfigurationStructure.ZRRelationshipConstant * pow(ref_data[i*this->data_grid->get_ny()*this->data_grid->get_nz()+j*this->data_grid->get_nz()+k],fileheader->ProductConfigurationStructure.ZRRelationshipExponent/1000)/1000);
	  }
	  */
	    //}
        }
      }
    }

    delete [] temp_data;
  }
  else{
    error = _ERRORCODE_NOTIMPLEMENTED;
  }
  this->data_grid->set_data(ref_data);
  file->close();

  delete [] ref_data;

  delete fileheader;
  delete file;
  return error;
}

###CPP### ###CUDA### ###HOST### int radar_data::read_iris_ndop_product(char *filename){
  libjeff::file_handler* file = NULL;
  openfile(file,filename);

  switch(file->get_error()){
  case BZ_CONFIG_ERROR:
    cout << "Error! Library mis-compiled." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_PARAM_ERROR:
    cout << "Error! Parameter error." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_IO_ERROR:
    cout << "IO error." << endl;
    return _ERRORCODE_BZERROR;
  case BZ_MEM_ERROR:
    cout << "Mem error." << endl;
    return _ERRORCODE_BZERROR;
  default:
    break;
  }
  coordSys = 1;
  IRIS_Header *fileheader = new IRIS_Header;
  read_iris_product_header(file,fileheader);
  set_with_iris_product_header(fileheader,this->data_grid);

  delete fileheader;
  delete file;
  return _ERRORCODE_NOERROR;
}

###CPP### ###CUDA### ###HOST### libjeff::grid_data_field* radar_data::get_reflectivity(libjeff::grid_data_field* out) const{
  if(dbz_index>=0){
    if(out != NULL){
      out->set(data_grid,dbz_index);
    }
    return out;
  }
  else{
    return NULL;
  }
}
###CPP### ###CUDA### ###HOST### libjeff::grid_data_field* radar_data::get_doppler_velocity(libjeff::grid_data_field* out) const{
  if(dv_index>=0){
    if(out != NULL){
      out->set(data_grid,dv_index);
    }
    return out;
  }
  else{
    return NULL;
  }
}

int radar_data::append_sweep(const radar_data &in){
  if(this->data_grid->get_grid_code() != REGULAR_GRID_CODE || in.data_grid->get_grid_code() != REGULAR_GRID_CODE || this->get_coordSys() != 2 || in.get_coordSys() != 2){
    cout << "Error! The radar data is not in PPI format." << endl;
    return 1;
  }

  if(in.data_grid->get_ny() != this->data_grid->get_ny() || in.data_grid->get_ndim() != this->data_grid->get_ndim()){
    cout << "Cannot append due to difference in dimensions:" << endl;
    cout << "Dimensions of appending data: " << in.data_grid->get_nx() << " " << in.data_grid->get_ny() << " " << in.data_grid->get_nz() << " " << in.data_grid->get_ndim() << endl;
    cout << "Dimensions of current data: " << this->data_grid->get_nx() << " " << this->data_grid->get_ny() << " " << this->data_grid->get_nz() << " " << this->data_grid->get_ndim() << endl;
    return 1;
  }

  int max_nz = this->data_grid->get_nz();
  if(in.data_grid->get_nz() > max_nz){
    max_nz = in.data_grid->get_nz();
  }
  //cout << max_nz << endl;

  double *temp_grid = new double [(this->data_grid->get_nx() + in.data_grid->get_nx())*this->data_grid->get_ny()*max_nz*this->data_grid->get_ndim()];
  double *temp_x = new double [this->data_grid->get_nx() + in.data_grid->get_nx()];
  double *temp_y = new double [this->data_grid->get_ny()];
  double *temp_z = new double [max_nz];

  //cout << "Temporary allocation done." << endl;
  
  int i,j,k,m;
  for(i=0;i<(this->data_grid->get_nx() + in.data_grid->get_nx());i++){
    if(i<this->data_grid->get_nx()){
      temp_x[i] = (this->data_grid->get_x())[i];
    }
    else{
      temp_x[i] = (in.data_grid->get_x())[i-this->data_grid->get_nx()];
    }
  }
  for(i=0;i<this->data_grid->get_ny();i++){
    temp_y[i] = (this->data_grid->get_y())[i];
  }
  for(i=0;i<max_nz;i++){
      if(in.data_grid->get_nz() == max_nz){
	temp_z[i] = (in.data_grid->get_z())[i];
      }
      else{
	temp_z[i] = (this->data_grid->get_z())[i];
      }
  }
  
  for(i=0;i<(this->data_grid->get_nx() + in.data_grid->get_nx())*this->data_grid->get_ny()*max_nz*this->data_grid->get_ndim();i++){
    temp_grid[i] = this->missing_value;
  }

	//cout << "Done filling missing value." << endl;
  
  for(i=0;i<(this->data_grid->get_nx() + in.data_grid->get_nx());i++){
    if(i<this->data_grid->get_nx()){
      for(j=0;j<this->data_grid->get_ny();j++){
	for(k=0;k<this->data_grid->get_nz();k++){
	  for(m=0;m<this->data_grid->get_ndim();m++){
	    temp_grid[i*this->data_grid->get_ny()*max_nz*this->data_grid->get_ndim()+j*max_nz*this->data_grid->get_ndim()+k*this->data_grid->get_ndim()+m] = (this->data_grid->get_data())[i*this->data_grid->get_ny()*this->data_grid->get_nz()*this->data_grid->get_ndim()+j*this->data_grid->get_nz()*this->data_grid->get_ndim()+k*this->data_grid->get_ndim()+m];
	  }
	}
      }
    }
    else{
      for(j=0;j<in.data_grid->get_ny();j++){
	for(k=0;k<in.data_grid->get_nz();k++){
	  for(m=0;m<in.data_grid->get_ndim();m++){
	    temp_grid[i*this->data_grid->get_ny()*max_nz*this->data_grid->get_ndim()+j*max_nz*this->data_grid->get_ndim()+k*this->data_grid->get_ndim()+m] = (in.data_grid->get_data())[ (i - this->data_grid->get_nx()) * in.data_grid->get_ny() * in.data_grid->get_nz() * in.data_grid->get_ndim() + j* in.data_grid->get_nz() * in.data_grid->get_ndim() + k * in.data_grid->get_ndim() + m];
	  }
	}
      }
    }
  }
	//cout << "Going to allocate final data structure." << endl;
      //cout << "Dimensions: " << (this->data_grid->get_nx() + in.data_grid->get_nx()) << " " << this->data_grid->get_ny() << " " << max_nz << " " << this->data_grid->get_ndim() << endl;
  this->data_grid->create((this->data_grid->get_nx() + in.data_grid->get_nx()),this->data_grid->get_ny(),max_nz,this->data_grid->get_ndim());
      //cout << "Done allocating the final data structure. " << endl;
  this->data_grid->set_x(temp_x);
  this->data_grid->set_y(temp_y);
  this->data_grid->set_z(temp_z);
  this->data_grid->set_data(temp_grid);
  
  delete [] temp_x;
  delete [] temp_y;
  delete [] temp_z;
  delete [] temp_grid;

  return 0;
}

###CPP### ###CUDA### ###HOST### void radar_data::set_coordSys(int in){
  if(in <= 0 || in > 2){
    this->coordSys = 0;
  }
  else{
    this->coordSys = in;
  }
}
###CPP### ###CUDA### ###HOST### void radar_data::allocate_data_grid(void (*allocation)(grid_data* &in)){
  (*allocation)(this->data_grid);
}
###CPP### ###CUDA### ###HOST### int radar_data::write_to_little_R(ofstream& fout,double horizontal_thin,double vertical_thin,const libjeff::vertical_profile* profile,bool (*filter)(double in)) const{
  int i,j,k,m;
  int error;
  
  if(coordSys==1){
    return _ERRORCODE_NOTIMPLEMENTED;
  }
  else if(coordSys==2){
    double *sitelatlon = new double [2];
    sitelatlon[0] = this->get_site_lat();
    sitelatlon[1] = this->get_site_lon();
    radar_data* temp_data = new radar_data;
    
    error = this->thinning(horizontal_thin,vertical_thin,profile,filter,temp_data);

    if(error == _ERRORCODE_NOERROR){
      char *temp = new char [FILENAMEBUFFSIZE];
      
      libjeff::grid_data_field* ref_field = new libjeff::grid_data_field;
      libjeff::grid_data_field* dv_field = new libjeff::grid_data_field;

      ref_field = temp_data->get_reflectivity(ref_field);
      dv_field = temp_data->get_doppler_velocity(dv_field);

      fout << drawline(temp) << endl << endl;
      switch(this->get_ndim()){
      case 1:
	fout << radarinfoline(temp,"RADAR",sitelatlon[0],sitelatlon[1],temp_data->get_site_height(),temp_data->get_scan_time(),ref_field->get_grid_data()->get_nx()+dv_field->get_grid_data()->get_nx(),1) << endl;
	break;
      case 2:
	fout << radarinfoline(temp,"RADAR",sitelatlon[0],sitelatlon[1],temp_data->get_site_height(),temp_data->get_scan_time(),temp_data->data_grid->get_nx(),1) << endl;
	break;
      }
      fout << drawline(temp) << endl << endl;
      switch(this->get_ndim()){
      case 1:
	for(i=0;i<ref_field->get_grid_data()->get_ngrid();i++){ 
	  fout << radardataheaderline(temp,temp_data->get_scan_time(),ref_field->get_grid_data()->get_y(i,0,0),ref_field->get_grid_data()->get_x(i,0,0),temp_data->get_site_height(),1) << endl;
	fout << radardataline(temp,temp_data->get_data_grid()->get_z(i,0,0),
			      (*(dv_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?*(dv_field->get_data(i,0,0)):-888888.000000),
			      (*(dv_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?1:-88),
			      (*(dv_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?0.5:-888888.000000),
			      (*(ref_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?*(ref_field->get_data(i,0,0)):-888888.000000),
			      (*(ref_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?1:-88),
			      (*(ref_field->get_data(i,0,0)) > temp_data->get_missing_value()+0.1?0.5:-888888.000000)) << endl;
	}
	break;
      case 2:
	for(i=0;i<ref_field->get_grid_data()->get_ngrid();i++){ 
	  fout << radardataheaderline(temp,temp_data->get_scan_time(),ref_field->get_grid_data()->get_y(i,0,0),ref_field->get_grid_data()->get_x(i,0,0),temp_data->get_site_height(),1) << endl;
	  fout << radardataline(temp,temp_data->get_data_grid()->get_z(i,0,0),-888888.000000,-88,-888888.000000,*(ref_field->get_data(i,0,0)),1,0.5) << endl;
	}
	for(i=0;i<dv_field->get_grid_data()->get_ngrid();i++){ 
	  fout << radardataheaderline(temp,temp_data->get_scan_time(),dv_field->get_grid_data()->get_y(i,0,0),dv_field->get_grid_data()->get_x(i,0,0),temp_data->get_site_height(),1) << endl;
	  fout << radardataline(temp,temp_data->get_data_grid()->get_z(i,0,0),*(dv_field->get_data(i,0,0)),1,0.5,-888888.000000,-88,-888888.000000) << endl;
	}
	break;
      }

      delete ref_field;
      delete dv_field;
      
      delete [] temp;
    }
    delete temp_data;
    delete [] sitelatlon;
  }
  else{
    return _ERRORCODE_DATAERROR_UNKNOWN;
  }
  return error;
}
###CPP### ###CUDA### ###HOST### int radar_data::thinning(double horizontal_thin,double vertical_thin,const libjeff::vertical_profile* profile,bool (*filter)(double in),radar_data *out)  const{
  out->destroy();

  if(coordSys==1){
    return _ERRORCODE_NOTIMPLEMENTED;
  }
  else if(coordSys==2){
    int i,j,k,m;

    double stepsize = 1000.;
    int nstep = 301;

    double **beam = new double* [nstep];
    for(i=0;i<nstep;i++){
      beam[i] = new double [3];
    }

    libjeff::vertical_profile *work_profile = new libjeff::vertical_profile;
    grid_data* temp_grid = NULL;
    if(profile==NULL){
      temp_grid = new regular_grid;
      work_profile->set_data(temp_grid);
      
      work_profile->set_p_index(0);
      work_profile->set_t_index(1);
      work_profile->set_q_index(2);

      work_profile->gen_ISA(20001,80.);
    }
    else{
      *work_profile = *profile;
    }

    out->ndim = this->get_ndim();
    out->coordSys = 1;
    out->missing_value = this->missing_value;
    out->scan_time = this->scan_time;
    out->site_lat = this->site_lat;
    out->site_lon = this->site_lon;
    out->site_height = this->site_height;

    out->dbz_index = 0;
    out->dv_index = 1;

    out->data_grid = new unstructured_grid [this->get_ndim()];

    int *ngrid = new int [this->get_ndim()];
    for(i=0;i<this->get_ndim();i++){
      ngrid[i] = (this->data_grid)[i].get_ngrid();
    }
    double ***output_data = new double** [this->get_ndim()];
    for(m=0;m<this->get_ndim();m++){
      output_data[m] = new double* [ngrid[m]];
      for(i=0;i<ngrid[m];i++){
	output_data[m][i] = new double [5];
      }
    }

    double *sitelatlon = new double [2];
    sitelatlon[0] = this->get_site_lat();
    sitelatlon[1] = this->get_site_lon();
    double *templatlon = new double [2];

    double ref, dv;
    int* ndata = new int [this->get_ndim()];
    for(m=0;m<this->get_ndim();m++){
      ndata[m] = 0;
    }
    if(this->get_ndim()==1){ //HKO radar case
      for(i=0;i<this->data_grid->get_nx();i++){
	libjeff::meteorology_radarbeam_propagation_zrnic_rk4(work_profile,nstep,stepsize,this->get_site_height(),this->data_grid->get_x(i,0,0),beam);

	for(j=0;j<this->data_grid->get_ny();j++){
	  //cout << "Processing: Sweep: " << i << " Ray: " << j << " Valid data found so far: " << ndata << endl;
	  for(k=0;k<this->data_grid->get_nz();k++){
	    if(dbz_index >= 0){
	      ref = this->data_grid->get_data(i,j,k)[dbz_index];
	    }
	    else{
	      ref = missing_value;
	    }
	    if(dv_index >= 0){
	      dv = this->data_grid->get_data(i,j,k)[dv_index];
	    }
	    else{
	      dv = missing_value;
	    }
	    
	    output_data[0][ndata[0]][3] = dv;
	    output_data[0][ndata[0]][4] = ref;
	    
	    if(filter==NULL || filter(ref) || filter(dv)){
	      bool lookupfound=0;
	      for(m=0;m<nstep;m++){
		if(beam[m][2] > this->data_grid->get_z(i,j,k)){
		  lookupfound = 1;
		  break;
		}
	      }
	      if(!lookupfound){
		break;
	      }
	      
	      double dist1 = beam[m-1][2], dist2 = beam[m][2];
	      double ptheight = beam[m-1][1] + (beam[m][1] - beam[m-1][1])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      double ptdist = beam[m-1][0] + (beam[m][0] - beam[m-1][0])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      libjeff::earth_cal_latlon_from_dist_bearing(sitelatlon,ptdist,this->data_grid->get_y(i,j,k),templatlon);
		    
	      output_data[0][ndata[0]][0] = templatlon[0];
	      output_data[0][ndata[0]][1] = templatlon[1];
	      output_data[0][ndata[0]][2] = ptheight;
	      
	      if(ndata[0] == 0 || !(horizontal_thin > 0 && vertical_thin > 0)){
		ndata[0]++;
	      }
	      else{
		bool too_close=0;
		for(m=ndata[0]-1;m>=0;m--){
		  if(libjeff::earth_latlon2dist(output_data[0][m],output_data[0][ndata[0]]) < horizontal_thin && fabs(output_data[0][m][2] - output_data[0][ndata[0]][2]) < vertical_thin){
		    too_close = 1;
		    break;
		  }
		}
		
		if(!too_close){
		  ndata[0]++;
		}
	      }
	    }
	  }
	}
      }

      out->get_data_grid()->create(ndata[0],1,1,2);
      for(i=0;i<ndata[0];i++){
	out->get_data_grid()->set_x(i,0,0,output_data[0][i][1]);
	out->get_data_grid()->set_y(i,0,0,output_data[0][i][0]);
	out->get_data_grid()->set_z(i,0,0,output_data[0][i][2]);
	out->get_data_grid()->get_data(i,0,0)[out->dbz_index] = output_data[0][i][3];
	out->get_data_grid()->get_data(i,0,0)[out->dv_index] = output_data[0][i][4];
      }
    }
    else{ //CINRAD case
      libjeff::grid_data_field* ref_field = new libjeff::grid_data_field;
      libjeff::grid_data_field* dv_field = new libjeff::grid_data_field;

      ref_field = this->get_reflectivity(ref_field);
      dv_field = this->get_doppler_velocity(dv_field);

      for(i=0;i<ref_field->get_nx();i++){
	libjeff::meteorology_radarbeam_propagation_zrnic_rk4(work_profile,nstep,stepsize,this->get_site_height(),ref_field->get_x(i,0,0),beam);

	for(j=0;j<ref_field->get_ny();j++){
	  //cout << "Processing: Sweep: " << i << " Ray: " << j << " Valid data found so far: " << ndata << endl;
	  for(k=0;k<ref_field->get_nz();k++){
	    ref = *(ref_field->get_data(i,j,k));
	    dv = missing_value;
	    
	    output_data[0][ndata[0]][3] = dv;
	    output_data[0][ndata[0]][4] = ref;
	    
	    if(filter==NULL || filter(ref)){
	      bool lookupfound=0;
	      for(m=0;m<nstep;m++){
		if(beam[m][2] > ref_field->get_z(i,j,k)){
		  lookupfound = 1;
		  break;
		}
	      }
	      if(!lookupfound){
		break;
	      }
	      
	      double dist1 = beam[m-1][2], dist2 = beam[m][2];
	      double ptheight = beam[m-1][1] + (beam[m][1] - beam[m-1][1])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      double ptdist = beam[m-1][0] + (beam[m][0] - beam[m-1][0])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      libjeff::earth_cal_latlon_from_dist_bearing(sitelatlon,ptdist,this->data_grid->get_y(i,j,k),templatlon);
		    
	      output_data[0][ndata[0]][0] = templatlon[0];
	      output_data[0][ndata[0]][1] = templatlon[1];
	      output_data[0][ndata[0]][2] = ptheight;
	      
	      if(ndata[0] == 0 || !(horizontal_thin > 0 && vertical_thin > 0)){
		ndata[0]++;
	      }
	      else{
		bool too_close=0;
		for(m=ndata[0]-1;m>=0;m--){
		  if(libjeff::earth_latlon2dist(output_data[0][m],output_data[0][ndata[0]]) < horizontal_thin && fabs(output_data[0][m][2] - output_data[0][ndata[0]][2]) < vertical_thin){
		    too_close = 1;
		    break;
		  }
		}
		
		if(!too_close){
		  ndata[0]++;
		}
	      }
	    }
	  }
	}
      }

      for(i=0;i<dv_field->get_nx();i++){
	libjeff::meteorology_radarbeam_propagation_zrnic_rk4(work_profile,nstep,stepsize,this->get_site_height(),dv_field->get_x(i,0,0),beam);

	for(j=0;j<dv_field->get_ny();j++){
	  //cout << "Processing: Sweep: " << i << " Ray: " << j << " Valid data found so far: " << ndata << endl;
	  for(k=0;k<dv_field->get_nz();k++){
	    dv = *(dv_field->get_data(i,j,k));
	    ref = missing_value;
	    
	    output_data[1][ndata[1]][3] = dv;
	    output_data[1][ndata[1]][4] = ref;
	    
	    if(filter==NULL || filter(dv)){
	      bool lookupfound=0;
	      for(m=0;m<nstep;m++){
		if(beam[m][2] > dv_field->get_z(i,j,k)){
		  lookupfound = 1;
		  break;
		}
	      }
	      if(!lookupfound){
		break;
	      }
	      
	      double dist1 = beam[m-1][2], dist2 = beam[m][2];
	      double ptheight = beam[m-1][1] + (beam[m][1] - beam[m-1][1])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      double ptdist = beam[m-1][0] + (beam[m][0] - beam[m-1][0])/(dist2 - dist1)*(this->data_grid->get_z(i,j,k) - dist1);
	      libjeff::earth_cal_latlon_from_dist_bearing(sitelatlon,ptdist,this->data_grid->get_y(i,j,k),templatlon);
		    
	      output_data[1][ndata[1]][0] = templatlon[0];
	      output_data[1][ndata[1]][1] = templatlon[1];
	      output_data[1][ndata[1]][2] = ptheight;
	      
	      if(ndata[1] == 0 || !(horizontal_thin > 0 && vertical_thin > 0)){
		ndata[1]++;
	      }
	      else{
		bool too_close=0;
		for(m=ndata[1]-1;m>=0;m--){
		  if(libjeff::earth_latlon2dist(output_data[1][m],output_data[1][ndata[1]]) < horizontal_thin && fabs(output_data[1][m][2] - output_data[1][ndata[1]][2]) < vertical_thin){
		    too_close = 1;
		    break;
		  }
		}
		
		if(!too_close){
		  ndata[1]++;
		}
	      }
	    }
	  }
	}
      }

      delete ref_field;
      delete dv_field;

      for(m=0;m<this->get_ndim();m++){
	(out->get_data_grid())[m].create(ndata[m],1,1,2);
	for(i=0;i<ndata[m];i++){
	  (out->get_data_grid())[m].set_x(i,0,0,output_data[m][i][1]);
	  (out->get_data_grid())[m].set_y(i,0,0,output_data[m][i][0]);
	  (out->get_data_grid())[m].set_z(i,0,0,output_data[m][i][2]);
	}
      }
      for(i=0;i<ndata[0];i++){
	*((out->get_data_grid())[out->dbz_index].get_data(i,0,0)) = output_data[0][i][3];
      }
      for(i=0;i<ndata[1];i++){
	*((out->get_data_grid())[out->dv_index].get_data(i,0,0)) = output_data[1][i][4];
      }
    }

    for(m=0;m<this->get_ndim();m++){
      for(i=0;i<ngrid[m];i++){
	delete [] output_data[m][i];
      }
      delete [] output_data[m];
    }
    delete [] output_data;
    delete [] ndata;
    
    if(profile==NULL){
      delete temp_grid;
    }
    delete work_profile;
    for(i=0;i<nstep;i++){
      delete [] beam[i];
    }
    delete [] beam;
    delete [] sitelatlon;
    delete [] templatlon;
  }

  return _ERRORCODE_NOERROR;
}
###CPP### ###CUDA### ###HOST### int radar_data::wavelet_filter3(const gsl_wavelet_type* wavelet,int member,int* thin_x, int* thin_z){
//int radar_data::wavelet_filter(gsl_wavelet_type wavelet,int member,int thin_x[], int thin_z[]){
//use maximum and minimum, do not change to qrain 
  if(this->get_ndim()!=2){
    cout<<"ndim != 2 is not implemented !"<<endl;
    return _ERRORCODE_NOTIMPLEMENTED;
  }
  int i,j,x;
  int nx,nz,d;
  int azi,first,nsize;
  double pheta,diff;
  bool complete_one_cycle = false;
  double threshold[2]={-30.0,-50.0};//first is vel, second is dbz
  double minimum, maximum;
  libjeff::grid_data_field* veldbz = new libjeff::grid_data_field [2];
  this->get_doppler_velocity(veldbz+0);
  this->get_reflectivity(veldbz+1);
  for(d=0;d<2;d++){
    azi = 1;//count how many x passed until complete 1 cycle
    pheta=0; // accumulate angle 
    first=0; //store the first x for current cycle
    nx=veldbz[d].get_nx();
    for(x=1;x<nx;x++){
      //cout<<"at beam "<<x<<endl;
      diff=this->data_grid->get_y(x,0,0)-this->data_grid->get_y(x-1,0,0);
      //cout<<diff<<endl;
      if( diff <= 0 ) diff += 360;
      pheta+=diff;
      azi++;
      if( pheta >= 360 || x==(nx-1) ){
	if(x==(nx-1))azi++;
	nz=veldbz[d].get_nz();
	i=1;
	while(i<azi)i=i*2;
	nsize=i;// this is the domain size
	while(nsize<nz)nsize=nsize*2;
	//cout<<"searched array length "<<nsize<<" d= "<<d<<endl;
	gsl_wavelet *w;
	gsl_wavelet_workspace *work;
	double *data;
	w = gsl_wavelet_alloc (wavelet, member);
	work = gsl_wavelet_workspace_alloc (nsize);
	data= new double [nsize*nsize];
	//take in vel or dbz data to the array for filtering
	minimum=0;
	maximum=0;
	for(i=0;i<azi;i++){
	  for(j=0;j<nz;j++){
	    data[i*nsize+j]=*(veldbz[d].get_data(i+first,0,j));
	    if( data[i*nsize+j] != this->get_missing_value()){
	      minimum = min(minimum,data[i*nsize+j]);
	      maximum = max(maximum,data[i*nsize+j]);
	    }
	  }
	  for(j=nz;j<nsize;j++){
	    data[i*nsize+j]=this->get_missing_value();
	  }
	}
	for(i=azi;i<nsize;i++){
	  for(j=0;j<nsize;j++){
	    data[i*nsize+j]=this->get_missing_value();
	  }
	}
	gsl_wavelet2d_transform_forward(w,  data,	nsize,  nsize,	nsize,  work);
	for(i=0;i<nsize;i++){
	  for(j=thin_z[d];j<nsize;j++){
	    data[i*nsize+j]=0;
	  }
	}
	for(i=thin_x[d];i<nsize;i++){
	  for(j=0;j<nsize;j++){
	    data[i*nsize+j]=0;
	  }
	}
	gsl_wavelet2d_transform_inverse(w,  data,	nsize,  nsize,	nsize,  work);
	for(i=0;i<azi;i++){
	  for(j=0;j<nz;j++){
	    *(veldbz[d].get_data(i+first,0,j))=data[i*nsize+j];
	    if(data[i*nsize+j]>=maximum || data[i*nsize+j]<=minimum)*(veldbz[d].get_data(i+first,0,j))=this->get_missing_value();
	    //cout<<i+first<<" "<<j<<" "<<*(veldbz[d].get_data(i+first,0,j))<<endl;
	  }
	}
	gsl_wavelet_free (w);
	gsl_wavelet_workspace_free (work);
	delete[] data;
	pheta=0;
	azi=0;
	first=x;
      }
    }
  }
  return _ERRORCODE_NOERROR;
}

###CPP### ###CUDA### ###HOST### double* radar_data::multiple_linear_interpolate(char *inputCoordinates,double ptx, double pty, double ptz, const libjeff::vertical_profile* profile, double *fg, double *temp) const{
  if(this->ndim == 1){
    if(strcmp(inputCoordinates,"Lat-Long-Height")==0){
      switch(coordSys){ //Lat-Lon-Height to Lat-Lon-Height
      case 1:
	this->get_data_grid()->multiple_linear_interpolate(ptx,pty,ptz,temp);
	return temp;
	break;
      case 2: { //Theta-Phi-R to Lat-Lon-Height
	libjeff::vertical_profile *work_profile = new libjeff::vertical_profile;
	grid_data* temp_grid = NULL;
	if(profile==NULL){
	  temp_grid = new regular_grid;
	  work_profile->set_data(temp_grid);
	  
	  work_profile->set_p_index(0);
	  work_profile->set_t_index(1);
	  work_profile->set_q_index(2);
	  
	  work_profile->gen_ISA(20001,80.);
	}
	else{
	  *work_profile = *profile;
	}
	
	double gcdist = libjeff::earth_latlon2dist(ptx,pty,this->get_site_lat(),this->get_site_lon());
	
	double *result = new double [2];
	result[0] = 0.;
	if(fg!=NULL){
	  result[0] = *fg;
	}
	
	libjeff::meteorology_radarbeam_find_elevation_zrnic_rk4(work_profile,1000,this->get_site_height(),gcdist,ptz,0.5,result);

	if(fg!=NULL){
	  *fg = result[0];
	}
	
	double direction = libjeff::earth_latlon_cal_bearing(this->get_site_lat(),this->get_site_lon(),ptx,pty);
	//std::cout << "Angle calculation done: " << result[0] << " " << direction << " " << result[1] << endl;
	
	int i;
	double missingvalue = this->missing_value;
	if((result[0]<this->data_grid->get_x(0,0,0) && result[0]<this->data_grid->get_x(this->data_grid->get_nx()-1,0,0)) || (result[0]>this->data_grid->get_x(0,0,0) && result[0]>this->data_grid->get_x(this->data_grid->get_nx()-1,0,0))){ //beam too low or beam too high
	  /*
	  std::cout << "Beam too low or too high. Elevation angles: ";
	  for(i=0;i<this->data_grid->get_nx();i++){
	      std::cout << (i==0?"":" ") << this->data_grid->get_x(i,0,0);
	    }
		std::cout << endl;
	  */
	  for(i=0;i<this->data_grid->get_ndim();i++){
	    temp[i] = this->missing_value;
	  }
	}
	else if((result[1]<this->data_grid->get_z(0,0,0) && result[1]<this->data_grid->get_z(0,0,this->data_grid->get_nz()-1)) || (result[1]>this->data_grid->get_z(0,0,0) && result[1]>this->data_grid->get_z(0,0,this->data_grid->get_nz()-1))){ //beam too short or beam too long
	  //std::cout << "Beam too short or too long. Range: " << this->data_grid->get_z(0,0,0) << " - " << this->data_grid->get_z(0,0,this->data_grid->get_nz()) << endl;
	  for(i=0;i<this->data_grid->get_ndim();i++){
	    temp[i] = this->missing_value;
	  }
	}
	else{
	  //std::cout << "Interpolation to: " << result[0] << " " << direction << " " << result[1] << endl;
	  this->data_grid->multiple_linear_interpolate(result[0],direction,result[1],&missingvalue,temp);
	}
	   
	delete [] result;
	
	if(profile==NULL){
	  delete temp_grid;
	}
	delete work_profile;
	
	return temp;
	break;
      }
      default:
	//coordinate system undefined
	return NULL;
	break;
      }
    }
    else if(strcmp(inputCoordinates,"Theta-Phi-Range")==0){
      switch(coordSys){
      case 1:
	//does not work because the origin of the Theta-Phi-Range coordinate not specified.
	return NULL;
	break;
      case 2: //Theta-Phi-R to Theta-Phi-R
	this->get_data_grid()->multiple_linear_interpolate(ptx,pty,ptz,temp);
	return temp;
	break;
      default:
	//coordinate system undefined
	return NULL;
	break;
      }
    }
    else{
      return NULL;
    }
  }
  else{
    //TO BE IMPLEMENTED
    return NULL;
  }
}

###CPP### ###CUDA### ###HOST### int radar_data::multiple_linear_interpolate_from(const radar_data& in, const libjeff::vertical_profile* profile, grid_data* fg){
  //first
  this->scan_time = in.scan_time;
  this->site_lat = in.site_lat;
  this->site_lon = in.site_lon;
  this->site_height = in.site_height;
  this->missing_value = in.missing_value;
  this->dbz_index = in.dbz_index;
  this->dv_index = in.dv_index;
  this->zdr_index = in.zdr_index;
  this->kdp_index = in.kdp_index;
  this->phidp_index = in.phidp_index;
  this->rhoHV_index = in.rhoHV_index;

  if(this->coordSys == in.coordSys){  //simple interpolation will work
    switch(this->coordSys){
    case 1:
    case 2:
      this->get_data_grid()->multiple_linear_interpolate_from(in.get_data_grid());
      break;
    case 0:
    default:
      return _ERRORCODE_INPUTERROR;
      break;
    }
  }
  else if(this->coordSys == 1 && in.coordSys == 2){ //PPI to vol-CAPPI
    bool have_fg = false;
    grid_data* work_fg;
    int error;
    if(fg!=NULL){
      //check if the dimension of the fg is correct
      if(this->get_data_grid()->get_nx() == fg->get_nx() && this->get_data_grid()->get_ny() == fg->get_ny() && this->get_data_grid()->get_nz() == fg->get_nz() && this->get_data_grid()->get_grid_code() == fg->get_grid_code()){
	//use first guess
	work_fg = fg;
	have_fg = true;
      }
    }

    int i,j,k,m;
    if(!have_fg){
      //no first guess found. See if there is previous learnt fg
      if(libjeff::file_check_exist("./ppi2cappi.fg")){
	int *fg_file_record = new int [4];
	ifstream fin;
	fin.open(RADARPPI2CAPPIFGFILE);
	read_fortran_binary_line(fin,4,fg_file_record,"little");
	if(this->get_data_grid()->get_nx() == fg_file_record[1] && this->get_data_grid()->get_ny() == fg_file_record[2] && this->get_data_grid()->get_nz() == fg_file_record[3] && this->get_data_grid()->get_grid_code() == fg_file_record[0]){
	//use previous learnt fg
	  error = grid_data_allocation(this->get_data_grid()->get_grid_code(),work_fg);
	  if(error != _ERRORCODE_NOERROR){
	    delete [] fg_file_record;
	    return error;
	  }

	  work_fg->create(fg_file_record[1],fg_file_record[2],fg_file_record[3],1);
	  read_fortran_binary_line(fin,work_fg->get_ngrid(),work_fg->get_data(),"little");
	}

	fin.close();

	delete [] fg_file_record;
      }
    }

    if(!have_fg){
      //no previous learnt data. Use first guess based on simple geometry
      error = grid_data_allocation(this->get_data_grid()->get_grid_code(),work_fg);
      if(error != _ERRORCODE_NOERROR){
	return error;
      }
      
      work_fg->create(this->get_data_grid()->get_nx(),this->get_data_grid()->get_ny(),this->get_data_grid()->get_nz(),1);
      

      double distance, height_diff;
      for(i=0;i<this->get_data_grid()->get_nx();i++){
	for(j=0;j<this->get_data_grid()->get_ny();j++){
	  for(k=0;k<this->get_data_grid()->get_nz();k++){
	    distance = libjeff::earth_latlon2dist(in.site_lat,in.site_lon,this->get_data_grid()->get_y(i,j,k),this->get_data_grid()->get_x(i,j,k));
	    height_diff = this->get_data_grid()->get_z(i,j,k) - in.site_height;
	    *(work_fg->get_data(i,j,k)) = atan2(height_diff,distance);
	  }
	}
      }
    }

    libjeff::vertical_profile *work_profile = new libjeff::vertical_profile;
    grid_data* temp_grid = NULL;
    if(profile==NULL){
      temp_grid = new regular_grid;
      work_profile->set_data(temp_grid);
      
      work_profile->set_p_index(0);
      work_profile->set_t_index(1);
      work_profile->set_q_index(2);
      
      work_profile->gen_ISA(20001,80.);
    }
    else{
      *work_profile = *profile;
    }

    //conversion from long-lat-height to elevation-azimuthal-range for interpolation.
    double *result = new double [2];
    double *temp_data = new double [in.get_data_grid()->get_ndim()];
    double elevation, azimuth, range, distance;
    for(i=0;i<this->get_data_grid()->get_nx();i++){
      for(j=0;j<this->get_data_grid()->get_ny();j++){
	for(k=0;k<this->get_data_grid()->get_nz();k++){
	  distance = libjeff::earth_latlon2dist(in.site_lat,in.site_lon,this->get_data_grid()->get_y(i,j,k),this->get_data_grid()->get_x(i,j,k));

	  result[0] = *(work_fg->get_data(i,j,k));
	  meteorology_radarbeam_find_elevation_zrnic_rk4(work_profile,1000.,in.site_height,distance,this->get_data_grid()->get_z(i,j,k),0.1,result);

	  elevation = result[0];
	  range = result[1];
	  azimuth = libjeff::earth_latlon_cal_bearing(in.site_lat,in.site_lon,this->get_data_grid()->get_y(i,j,k),this->get_data_grid()->get_x(i,j,k));

	  in.get_data_grid()->multiple_linear_interpolate(elevation,azimuth,range,temp_data);

	  for(m=0;m<this->get_data_grid()->get_ndim();m++){
	    (this->get_data_grid()->get_data(i,j,k))[m] = temp_data[m];
	  }
	}
      }
    }
    delete [] result;
    delete [] temp_data;

    //write to fg file for future use
    ofstream fout;
    fout.open(RADARPPI2CAPPIFGFILE);
    int *fg_file_record = new int [4];
    fg_file_record[0] = this->get_data_grid()->get_grid_code();
    fg_file_record[1] = this->get_data_grid()->get_nx();
    fg_file_record[2] = this->get_data_grid()->get_ny();
    fg_file_record[3] = this->get_data_grid()->get_nz();

    write_fortran_binary(fout,4,fg_file_record,"little");
    write_fortran_binary(fout,work_fg->get_ngrid(),work_fg->get_data(),"little");

    fout.close();

    delete [] fg_file_record;

    if(profile==NULL){
      delete temp_grid;
    }
    delete work_profile;
    if(fg!=NULL){
      delete work_fg;
    }

  }
  else{
    return _ERRORCODE_NOTIMPLEMENTED;
  }

  return _ERRORCODE_NOERROR;
}

###CPP### ###CUDA### ###HOST### int radar_data::nearest_to(char *inputCoordinates,double ptx, double pty, double ptz, int max_neighbour,const libjeff::vertical_profile* profile, double *fg,double *temp) const{
  if(max_neighbour <= 0){
    return _ERRORCODE_INPUTOUTOFRANGE;
  }

  if(this->ndim == 1){
    if(strcmp(inputCoordinates,"Lat-Long-Height")==0){
      switch(coordSys){ //Lat-Lon-Height to Lat-Lon-Height
      case 1:
	return _ERRORCODE_NOTIMPLEMENTED;
	break;
      case 2: { //Theta-Phi-R to Lat-Lon-Height
	libjeff::vertical_profile *work_profile = new libjeff::vertical_profile;
	grid_data* temp_grid = NULL;
	if(profile==NULL){
	  temp_grid = new regular_grid;
	  work_profile->set_data(temp_grid);
	  
	  work_profile->set_p_index(0);
	  work_profile->set_t_index(1);
	  work_profile->set_q_index(2);
	  
	  work_profile->gen_ISA(20001,80.);
	}
	else{
	  *work_profile = *profile;
	}
	
	double gcdist = libjeff::earth_latlon2dist(ptx,pty,this->get_site_lat(),this->get_site_lon());
	
	double *result = new double [2];
	result[0] = 0.;
	if(fg!=NULL){
	  result[0] = *fg;
	}
	
	libjeff::meteorology_radarbeam_find_elevation_zrnic_rk4(work_profile,1000,this->get_site_height(),gcdist,ptz,0.5,result);
	
	if(fg!=NULL){
	  *fg = result[0];
	}
	
	double direction = libjeff::earth_latlon_cal_bearing(this->get_site_lat(),this->get_site_lon(),ptx,pty);
	//std::cout << "Angle calculation done: " << result[0] << " " << direction << " " << result[1] << endl;

	int i,j,k,m,n,p;
	if((result[0]<this->data_grid->get_x(0,0,0) && result[0]<this->data_grid->get_x(this->data_grid->get_nx()-1,0,0)) || (result[0]>this->data_grid->get_x(0,0,0) && result[0]>this->data_grid->get_x(this->data_grid->get_nx()-1,0,0))){ //beam too low or beam too high
	  /*
	  std::cout << "Beam too low or too high. Elevation angles: ";
	  for(i=0;i<this->data_grid->get_nx();i++){
	      std::cout << (i==0?"":" ") << this->data_grid->get_x(i,0,0);
	    }
		std::cout << endl;
	  */
	  for(i=0;i<this->data_grid->get_ndim();i++){
	    temp[i] = this->missing_value;
	  }
	}
	else if((result[1]<this->data_grid->get_z(0,0,0) && result[1]<this->data_grid->get_z(0,0,this->data_grid->get_nz()-1)) || (result[1]>this->data_grid->get_z(0,0,0) && result[1]>this->data_grid->get_z(0,0,this->data_grid->get_nz()-1))){ //beam too short or beam too long
	  //std::cout << "Beam too short or too long. Range: " << this->data_grid->get_z(0,0,0) << " - " << this->data_grid->get_z(0,0,this->data_grid->get_nz()) << endl;
	  for(i=0;i<this->data_grid->get_ndim();i++){
	    temp[i] = this->missing_value;
	  }
	}
	else{
	  int *pts = new int [3];
	  this->data_grid->find_enclose(result[0],direction,result[1],pts);

	  int **candidates = new int* [max_neighbour];
	  double *metric = new double [max_neighbour];
	  for(i=0;i<max_neighbour;i++){
	    candidates[i] = new int [3];
	    metric[i] = -9999.;
	  }
	  
	  double length;
	  double *vec1 = new double [3];
	  double *vec2 = new double [3];
	  vec1[0] = result[1];
	  vec1[1] = result[0]*ang_to_rad;
	  vec1[2] = direction*ang_to_rad;
	  int *test_pts = new int [3];
	  for(k=-max_neighbour;k<=max_neighbour;k++){
	    test_pts[2] = k+pts[2];
	    if(this->data_grid->is_z_periodic() && (test_pts[2] < 0 || test_pts[2] >= this->data_grid->get_nz())){
	      while(test_pts[2] < 0){
		test_pts[2] += this->data_grid->get_nz();
	      }
	      test_pts[2] = test_pts[2]%(this->data_grid->get_nz());
	    }

	    if(test_pts[2] >= 0 && test_pts[2]< this->data_grid->get_nz()){
	      for(j=-max_neighbour;j<=max_neighbour;j++){
		test_pts[1] = j+pts[1];
		if(this->data_grid->is_y_periodic() && (test_pts[1] < 0 || test_pts[1] >= this->data_grid->get_ny())){
		  while(test_pts[1] < 0){
		    test_pts[1] += this->data_grid->get_ny();
		  }
		  test_pts[1] = test_pts[1]%(this->data_grid->get_ny());
		}

		if(test_pts[1] >= 0 && test_pts[1]< this->data_grid->get_ny()){
		  for(i=-max_neighbour;i<=max_neighbour;i++){
		    test_pts[0] = i+pts[0];
		    if(this->data_grid->is_x_periodic() && (test_pts[0] < 0 || test_pts[0] >= this->data_grid->get_nx())){
		      while(test_pts[0] < 0){
			test_pts[0] += this->data_grid->get_nx();
		      }
		      test_pts[0] = test_pts[0]%(this->data_grid->get_nx());
		    }

		    if(test_pts[0] >= 0 && test_pts[0]< this->data_grid->get_nx()){
		      vec2[0] = this->data_grid->get_z(test_pts[0],test_pts[1],test_pts[2]);
		      vec2[1] = this->data_grid->get_x(test_pts[0],test_pts[1],test_pts[2])*ang_to_rad;
		      vec2[2] = this->data_grid->get_y(test_pts[0],test_pts[1],test_pts[2])*ang_to_rad;
		      
		      length = libjeff::vector_spherical_coord_cal_norm(vec1,vec2);
		      for(m=0;m<max_neighbour;m++){
			if(length < metric[m] || metric[m] < 0){
			  for(n=max_neighbour-1;n>m;n--){
			    metric[n] = metric[n-1];
			    for(p=0;p<3;p++){
			      candidates[n][p] = candidates[n-1][p];
			    }
			  }
			  metric[m] = length;
			  candidates[m][0] = test_pts[0];
			  candidates[m][1] = test_pts[1];
			  candidates[m][2] = test_pts[2];
			  break;
			}
		      }
		    }
		  }
		}
	      }
	    }
	  }
	  
	  delete [] vec1;
	  delete [] vec2;
	  
	  for(j=0;j<this->data_grid->get_ndim();j++){
	    temp[j] = missing_value;
	    for(i=0;i<max_neighbour;i++){
	      if(metric[i] >= -1. && this->data_grid->get_data(candidates[i][0],candidates[i][1],candidates[i][2])[j] != missing_value){
		temp[j] = this->data_grid->get_data(candidates[i][0],candidates[i][1],candidates[i][2])[j];
		break;
	      }
	    }
	  }
	  
	  for(i=0;i<max_neighbour;i++){
	    delete [] candidates[i];
	  }
	  delete [] candidates;
	  delete [] metric;
	
	  delete [] pts;
	  delete [] test_pts;
	}
	
	delete [] result;
	
	if(profile==NULL){
	  delete temp_grid;
	}
	delete work_profile;
	
	return _ERRORCODE_NOERROR;
	break;
      }
      default:
	return _ERRORCODE_UNKNOWNERROR;
	break;
      }
    }
    else if(strcmp(inputCoordinates,"Theta-Phi-Range")==0){
      return _ERRORCODE_NOTIMPLEMENTED;
    }
  }
  else{
    return _ERRORCODE_NOTIMPLEMENTED;
  }
  
  return _ERRORCODE_NOERROR;
}
###CPP### ###CUDA### ###HOST### radar_data& radar_data::operator=(const radar_data &in){
  if(this == &in){
    return *this;
  }

  if(ndim > 1){
    delete [] data_grid;
  }
  else if(ndim == 1){
    delete data_grid;
  }
  ndim = 0;

  if(in.ndim > 0){
    if(in.ndim > 1){
      grid_data_allocation(in.data_grid[0].get_grid_code(),this->data_grid,in.ndim);
    }
    else{
      grid_data_allocation(in.data_grid[0].get_grid_code(),this->data_grid);
    }
    this->ndim = in.ndim;

    int i;
    for(i=0;i<ndim;i++){
      *(this->data_grid+i) = *(in.data_grid+i);
    }
    this->missing_value = in.missing_value;
    this->site_lat = in.site_lat;
    this->site_lon = in.site_lon;
    this->site_height = in.site_height;

    this->coordSys =  in.coordSys;
    this->dbz_index = in.dbz_index;
    this->dv_index = in.dv_index;
    this->zdr_index = in.zdr_index;
    this->kdp_index = in.kdp_index;
    this->phidp_index = in.phidp_index;
    this->rhoHV_index = in.rhoHV_index;
  }

  return *this;
}

###CPP### ###CUDA### ###HOST### void radar_data::fill_missing_value(){
  int i;
  for(i=0;i<this->data_grid->get_nx()*this->data_grid->get_ny()*this->data_grid->get_nz()*this->data_grid->get_ndim();i++){
    (this->data_grid->get_data())[i] = missing_value;
  }
}
###CPP### ###CUDA### ###HOST### void radar_data::set_x(int index,double value){
  (this->data_grid->get_x())[index] = value;
}
###CPP### ###CUDA### ###HOST### void radar_data::set_y(int index,double value){
  (this->data_grid->get_y())[index] = value;
}
###CPP### ###CUDA### ###HOST### void radar_data::set_z(int index,double value){
  (this->data_grid->get_z())[index] = value;
}
###CPP### ###CUDA### ###HOST### int radar_data::ppi_composite_by_priority(int nradar,radar_data* in,double horizontal_thin,double vertical_thin,double dv_error,double ref_error){
  if(nradar <= 0){
    return _ERRORCODE_INPUTOUTOFRANGE;
  }

  int max_ndim = 0;
  int i;

  return _ERRORCODE_NOERROR;
}
###CPP### ###CUDA### ###HOST### int radar_data::ppi_composite_weighting(int nradar,radar_data* in,double horizontal_thin,double vertical_thin,double dv_error,double ref_error){
  if(nradar <= 0){
    return _ERRORCODE_INPUTOUTOFRANGE;
  }

  return _ERRORCODE_NOERROR;
}
###CPP### ###CUDA### ###HOST### int radar_data::ppi_composite(int nradar,radar_data* in,double horizontal_thin,double vertical_thin,double dv_error,double ref_error,char* method){
  if(strcmp(method,"priority")==0){
    return this->ppi_composite_by_priority(nradar,in,horizontal_thin,vertical_thin,dv_error,ref_error);
  }
  else if(strcmp(method,"weighting")==0){
    return this->ppi_composite_weighting(nradar,in,horizontal_thin,vertical_thin,dv_error,ref_error);
  }
  else{
    return _ERRORCODE_NOTIMPLEMENTED;
  }
}

###CPP### ###CUDA### ###HOST### int radar_data_read_HKO_iris_raw_ppi(radar_data* to_read,char *dirnameformat,char *sitename,date_time scantime){
  const int num_file_per_vol_scan = 3;

  date_time local_time;
  date_time hkt2utc(0,0,0,8);
  date_time threeMinutes(0,0,0,0,3);
  local_time = scantime + hkt2utc;

  tags diryyyy("DIR YYYY"), diryyyymm("DIR YYYYMM"),diryyyymmdd("DIR YYYYMMDD"), tag_sitename("SITE NAME");
  
  
  char *ctemp = new char [FILENAMEBUFFSIZE];
  char *dirname = new char [FILENAMEBUFFSIZE];
  char *temp_filename = new char [FILENAMEBUFFSIZE];
  char **filelist;

  int error = _ERRORCODE_NOERROR;

  strcpy(dirname,dirnameformat);

  diryyyy.replace(dirname,scantime.get_time("yyyy",ctemp));
  diryyyymm.replace(dirname,scantime.get_time("yyyymm",ctemp));
  diryyyymmdd.replace(dirname,scantime.get_time("yyyymmdd",ctemp));
  tag_sitename.replace(dirname,sitename);
  int num_files;
  int i,j,k;
  date_time temp_time;

  char **filename = new char* [num_file_per_vol_scan];
  for(i=0;i<num_file_per_vol_scan;i++){
    filename[i] = new char [FILENAMEBUFFSIZE];
  }

  radar_data *data2process = new radar_data [num_file_per_vol_scan];

  libjeff::file_check_list_item(dirname,filelist,num_files);
  int file_count = 0;
  for(j=0;j<num_files;j++){
    //std::cout << filelist[j] << endl;
    if(strlen(filelist[j])<23){
      continue;
    }
    if(strstr(filelist[j],sitename)==NULL){
      continue;
    }
    
    strcpy(temp_filename,filelist[j]+3);

    char *test=strstr(temp_filename,".");
    if(test != NULL){
      *test='\0';
      temp_time.set_time_YYMMDDHHMMSS(temp_filename);
      
      //      if(temp_time.isSameMinute(local_time) || temp_time.isSameMinute(local_time+threeMinutes)){
      if(temp_time >= local_time && temp_time <= local_time + date_time(0,0,0,0,3,59)){
	//std::cout << filelist[j] << endl;
	strcpy(filename[file_count],filelist[j]);
	file_count++;
      }
    }
  }

  if(file_count == num_file_per_vol_scan){
    date_time *filetime = new date_time [num_file_per_vol_scan];
    
    for(j=0;j<num_file_per_vol_scan;j++){
      strcpy(temp_filename,filename[j]+3);
      char *test=strstr(temp_filename,".");
      *test='\0';
      filetime[j].set_time_YYMMDDHHMMSS(temp_filename);
    }
    
    for(k=0;k<num_file_per_vol_scan;k++){
      for(j=k+1;j<num_file_per_vol_scan;j++){
	if(filetime[k] > filetime[j]){
	  temp_time = filetime[k];
	  filetime[k] = filetime[j];
	  filetime[j] = temp_time;
	  
	  strcpy(temp_filename,filename[k]);
	  strcpy(filename[k],filename[j]);
	  strcpy(filename[j],temp_filename);
	}
      }
    }
    
    delete [] filetime;
    
    for(j=0;j<num_file_per_vol_scan;j++){
      strcpy(temp_filename,dirname);
      strcat(temp_filename,"/");
      strcat(temp_filename,filename[j]);
      
      error = data2process[j].read_iris_raw_ppi(temp_filename);
      if(error != _ERRORCODE_NOERROR){
	break;
      }
    }

    if(error == _ERRORCODE_NOERROR){
      for(j=1;j<num_file_per_vol_scan;j++){
	data2process[0].append_sweep(data2process[j]);
      }
      
      *to_read = data2process[0];
      
      to_read->set_scan_time(scantime);
    }
  }
  else{
    return _ERRORCODE_FILENOTFOUND;
  }

  delete [] data2process;
  for(j=0;j<num_files;j++){
    delete [] filelist[j];
  }
  delete [] filelist;

  delete [] ctemp;
  delete [] dirname;
  delete [] temp_filename;
  for(i=0;i<num_file_per_vol_scan;i++){
    delete [] filename[i];
  }
  delete [] filename;

  return error;
}
