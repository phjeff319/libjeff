#include<cmath>
###CUDA####include<cuda.h>
#include <ctime>
#include <fstream>
#include <iostream>

###CUDA####include "cuda_setting.h"
###CUDA####include "cuda_tools.h"
#include "debug_mode.h"
#include "earth.h"
#include "error_code.h"
#include "grid_data_field.h"
#include "math_special_function.h"
#include "meteorology.h"
#include "numerical_schemes.h"
#include "physics_constants.h"
#include "tools.h"
using namespace std;

const int MAX_ITERATION_FIND_ELEVATION = 100;
const int MAX_ITERATION_FIND_WETBULB = 10000;
const int MAX_ITERATION_FIND_DEWPOINT = 100;
const double DEFAULT_WETBULB_ACCURACY = 0.001;
const int MAX_ITERATION_SATURATION_ADJUSTMENT = 500;
const double DEFAULT_SATURATION_ADJUSTMENT_ACCURACY = 0.00001;
const int MAX_ITERATION_UPDRAFT_CONDENSATION = 500;
const double DEFAULT_UPDRAFT_CONDENSATION_ACCURACY = 0.00001;
const int MAX_ITERATION_GGP_CALCULATION  = 500;
const double DEFAULT_GGP_CALCULATION_ACCURACY = 0.00001;
const int MAX_ITERATION_FALLOUT_CALCULATION  = 500;
const double DEFAULT_FALLOUT_CALCULATION_ACCURACY = 0.00001;

const double tice = meteorology_tice;
const double t0 = 273.16;
const double tbf = 268.16;

const double u_asterisk_cube = 0.001;
const double kapper = 0.4;

const double default_Pr = 0.85;

namespace libjeff{
  ###CPP### ###CUDA### ###HOST### ###DEVICE### int meteorology_plv2fl(double plv,double slp,int rounding){
    double result;
    if(plv >= 226.32){
      result = -1454.42157*(pow(10.,log10(plv/slp)/5.2558797)-1);
    }
    else{
      result = (216.65*meteorology_R/meteorology_g0*log(226.32/plv) + 11000)*meter_to_ft*0.01;
    }
    int iresult = ((int) round(result/rounding))*rounding;
    return iresult;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_fl2plv(double fl,double slp){
    double result = -1.;
    if(fl < 1454.42157){
      result = pow(10.,5.2558797*log10(1.-fl/1454.42157))*slp;
    }
    else{
      result = -1;
    }
    return result;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_taylor_cal_es0swirls(double temperature){
    double temperature_C = temperature - meteorology_C_to_K;
  /*
    double rtemp=0.99999683 - 0.90826951e-2*temperature_C + 0.78736169e-4*pow(temperature_C,2.) - 0.61117958e-6*pow(temperature_C,3.) + 0.43884187e-8*pow(temperature_C,4.) - 0.29883885e-10*pow(temperature_C,5.) + 0.21874425e-12*pow(temperature_C,6.) - 0.17892321e-14*pow(temperature_C,7.) + 0.11112018e-16*pow(temperature_C,8.) - 0.30994571e-19*pow(temperature_C,9.);
    double es0 = 6.1078/(pow(rtemp,8.));
  */
  //this implementation is much faster
    double rtemp=0.99999683 + (-0.90826951e-2 + (0.78736169e-4 + (-0.61117958e-6 + (0.43884187e-8 + (-0.29883885e-10 + (0.21874425e-12 + (-0.17892321e-14 + (0.11112018e-16 - 0.30994571e-19*temperature_C)*temperature_C)*temperature_C)*temperature_C)*temperature_C)*temperature_C)*temperature_C)*temperature_C)*temperature_C;
    rtemp*=rtemp; //square
    rtemp*=rtemp;
    rtemp*=rtemp; //pow 8
    double es0 = 6.1078/rtemp;
    
    return es0;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_taylor_cal_es0(double temperature){
    double deltat = 23;
    if(temperature < 273.16 && temperature > 273.16 - deltat){ 
      double alpha = (temperature - 273.16 + 23)/23;
      alpha *= alpha;

      return alpha*meteorology_taylor_cal_es0liquid(temperature) + (1. - alpha)*meteorology_taylor_cal_es0ice(temperature);
    }
    else if(temperature >= 273.16){
      return meteorology_taylor_cal_es0liquid(temperature);
    }
    else{
      return meteorology_taylor_cal_es0ice(temperature);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_taylor_cal_es0liquid(double temperature){
    return meteorology_CC_es0*exp(17.502*(temperature - 273.16)/(temperature - 32.19));
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_taylor_cal_es0ice(double temperature){
    return meteorology_CC_es0*exp(22.587*(temperature - 273.16)/(temperature + 0.7));
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_mixing_ratio(int nstate,double *pressure,double *temperature,double *dew_point,double *mixing_ratio){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      mixing_ratio[i]=libjeff::meteorology_cal_mixing_ratio(pressure[i],temperature[i],dew_point[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_mixing_ratio(double pressure,double temperature,double dew_point){
    double temperature_C=temperature - meteorology_C_to_K;
    
    const double eps=0.62197;
    double rtemp;
    double wfw, fwesw;
    
    rtemp = 0.02e0*(temperature_C - 12.5e0 + 7500.e0/pressure);
    wfw = 1.e0 + 4.5e-6*pressure + 1.4e-3*rtemp*rtemp;
    fwesw = wfw*meteorology_taylor_cal_es0(dew_point);
    double mixing_ratio=eps*fwesw/(pressure-fwesw);
    
    return mixing_ratio;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_saturated_mixing_ratio(double pressure,double temperature){
    double es = meteorology_taylor_cal_es0(temperature);

    return meteorology_epsilon*(es/(pressure - es));
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_saturated_mixing_ratio_ice(double pressure,double temperature){
    double es = meteorology_taylor_cal_es0ice(temperature);

    return meteorology_epsilon*(es/(pressure - es));
  }

  ###CPP### ###CUDA### ###HOST### double meteorology_cal_dewpoint(double pressure,double temperature,double mixing_ratio){
    double temperature_C=temperature - meteorology_C_to_K;
    const double eps=0.62197;
    double rtemp;
    double wfw, fwesw;
    
    rtemp = 0.02e0*(temperature_C - 12.5e0 + 7500.e0/pressure);
    wfw = 1.e0 + 4.5e-6*pressure + 1.4e-3*rtemp*rtemp;
    fwesw =  mixing_ratio*pressure/(eps + mixing_ratio);
    
    return numerical_schemes_secant_method(100,temperature,temperature-1.,fwesw,0.01,meteorology_taylor_cal_es0);
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_dewpoint(int nstate,double *pressure,double *temperature,double *mixing_ratio,double *dew_point){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      double temperature_C=temperature[i] - meteorology_C_to_K;
      const double eps=0.62197;
      double rtemp;
      double wfw, fwesw;
      
      rtemp = 0.02e0*(temperature_C - 12.5e0 + 7500.e0/pressure[i]);
      wfw = 1.e0 + 4.5e-6*pressure[i] + 1.4e-3*rtemp*rtemp;
      fwesw =  mixing_ratio[i]*pressure[i]/(eps + mixing_ratio[i]);

      int j;
      double result;
      double x0, x1, y0;
      x0 = temperature[i];
      x1 = temperature[i]-1.;
      y0 = fwesw;
      for(j=0;j<MAX_ITERATION_FIND_DEWPOINT;j++){
	result = x1 - (meteorology_taylor_cal_es0(x1) - y0)*(x1 - x0)/(meteorology_taylor_cal_es0(x1) - meteorology_taylor_cal_es0(x0));
	x0 = x1;
	x1 = result;
      }

      dew_point[i] = result;
    }
  }
  
  ###CUDA### ###GLOBAL### void meteorology_cal_dry_density(int nstate,double *temperature,double *pressure,double *mixing_ratio,double *density){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      density[i]=libjeff::meteorology_cal_dry_density(temperature[i],pressure[i],mixing_ratio[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_dry_density(double temperature,double pressure,double mixing_ratio){
    double density = pressure*100.e0/(meteorology_Rv * temperature * (meteorology_epsilon + mixing_ratio));
    
    return density;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_dry_pressure(double dry_density,double temperature){
    return dry_density * meteorology_R * temperature * 0.01;
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_density(int nstate,double *temperature,double *pressure,double *mixing_ratio,double *density){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      density[i]=libjeff::meteorology_cal_density(temperature[i],pressure[i],mixing_ratio[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_density(double temperature,double pressure,double mixing_ratio){
    double density = pressure*100.e0/(meteorology_Rv * temperature * (meteorology_epsilon + mixing_ratio))*(1+mixing_ratio);
    
    return density;
  }
  
  ###CUDA### ###GLOBAL### void meteorology_cal_rh(int nstate,double *pressure,double *temperature,double *dew_point,double *rh){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      rh[i] = libjeff::meteorology_cal_rh(pressure[i],temperature[i],dew_point[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_rh(double pressure,double temperature,double dew_point){
    return 100.*meteorology_cal_mixing_ratio(pressure,temperature,dew_point)/meteorology_cal_mixing_ratio(pressure,temperature,temperature);
  }
  
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_theta(double pressure,double temperature){
    double theta = temperature*pow((1000./pressure),meteorology_R/meteorology_Cpd);
    //double theta = temperature*exp(meteorology_R/meteorology_Cpd*log(1000./pressure));
    return theta;
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_theta(int nstate,double *pressure,double *temperature,double* theta){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      theta[i] = libjeff::meteorology_cal_theta(pressure[i],temperature[i]);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_thetav(int nstate,double *theta,double *mixing_ratio,double *thetav){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      thetav[i] = theta[i]*(1.+0.61*mixing_ratio[i]);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_theta_e(int nstate,double *pressure,double *temperature,double *dew_point,double* theta_e){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      theta_e[i] = libjeff::meteorology_cal_theta_e(pressure[i],temperature[i],dew_point[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_theta_e(double pressure,double temperature,double dew_point){
    double mixing_ratio = meteorology_cal_mixing_ratio(pressure,temperature,dew_point);
    double theta = meteorology_cal_theta(pressure,temperature);
    double theta_e = theta*exp(meteorology_Lv0*mixing_ratio/(meteorology_Cpd*temperature));
    return theta_e;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_theta2temperature(double pressure,double theta){
    double temperature = theta/(pow((1000./pressure),meteorology_R/meteorology_Cpd));
    return temperature;
  }
  
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_slp(double pressure,double temperature,double dew_pt,double gournd_height){
    return pressure*exp(gournd_height*meteorology_g0/(meteorology_R*meteorology_cal_virtual_temperature(pressure,temperature,dew_pt)));
  }

  ###CUDA### ###GLOBAL### void  meteorology_cal_vapour_pressure(int nstate,double *pressure,double *temperature,double *rh,double *pressure_e){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      pressure_e[i] = libjeff::meteorology_cal_vapour_pressure(pressure[i],temperature[i],rh[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_vapour_pressure(double pressure,double temperature,double rh){
    double mixing_ratio = rh*0.01*meteorology_cal_mixing_ratio(pressure,temperature,temperature);
    double rho_v = mixing_ratio*meteorology_cal_dry_density(temperature,pressure,mixing_ratio);
    return rho_v * meteorology_Rv * temperature * 0.01;
  } 
  ###CUDA### ###GLOBAL### void  meteorology_cal_vapour_pressure(int nstate,double *temperature,double *qvapour,double *pressure_e){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      pressure_e[i] = libjeff::meteorology_cal_vapour_pressure(temperature[i],qvapour[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_vapour_pressure(double temperature,double qvapour){
    return qvapour * meteorology_Rv * temperature * 0.01;
  } 
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_wetbulb(double pressure,double temperature,double dew_point){
    return meteorology_cal_wetbulb(pressure,temperature,dew_point,MAX_ITERATION_FIND_WETBULB,DEFAULT_WETBULB_ACCURACY);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_wetbulb(double pressure,double temperature,double dew_point,int max_iteration,double accuracy){
    double wetbulb = temperature - (temperature - dew_point)/3.;

    double temp;
    double mixing_coeff = 0.5;
    int i;
    for(i=0;i<max_iteration;i++){
      temp = temperature - meteorology_Lv/meteorology_Cpd*(meteorology_cal_mixing_ratio(pressure,wetbulb,wetbulb) - meteorology_cal_mixing_ratio(pressure,temperature,dew_point));

      wetbulb = mixing_coeff*temp + (1. - mixing_coeff)*wetbulb;
      if(wetbulb > temperature || wetbulb < dew_point){ //restart
	wetbulb = temperature - (temperature - dew_point)/3.;
	mixing_coeff*=0.5;
	continue;
      }
      if(fabs(wetbulb - temp) < accuracy){ //check converegnce
	break;
      }
    }

    return wetbulb;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double *meteorology_cal_gph(int nlevel,double *p,double *t,double *q,double sfc_gph,double *gph){
    //assume hydrostatic balance
    int i;

    gph[0] = sfc_gph;
    for(i=1;i<nlevel;i++){
      gph[i] = gph[i-1] + 10;
    }

    return gph;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_virtual_temperature(double pressure,double temperature,double dew_pt){
    double wr = meteorology_cal_mixing_ratio(pressure,temperature,dew_pt);
    return temperature*(1.+wr/meteorology_epsilon)/(1.+wr);
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_virtual_temperature(double *pressure,double *temperature,double *qv,double *dew_point,double* qcloud,double *qrain){
    double wr,qc,qr;
    if(qv == NULL){
      wr = meteorology_cal_mixing_ratio(*pressure,*temperature,*dew_point);
    }
    else{
      wr = *qv;
    }
    if(qcloud == NULL){
      qc = 0;
    }
    else{
      qc = *qcloud;
    }
    if(qrain == NULL){
      qr = 0;
    }
    else{
      qr = *qrain;
    }
    return (*temperature)*(1.+wr/meteorology_epsilon - qc -qr)/(1.+wr);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_virtual_potential_temperature(double pressure,double temperature,double mixing_ratio){
    return meteorology_cal_theta(pressure,temperature)*(1.+mixing_ratio*0.61);
  }
  namespace meteorology_routines{
    ###CPP### ###CUDA### ###HOST### double funct_cal_mixing_ratio(double in,double *theta,int *notused){
      double t = meteorology_theta2temperature(in,*theta);
      return meteorology_cal_mixing_ratio(in,t,t);
    }
  };
  
  ###CPP### ###CUDA### ###HOST### double meteorology_cal_lift_condensation_level(double pressure,double temperature,double dew_point){
    if(temperature - dew_point > 50.){
      return 0.;
    }
    
    double mixing_ratio = meteorology_cal_mixing_ratio(pressure,temperature,dew_point);
    double *theta = new double;
    *theta = meteorology_cal_theta(pressure,temperature);
    double plcl = pressure;
    int error = numerical_schemes_secant_method(50000,pressure,100.,mixing_ratio,0.01,theta,NULL,meteorology_routines::funct_cal_mixing_ratio,plcl);
    if(error != _ERRORCODE_NOERROR){
      std::cout << "Error in cal_lift_condensation_level. Code = " << error << std::endl;
    }

    delete theta;

    return plcl;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_uv_to_dir(double u,double v){
    double result = atan2(-u,-v)/ang_to_rad;
    if(result < 0.) {
      result += 360.;
    }
    return result;
  }
  ###CUDA### ###GLOBAL### void meteorology_uv_to_dir_kernel(int nstate,double *u,double *v,double *dir){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      dir[i] = meteorology_uv_to_dir(u[i],v[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_uv_to_speed(double u,double v){
    return pow(u*u+v*v,0.5);
  }
  ###CUDA### ###GLOBAL### void meteorology_uv_to_speed_kernel(int nstate,double *u,double *v,double *speed){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      speed[i] = meteorology_uv_to_speed(u[i],v[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_sd_to_u(double speed,double dir){
    return -speed*sin(dir*ang_to_rad);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_sd_to_v(double speed,double dir){
    return -speed*cos(dir*ang_to_rad);
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_cal_ecmwf_model_level_pressure(double sfc_pressure,double coeff_a,double coeff_b){
    return coeff_b*sfc_pressure + coeff_a;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double saturation_adjustment_funct(double in,double *dparms,int *iparms){
    double alpha = meteorology_convective_cal_ice_ratio(in);
    double es = alpha*meteorology_cal_saturated_mixing_ratio(dparms[0],in) + (1. - alpha)*meteorology_cal_saturated_mixing_ratio_ice(dparms[0],in);
    double lv = alpha*meteorology_Lv + (1. - alpha)*meteorology_Lvice;
###CUDA### #ifndef __CUDA_ARCH__
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << "Saturation adjustment function: " << in << " " << dparms[0] << " " << dparms[1] << " " << dparms[2] << " " << alpha << " " << es << " " << meteorology_cal_mixing_ratio(dparms[0],in,in) << " " << lv << '\n';
    }
###CUDA### #endif
    //std::cout << "Saturation adjustment function: " << in << " " << dparms[0] << " " << dparms[1] << " " << dparms[2] << " " << alpha << " " << es << " " << meteorology_cal_mixing_ratio(dparms[0],in,in) << " " << lv << endl;
    return dparms[1] - in + lv/meteorology_Cpd*(dparms[2] - es);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### int meteorology_cal_saturation_adjustment(double pressure,double &t,double &q,double &condensate){
    double adj_t;
    double t0, t1;
    t1 = t;
    t0 = t + meteorology_Lv/meteorology_Cpd*q;
    //double temp;

    double dparms[3];
    dparms[0] = pressure;
    dparms[1] = t;
    dparms[2] = q;
    int *iparms = NULL;
    
    int error;
    //double mixing_coeff = 0.25;
###CUDA### #ifdef __CUDA_ARCH__
###CUDA### {
    error = _ERRORCODE_NOERROR;
    int i;
    double y = 0;
    double y0,y1,newx, newy;
    y0 = saturation_adjustment_funct(t0,dparms,NULL);
    y1 = saturation_adjustment_funct(t1,dparms,NULL);

    for(i=0;i<MAX_ITERATION_SATURATION_ADJUSTMENT;i++){
      newx = (t0*(y1-y) - t1*(y0-y))/(t1 - t0);
      newy = saturation_adjustment_funct(newx,dparms,NULL);

      if(fabs(newy -y) < DEFAULT_SATURATION_ADJUSTMENT_ACCURACY){
	adj_t = newx;
	break;
      }

      if((newy-y)*(y0-y)>=0){
	t0 = newx;
	y0 = newy;
      }
      else{
	t1 = newx;
	y1 = newy;
      }
    }
}
###CUDA### #else
    error = numerical_schemes_false_position_method(MAX_ITERATION_SATURATION_ADJUSTMENT,t0,t1,0,DEFAULT_SATURATION_ADJUSTMENT_ACCURACY,dparms,iparms,saturation_adjustment_funct,adj_t);
###CUDA### #endif
    
    if(error == _ERRORCODE_NOERROR){
      double alpha = meteorology_convective_cal_ice_ratio(adj_t);
      double lv = alpha*meteorology_Lv + (1. - alpha)*meteorology_Lvice;
      condensate = (adj_t - t)*meteorology_Cpd/lv;
      q -= condensate;
      t = adj_t;
    }
    return error;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_radiance2bt(double radiance,double wavelength){
    return phys_h*phys_c/(phys_k0*wavelength*log((2.*phys_h*pow(phys_c,2.))/(radiance*pow(wavelength,5.))+1.));
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_dbz2lambda(double dbz){
    return meteorology_marshall_palmer_dbz2lambda(marshall_palmer_n,dbz);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_dbz2lambda(double N0,double dbz){
    double z = pow(10.,0.1*dbz)*1e-18;
    //double z = exp(0.1*dbz*log(10.))*1e-18;
    double lambda = pow(720*N0/z,1./7.);
    //double lambda = exp(1./7.*log(720*N0/z));
    return lambda;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_lambda2dbz(double lambda){
    return meteorology_marshall_palmer_lambda2dbz(marshall_palmer_n,lambda);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_lambda2dbz(double N0,double lambda){
    double z = (720*N0/(lambda*lambda*lambda*lambda*lambda*lambda*lambda))*1e18;
    return 10.*log10(z);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_lambda2mass(double lambda){
    return meteorology_marshall_palmer_lambda2mass(marshall_palmer_n,lambda);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_lambda2mass(double N0,double lambda){
    return pi*N0*1000./(lambda*lambda*lambda*lambda);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_mass2lambda(double mass){
    return meteorology_marshall_palmer_mass2lambda(marshall_palmer_n,mass);
  }
  ###CUDA### ###GLOBAL### void meteorology_marshall_palmer_mass2lambda(int nstate,double *mass,double *lambda){
    int i=blockDim.x*blockIdx.x + threadIdx.x;
    
    if(i<nstate){
      lambda[i] = meteorology_marshall_palmer_mass2lambda(mass[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_mass2lambda(double N0,double mass){
    return pow((pi*N0*1000./mass),0.25);
    //return exp(0.25*log(pi*N0*1000./mass));
  }
  ###CUDA### ###GLOBAL### void meteorology_marshall_palmer_mass2lambda(int nstate,double *N0,double *mass,double *lambda){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      lambda[i] = meteorology_marshall_palmer_mass2lambda(N0[i],mass[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_dbz2mass(double dbz){
    return meteorology_marshall_palmer_dbz2mass(marshall_palmer_n,dbz);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_dbz2mass(double N0,double dbz){
    double lambda = meteorology_marshall_palmer_dbz2lambda(N0,dbz);
    return meteorology_marshall_palmer_lambda2mass(N0,lambda);
  }
  ###CUDA### ###GLOBAL### void meteorology_marshall_palmer_dbz2mass(int nstate,double *dbz,double *mass){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      mass[i] = meteorology_marshall_palmer_dbz2mass(dbz[i]);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_marshall_palmer_dbz2mass(int nstate,double *N0,double *dbz,double *mass){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      mass[i] = meteorology_marshall_palmer_dbz2mass(N0[i],dbz[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_mass2dbz(double mass){
    return meteorology_marshall_palmer_mass2dbz(marshall_palmer_n,mass);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_mass2dbz(double N0,double mass){
    double lambda = meteorology_marshall_palmer_mass2lambda(N0,mass);
    return meteorology_marshall_palmer_lambda2dbz(N0,lambda);
  }
  ###CUDA### ###GLOBAL### void  meteorology_marshall_palmer_mass2dbz(int nstate,double *mass,double *dbz){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      dbz[i] = meteorology_marshall_palmer_mass2dbz(mass[i]);
    }
  }
  ###CUDA### ###GLOBAL### void  meteorology_marshall_palmer_mass2dbz(int nstate,double *N0,double *mass,double *dbz){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      dbz[i] = meteorology_marshall_palmer_mass2dbz(N0[i],mass[i]);
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_snow_mass2dbz(double mass){
    return meteorology_marshall_palmer_snow_mass2dbz(2.e7,mass);
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_marshall_palmer_snow_mass2dbz(double N0,double mass){
    double lambda = pow((pi*N0*100./mass),0.25);
    double z = (720*N0*0.224*0.01/(lambda*lambda*lambda*lambda*lambda*lambda*lambda))*1e18;
    return 10.*log10(z);
    //return exp(0.25*log(pi*N0*1000./mass));
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double* meteorology_radarbeam_propagation_zrnic_funct(double *y,double p,double t,double pw,double dp,double dt,double dpw,double *f){
    double n=1.+0.0000776*(p + 4810*pw/t)/t;
    double dn = 0.0000776*(dp/t + 4810*dpw/(t*t) - dt*(p/(t*t) + 9620*pw/(t*t*t)));
    
    double beam_y = Earth_radius*1000. + y[0];
    
    f[0] = y[1];
    f[1] = (2./(beam_y) + dn/n)*y[1]*y[1] + beam_y*beam_y/(Earth_radius*Earth_radius*1000000.)*(1./beam_y + dn/n);
    f[2] = pow(1.+y[1]*y[1],0.5);
    
    return f;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double* meteorology_radarbeam_zrnic_rk4(int nheight,double *height,double *pressure,double *temperature,double *mixingratio,double stepsize,double *inputy,double *outputy){
    
    const double xstep[3]={0.5,0.5,1.0};
    const double ystep[4]={1.,2.,2.,1.};
    
    double k[4][3];
    double temp[3];
    double input_copy[3];
    int i,j,m;
    for(j=0;j<3;j++){
      temp[j] = inputy[j];
      input_copy[j] = inputy[j];
    }

    double p,t,pw,dp,dt,dpw;
    double dry_p1,dry_p2, pw1, pw2;
    for(i=0;i<4;i++){
      for(j=1;j<nheight;j++){
	if(height[j] > temp[0]){
	  break;
	}
      }

      dt = (temperature[j] - temperature[j-1])/(height[j] - height[j-1]);
      t = temperature[j-1] + dt*(temp[0] - height[j-1]);

      dry_p1 = meteorology_cal_dry_pressure(meteorology_cal_dry_density(temperature[j-1],pressure[j-1],mixingratio[j-1]),temperature[j-1]);
      dry_p2 = meteorology_cal_dry_pressure(meteorology_cal_dry_density(temperature[j],pressure[j],mixingratio[j]),temperature[j]);
    
      dp = (log(dry_p2 ) - log(dry_p1))/(height[j] - height[j-1]);
      p = exp(log(dry_p1) + (temp[0] - height[j-1])*dp);
      dp *= p;
      
      pw1 = meteorology_cal_dry_density(temperature[j-1],pressure[j-1],mixingratio[j-1]) * mixingratio[j-1] * meteorology_Rv * temperature[j-1] * 0.01;
      pw2 = meteorology_cal_dry_density(temperature[j],pressure[j],mixingratio[j]) * mixingratio[j] * meteorology_Rv * temperature[j] * 0.01;
    
      dpw = (pw2 - pw1)/(height[j] - height[j-1]);
      pw = pw1 + dpw*(temp[0] - height[j-1]);

      meteorology_radarbeam_propagation_zrnic_funct(temp,p,t,pw,dp,dt,dpw,k[i]);

      if(i<3){
#pragma unroll
	for(j=0;j<3;j++){
	  temp[j] = inputy[j] + xstep[i]*stepsize*k[i][j];
	}
      }
      else{
#pragma unroll
	for(j=0;j<3;j++){
	  outputy[j] = 0.;
	 #pragma unroll
	  for(m=0;m<4;m++){
	    outputy[j] += ystep[m]*k[m][j];
	  }
	  outputy[j] *= stepsize/6.0;
	  outputy[j] += input_copy[j];
	}
      }
    }
    return outputy;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### void meteorology_radarbeam_propagation_zrnic_rk4(int nheight,double *height,double *pressure,double *temperature,double *mixingratio,int nstep,double stepsize,double radar_altitude,double elevation,double *beam_path){
    double y[3];
    int i,j;
    
    y[0] = radar_altitude;
    y[1] = tan(elevation*ang_to_rad);
    y[2] = 0.;
    
    for(i=0;i<nstep;i++){
      for(j=1;j<3;j++){
	beam_path[3*i+j] = -9999.;
      }
      beam_path[3*i] = i*stepsize;
    }
    
    beam_path[1] = y[0];
    beam_path[2] = y[2];
    
    for(i=1;i<nstep;i++){
      meteorology_radarbeam_zrnic_rk4(nheight,height,pressure,temperature,mixingratio,stepsize,y,y);
      
      if(y[0] < 0. || y[0] > height[nheight-1]){
	break;
      }
      else{
	beam_path[3*i+1] = y[0];
	beam_path[3*i+2] = y[2];
      }
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### void meteorology_radarbeam_propagation_zrnic_rk4(int nheight,double *height,double *pressure,double *temperature,double *mixingratio,int nstep,double stepsize,double radar_altitude,double elevation,double **beam_path){
    double y[3];
    int i,j;
    
    y[0] = radar_altitude;
    y[1] = tan(elevation*ang_to_rad);
    y[2] = 0.;
    
    for(i=0;i<nstep;i++){
      for(j=1;j<3;j++){
	beam_path[i][j] = -9999.;
      }
      beam_path[i][0] = i*stepsize;
    }
    
    beam_path[0][1] = y[0];
    beam_path[0][2] = y[2];
    
    for(i=1;i<nstep;i++){
      meteorology_radarbeam_zrnic_rk4(nheight,height,pressure,temperature,mixingratio,stepsize,y,y);
      
      if(y[0] < 0. || y[0] > height[nheight-1]){
	break;
      }
      else{
	beam_path[i][1] = y[0];
	beam_path[i][2] = y[2];
      }
    }
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### void meteorology_radarbeam_propagation_zrnic_rk4(vertical_profile* profile,int nstep,double stepsize,double radar_altitude,double elevation,double **beam_path){
    if(profile!=NULL && profile->get_nz()>0){
      int nlevel = profile->get_nz();

      double *height = new double [nlevel];
      double *t = new double [nlevel];
      double *p = new double [nlevel];
      double *qv = new double [nlevel];

      int i;
      for(i=0;i<nlevel;i++){
	height[i] = profile->get_z(i);
	t[i] = *(profile->get_temperature()->get_data(0,0,i));
	p[i] = *(profile->get_pressure()->get_data(0,0,i));
	qv[i] = *(profile->get_qvapor()->get_data(0,0,i));
      }

      meteorology_radarbeam_propagation_zrnic_rk4(nlevel,height,p,t,qv,nstep,stepsize,radar_altitude,elevation,beam_path);

      delete [] height;
      delete [] p;
      delete [] t;
      delete [] qv;
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_radarbeam_propagation_zrnic_rk4_kernel(int nbeam,int nheight,int nprofile,double *height,double *pressure,double *temperature,double *mixingratio,int nstep,double stepsize,double *radar_altitude,double *elevation,double *beam_path){
    int beam_index = (blockDim.x*blockIdx.x + threadIdx.x)%nbeam;
    int profile_index = (blockDim.x*blockIdx.x + threadIdx.x)/nbeam;

    if(profile_index < nprofile){
      meteorology_radarbeam_propagation_zrnic_rk4(nheight,height+profile_index*nheight,pressure+profile_index*nheight,temperature+profile_index*nheight,mixingratio+profile_index*nheight,nstep,stepsize,radar_altitude[beam_index],elevation[beam_index],beam_path+3*beam_index+profile_index*3*nbeam);
    }
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double* meteorology_radarbeam_find_elevation_zrnic_rk4(vertical_profile* profile,double max_stepsize,double radar_altitude,double gcdist,double target_height,double precision,double *result){
    if(profile!=NULL && profile->get_nz()>0){
      int nlevel = profile->get_nz();

      double *height = new double [nlevel];
      double *t = new double [nlevel];
      double *p = new double [nlevel];
      double *qv = new double [nlevel];

      int i;
      for(i=0;i<nlevel;i++){
	height[i] = profile->get_z(i);
	t[i] = *(profile->get_temperature()->get_data(0,0,i));
	p[i] = *(profile->get_pressure()->get_data(0,0,i));
	qv[i] = *(profile->get_qvapor()->get_data(0,0,i));
      }

      meteorology_radarbeam_find_elevation_zrnic_rk4(nlevel,height,p,t,qv,max_stepsize,radar_altitude,gcdist,target_height,precision,result);

      delete [] height;
      delete [] p;
      delete [] t;
      delete [] qv;
    }
    
    return result;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double* meteorology_radarbeam_find_elevation_zrnic_rk4(int nheight,double *height,double *pressure,double *temperature,double *mixingratio,double max_stepsize,double radar_altitude,double gcdist,double target_height,double precision,double *result){

    int nstep = gcdist/max_stepsize + 1;
    double stepsize = gcdist/nstep;
    
    double y[3];
    int i,j;
    double old_angle = result[0];
    
    //first guess
    y[0] = radar_altitude;
    y[1] = tan(old_angle*ang_to_rad);//((radar_altitude + Earth_radius*1000.) - (Earth_radius*1000. + target_height)*cos(gcdist*0.001/Earth_radius))/((Earth_radius*1000. + target_height)*sin(gcdist*0.001/Earth_radius));
    y[2] = 0.;
    
    bool converge = 0;
    result[0] = -9999;
    for(i=0;i<MAX_ITERATION_FIND_ELEVATION && !converge;i++){
      for(j=0;j<=nstep;j++){
	meteorology_radarbeam_zrnic_rk4(nheight,height,pressure,temperature,mixingratio,stepsize,y,y);
      }

      if(fabs(y[0] - target_height) < precision){
	converge = 1;
      }
      else{
	//cout << old_angle << " " << y[0] << endl;
	old_angle += atan2((target_height - y[0]),gcdist)/ang_to_rad;
	y[0] = radar_altitude;
	y[1] = tan(old_angle*ang_to_rad);
	y[2] = 0.;
      }

      //result[0] = old_angle;
      //result[1] = y[1];

      if(converge){
	//cout << old_angle << " " << y[0] << endl;
	result[0] = old_angle;
	result[1] = y[2];
	//break;
      }
    }
    /*
    if(converge){
      y[0] = radar_altitude;
      y[1] = tan(result[0]*ang_to_rad);
      y[2] = 0.;
      
      for(j=0;j<=nstep;j++){
	meteorology_radarbeam_zrnic_rk4(nheight,height,pressure,temperature,mixingratio,stepsize,y,y);
	
	if(y[0] < 0){
	  converge = 0;
	  break;
	}
      }
    }
    
    if(!converge){
      result[0] = 9999.;
      result[1] = -9999.;
    }
    */
    return result;
  }
  ###CUDA### ###GLOBAL### void  meteorology_radarbeam_find_elevation_zrnic_rk4_kernel(int npoint,int nheight,int nprofile,double *height,double *pressure,double *temperature,double *mixingratio,double max_stepsize,double *radar_altitude,double *gcdist,double *target_height,double precision,double *result){
    int point_index = (blockDim.x*blockIdx.x + threadIdx.x)%npoint;
    int profile_index = (blockDim.x*blockIdx.x + threadIdx.x)/npoint;
    
    if(profile_index < nprofile){
      meteorology_radarbeam_find_elevation_zrnic_rk4(nheight,height+profile_index*nheight,pressure+profile_index*nheight,temperature+profile_index*nheight,mixingratio+profile_index*nheight,max_stepsize,radar_altitude[point_index],gcdist[point_index],target_height[point_index],precision,result+2*point_index+profile_index*2*npoint);
    }
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### void meteorology_gen_ISA_funct(int nlevel,int level_index,double rh,double *height,double *p,double *t,double *mixing_ratio){
    double delta_h = 20000./(nlevel - 1);
    height[level_index] = level_index*delta_h;
    if(height[level_index] < 11000.){
      t[level_index] = 288.15 - height[level_index]*6.5*0.001;
      p[level_index] = 1013.25*pow(1. - 0.0065*height[level_index]/288.15,5.2561);
      mixing_ratio[level_index] = 0.01*rh*meteorology_cal_mixing_ratio(p[level_index],t[level_index],t[level_index]);
    }
    else{
      t[level_index] = 216.65;
      p[level_index] = 226.32*exp(-meteorology_g0*(height[level_index] - 11000.)/(meteorology_R*216.65));
      mixing_ratio[level_index] = 0.;
    }
  }
  ###CPP### ###CUDA### ###HOST### void meteorology_gen_ISA(int nlevel,double rh,double *height,double *p,double *t,double *mixing_ratio){
    int level_index;
    
    for(level_index=0;level_index < nlevel;level_index++){
      meteorology_gen_ISA_funct(nlevel,level_index,rh,height,p,t,mixing_ratio);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_gen_ISA_kernel(int nlevel,double rh,double *height,double *p,double *t,double *mixing_ratio){
    int level_index=blockDim.x*blockIdx.x + threadIdx.x;
    
    if(level_index < nlevel){
      meteorology_gen_ISA_funct(nlevel,level_index,rh,height,p,t,mixing_ratio);
    }
  }

  ###CUDA### ###GLOBAL### void meteorology_cal_vws_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *u,double *v,double *vws){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
/*
    int zindex = i/(nx*ny);
    int xindex = (i/ny)%nx;
    int yindex = i%ny;
*/
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    //    if(zindex >= 1 && zindex < nz-1){
    if(xindex<nx){
      /*
      double ws_up, ws_down;
      ws_up = pow(u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1]*u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1] + v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1]*v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1],0.5);
      ws_down = pow(u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1]*u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1] + v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1]*v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1],0.5);
      vws[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad] = (ws_up - ws_down)/(z[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1] - z[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1]);
      */
      double u_diff, v_diff;
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_up_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+1+zpad;
      int pt_dn_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex-1+zpad;
      u_diff = u[pt_up_index] - u[pt_dn_index];
      v_diff = v[pt_up_index] - v[pt_dn_index];
      vws[pt_index] = fabs(pow(u_diff*u_diff + v_diff*v_diff,0.5)/(z[pt_up_index] - z[pt_dn_index]));
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_vorticity(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *u,double *v,double *dudy,double *dvdx,double *winds,double *dVdx,double *dVdy,double *vorticity_curvarture,double *vorticity_shear){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      double vorticity = dvdx[pt_index] - dudy[pt_index];
      if(winds[pt_index] > c_zero){
	vorticity_shear[pt_index] = (v[pt_index]*dVdx[pt_index] - u[pt_index]*dVdy[pt_index])/winds[pt_index];
      }
      else{
	vorticity_shear[pt_index] = 0.;
      }

      vorticity_curvarture[pt_index] = vorticity - vorticity_shear[pt_index];
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_ti2_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *dudx,double *dudy,double *dvdx,double *dvdy,double *vws,double *ti){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
/*
    int zindex = i/(nx*ny);
    int xindex = (i/ny)%nx;
    int yindex = i%ny;
*/
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    //    if(zindex >= 1 && zindex < nz-1){
    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      double stretch = dudy[pt_index] + dvdx[pt_index];
      double shear = dudx[pt_index] - dvdy[pt_index];
      double conv = -(dudx[pt_index] + dvdy[pt_index]);
      ti[pt_index] = vws[pt_index]*(pow(stretch*stretch + shear*shear,0.5) + conv);
    }    
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_ti3_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *thetav,double *vws,double *ti2,double *ti3){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      ti3[pt_index] = ti2[pt_index]*(1. - 1./(1. + 0.25*vws[pt_index]*vws[pt_index]/(meteorology_g0*((thetav[pt_index+1] - thetav[pt_index-1])/(z[pt_index+1] - z[pt_index-1]))/thetav[pt_index])));
    }    
  }
###CUDA### ###GLOBAL### void meteorology_cal_ti4_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *coriolis_fre,double *vorticity_curvature,double *vorticity_shear,double *z,double *thetav,double *vws,double *ti4){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_index_2d = xindex*ny+yindex;

      double epsilon = coriolis_fre[pt_index_2d] + fabs(vorticity_curvature[pt_index] - vorticity_shear[pt_index]);
      epsilon*=epsilon;
      double vorticity = vorticity_curvature[pt_index] + vorticity_shear[pt_index];
      vorticity*=vorticity;
      ti4[pt_index] = (1. - 1./(1. + 0.25*vws[pt_index]*vws[pt_index]/(meteorology_g0*((thetav[pt_index+1] - thetav[pt_index-1])/(z[pt_index+1] - z[pt_index-1]))/thetav[pt_index])))*vorticity/epsilon;
    }    
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_dti_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *ti2,double *div,double *div_p3,double *dti){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
/*
    int zindex = i/(nx*ny);
    int xindex = (i/ny)%nx;
    int yindex = i%ny;
*/
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    //    if(zindex >= 1 && zindex < nz-1){
    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      dti[pt_index] = ti2[pt_index] + div_p3[pt_index] - div[pt_index];
    }    
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_richardson_num_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *theta,double *z,double *vws,double *ri){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
/*
    int zindex = i/(nx*ny);
    int xindex = (i/ny)%nx;
    int yindex = i%ny;
*/
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    //    if(zindex >= 1 && zindex < nz-1){
    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_up_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+1+zpad;
      int pt_dn_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex-1+zpad;
      ri[pt_index] = meteorology_g0*(theta[pt_dn_index] - theta[pt_up_index])/(theta[pt_index]*(z[pt_dn_index] - z[pt_up_index])*vws[pt_index]*vws[pt_index]);

    }    
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_colson_panofsky_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *ri,double *vws,double *cp){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_up_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+1+zpad;
      int pt_dn_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex-1+zpad;
      double delta_z = z[pt_up_index] - z[pt_dn_index];
      cp[pt_index] = delta_z*delta_z*vws[pt_index]*vws[pt_index]*(1. - ri[pt_index]/0.5);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_tke_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *ri,double *vws,double *tke,double *tke_dtf){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_up_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+1+zpad;
      int pt_dn_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex-1+zpad;
      double delta_z = z[pt_up_index] - z[pt_dn_index];
      double theta, theta_up,theta_down;
      theta = vws[pt_index]*vws[pt_index]*(1 - ri[pt_index]/default_Pr);
      if(theta < 0){
	tke[pt_index] = 0.;
      }
      else{
	theta_up = vws[pt_up_index]*vws[pt_up_index]*(1 - ri[pt_up_index]/default_Pr);
	theta_down = vws[pt_dn_index]*vws[pt_dn_index]*(1 - ri[pt_dn_index]/default_Pr);
	if(theta_up < 0){
	  theta_up = 0.;
	}
	if(theta_down < 0){
	  theta_down = 0.;
	}
	if(theta_up == theta_down){
	  tke[pt_index] = 0.;
	}
	else{
	  tke[pt_index] = libjeff::pow(theta,1.5)*delta_z/(theta_up - theta_down);
	}
      }
      tke[pt_index] = theta;
      tke_dtf[pt_index] = vws[pt_index]*vws[pt_index]*(1.44 - ri[pt_index]/default_Pr)/1.92;
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_tke_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *ri,double *vws,double *tke,double *tke_dtf,double *tke_adj1_mem,double *tke_adj2_mem,double *tke_adj3_mem,double *tke_adj4_mem,double *tke_adj5_mem,double *tke_adj6_mem){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_up_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+1+zpad;
      int pt_dn_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex-1+zpad;
      double delta_z = z[pt_up_index] - z[pt_dn_index];
      double theta, theta_up,theta_down;
      theta = vws[pt_index]*vws[pt_index]*(1 - ri[pt_index]/default_Pr);
      if(theta < 0){
	tke[pt_index] = 0.;
      }
      else{
	theta_up = vws[pt_up_index]*vws[pt_up_index]*(1 - ri[pt_up_index]/default_Pr);
	theta_down = vws[pt_dn_index]*vws[pt_dn_index]*(1 - ri[pt_dn_index]/default_Pr);
	if(theta_up < 0){
	  theta_up = 0.;
	}
	if(theta_down < 0){
	  theta_down = 0.;
	}
	if(fabs(theta_up - theta_down) < 1e-100){
	  tke[pt_index] = 0.;
	}
	else{
	  tke[pt_index] = libjeff::pow(theta,1.5)*delta_z/(theta_up - theta_down);
	}
      }
      tke_dtf[pt_index] = vws[pt_index]*vws[pt_index]*(1.44 - ri[pt_index]/default_Pr)/1.92;
      tke_adj1_mem[pt_index] = vws[pt_index];
      tke_adj2_mem[pt_index] = ri[pt_index];
      tke_adj3_mem[pt_index] = vws[pt_up_index];
      tke_adj4_mem[pt_index] = ri[pt_up_index];
      tke_adj5_mem[pt_index] = vws[pt_dn_index];
      tke_adj6_mem[pt_index] = ri[pt_dn_index];
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_browns_index_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *dudx,double *dudy,double *dvdx,double *dvdy,double *coriolis_fre,double *vws,double *browns_index){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_index_2d = xindex*ny+yindex;
      double vort_a = dvdx[pt_index] - dudy[pt_index] + coriolis_fre[pt_index_2d];
      double dsh = dvdx[pt_index] + dudy[pt_index];
      double dst = dudx[pt_index] - dvdy[pt_index];
	
      browns_index[pt_index] = (0.3*vort_a*vort_a + dsh*dsh + dst*dst)*vws[pt_index]*vws[pt_index]/24.;
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_pv_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *dvdx,double *dudy,double *p,double *coriolis_fre,double *theta,double *pv){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      int pt_index_2d = xindex*ny+yindex;

      pv[pt_index] = -meteorology_g0*(dvdx[pt_index] - dudy[pt_index] + coriolis_fre[pt_index_2d])*(theta[pt_index+1] - theta[pt_index-1])/(p[pt_index+1] - p[pt_index-1])*0.01;

      if(xpad > 0 && xindex == 0){
	pv[((xindex+xpad-1)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad] = pv[pt_index];
      }
      else if(xpad > 0 && xindex == nx-1){
	pv[((xindex+xpad+1)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad] = pv[pt_index];
      }

      if(ypad > 0 && yindex == 0){
	pv[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad-1))*(nz+2*zpad)+zindex+zpad] = pv[pt_index];
      }
      else if(ypad > 0 && yindex == ny-1){
	pv[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad+1))*(nz+2*zpad)+zindex+zpad] = pv[pt_index];
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_mos_cat_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *dudx,double *dudy,double *dvdx,double *dvdy,double *winds,double *mos_cat){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;

      double stretch = dudy[pt_index] + dvdx[pt_index];
      double shear = dudx[pt_index] - dvdy[pt_index];

      mos_cat[pt_index] = winds[pt_index]*pow(stretch*stretch + shear*shear,0.5);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_dutton_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *dVdx,double *dVdy,double *u,double *v,double *winds,double *vws,double *dutton){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;

      dutton[pt_index] = 1.25*(u[pt_index]*dVdy[pt_index] - v[pt_index]*dVdx[pt_index])/winds[pt_index] + 0.25*vws[pt_index]*vws[pt_index]* + 10.5;
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_wind_index_kernel(int nx,int ny,int nz,int xpad,int ypad,int zpad,double *z,double *u,double *v,double *winds,double *wind_index){
    int i = blockDim.x*blockIdx.x + threadIdx.x;
    int zindex = i%(nz-2)+1;
    int yindex = (i/(nz-2))%ny;
    int xindex = (i/((nz-2)*ny));

    if(xindex<nx){
      int pt_index = ((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad;
      double dthetadz = fabs(meteorology_uv_to_dir(u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1],v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1]) - meteorology_uv_to_dir(u[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1],v[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1]));
      if(dthetadz > 180.){
	dthetadz = 360. - dthetadz;
      }
      dthetadz /= ang_to_rad;
      dthetadz /= (z[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad+1] - z[((xindex+xpad)*(ny+2*ypad)+(yindex+ypad))*(nz+2*zpad)+zindex+zpad-1]);

      wind_index[pt_index] = winds[pt_index]*dthetadz;
    }
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_cal_TI2(const grid_data_field* z,const grid_data_field* u,const grid_data_field* v,const grid_data_field* map_factor_x,const grid_data_field* map_factor_y,grid_data_field *ti2,bool gpu_mode){
    ###CPP### gpu_mode = false;
    if(grid_data_field_check_grid_inconsistence(z,u) ||
       grid_data_field_check_grid_inconsistence(z,v) ||
       grid_data_field_check_grid_inconsistence(z,ti2) ||
       (map_factor_x != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_x)) ||
       (map_factor_y != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_y))){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    int error;

    if(gpu_mode){
      //this part of code only generates if GPU mode is enabled
      ###CUDA###{
	size_t free, total;
	cudaMemGetInfo(&free,&total);

	int nbatchx, nbatchy;
	int error = determine_nbatchxy(nbatchx,nbatchy,z->get_nx(),z->get_ny(),0,0,((8.*z->get_nx())*z->get_ny()*z->get_nz()*(4+5) + 8.*(z->get_nx())*z->get_ny()*(4))*1.2); // memory ~ (nx) * ny *nz * 8 (num bytes of double) * (4 + 5 ) + (nx) * ny * 8 * 4 (map factor + lat-long) + 20% contingency

	if(error){
	  return error;
	}
	
	double *z_mem, *u_mem, *v_mem, *ti_mem;
	double *dz_mem, *du_mem, *dv_mem, *dti_mem;
	double *dudx,*dudy,*dvdx,*dvdy;
	double *dvws;
	double *map_factor_x_mem, *map_factor_y_mem;
	double *d_map_factor_x_mem = NULL;
	double *d_map_factor_y_mem = NULL;
	double *lat, *lon;
	double *dlat, *dlon;
	int batchx_index,batchy_index;
	int batchx_size,batchy_size;
	batchx_size = z->get_nx()/nbatchx;
	batchy_size = z->get_ny()/nbatchy;
	int i,j,k;

	//std::cout << "Batch size: " << nbatchx << " X " << nbatchy << endl;

	lon = new double [(batchx_size+2)*(batchy_size+2)];
	lat = new double [(batchx_size+2)*(batchy_size+2)];
	z_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	u_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	v_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	ti_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	if(map_factor_x != NULL && map_factor_y != NULL){
	  map_factor_x_mem = new double [(batchx_size+2)*(batchy_size+2)];
	  map_factor_y_mem = new double [(batchx_size+2)*(batchy_size+2)];
	}

	cudaMalloc(&dlat,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dlon,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dz_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvws,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaMalloc(&d_map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	  cudaMalloc(&d_map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	}
	else{
	  d_map_factor_x_mem = NULL;
	  d_map_factor_y_mem = NULL;
	}

	int numthreads = cuda_setting::get_numthreads();
	dim3 grid;

	int i_offset, j_offset;
	int index_2d, index_3d;

	for(batchy_index=0;batchy_index<nbatchy;batchy_index++){
	  for(batchx_index=0;batchx_index<nbatchx;batchx_index++){
	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *(map_factor_x->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0));
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *(map_factor_y->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0));
		}
	      }
	    }

	    if(batchx_index==0){
	      i=-1;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0) - z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(u->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(v->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(map_factor_x->get_nx()-1,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(map_factor_y->get_nx()-1,j_offset+j,0));
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(0,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(0,j_offset+j,0));
		  }
		}
	      }
	    }
	    else{
	      i=-1;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchx_index==nbatchx-1){
	      i=batchx_size;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0) + z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(0,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(0,j_offset+j,0);
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(z->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(z->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(z->get_nx()-1,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(z->get_nx()-1,j_offset+j,0);
		  }
		}
	      }
	    }
	    else{
	      i=batchx_size;
	      for(j=0;j<batchy_size;j++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_x->get_data((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,0);
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_y->get_data((batchx_index+1)*batchx_size,batchy_index*batchy_size+j,0);
		}
	      }
	    }

	    if(batchy_index==0){
	      j=-1;
	      for(i=0;i<batchx_size;i++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y(batchx_index*batchx_size+i,0,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x(batchx_index*batchx_size+i,0,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data(batchx_index*batchx_size+i,0,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data(batchx_index*batchx_size+i,0,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data(batchx_index*batchx_size+i,0,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_x->get_data(batchx_index*batchx_size+i,0,0);
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_y->get_data(batchx_index*batchx_size+i,0,0);
		}
	      }
	    }
	    else{
	      j=-1;
	      for(i=0;i<batchx_size;i++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_x->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_y->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,0);
		}
	      }
	    }
	    
	    if(batchy_index==nbatchy-1){
	      j=batchy_size;
	      for(i=0;i<batchx_size;i++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y(batchx_index*batchx_size+i,z->get_ny()-1,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x(batchx_index*batchx_size+i,z->get_ny()-1,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data(batchx_index*batchx_size+i,z->get_ny()-1,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data(batchx_index*batchx_size+i,z->get_ny()-1,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data(batchx_index*batchx_size+i,z->get_ny()-1,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_x->get_data(batchx_index*batchx_size+i,z->get_ny()-1,0);
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_y->get_data(batchx_index*batchx_size+i,z->get_ny()-1,0);
		}
	      }
	    }
	    else{
	      j=batchy_size;
	      for(i=0;i<batchx_size;i++){
		lat[(i+1)*(batchy_size+2)+j+1] = z->get_y(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,0);
		lon[(i+1)*(batchy_size+2)+j+1] = z->get_x(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,0);
		for(k=0;k<z->get_nz();k++){
		  z_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(z->get_data(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,k));
		  u_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(u->get_data(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,k));
		  v_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] = *(v->get_data(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_x->get_data(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,0);
		  map_factor_y_mem[(i+1)*(batchy_size+2)+j+1] = *map_factor_y->get_data(batchx_index*batchx_size+i,(batchy_index+1)*batchy_size,0);
		}
	      }
	    }
	    /*
	    i=1;
	    std::cout << "Latitude:" << endl;
	    for(j=0;j<batchy_size+2;j++){
	      std::cout << lat[i*(batchy_size+2)+j] << " ";
	    }
	    std::cout << endl;
	    j=1;
	    std::cout << "Longitude:" << endl;
	    for(i=0;i<batchx_size+2;i++){
	      std::cout << lon[i*(batchy_size+2)+j] << " ";
	    }
	    std::cout << endl;
	    */
	    cudaMemcpy(dlat,lat,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dlon,lon,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    if(map_factor_x != NULL && map_factor_y != NULL){
	      cudaMemcpy(d_map_factor_x_mem,map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	      cudaMemcpy(d_map_factor_y_mem,map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    }
	    cudaMemcpy(dz_mem,z_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(du_mem,u_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dv_mem,v_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);

	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy@meteorology_cal_TI2" <<endl;

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_mem,d_map_factor_x_mem,dudx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_TI2" <<endl;
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dv_mem,d_map_factor_x_mem,dvdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,du_mem,d_map_factor_y_mem,dudy);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_mem,d_map_factor_y_mem,dvdy);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*(z->get_nz()-2)/numthreads);
	    meteorology_cal_vws_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,dvws);
	    meteorology_cal_ti2_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,dvws,dti_mem);

	    cudaMemcpy(ti_mem,dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	    
	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		for(k=0;k<z->get_nz();k++){
		  *(ti2->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k)) = ti_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		}
	      }
	    }
	  }
	}

	delete [] lat;
	delete [] lon;
	if(map_factor_x != NULL && map_factor_y != NULL){
	  delete [] map_factor_x_mem;
	  delete [] map_factor_y_mem;
	  cudaFree(d_map_factor_x_mem);
	  cudaFree(d_map_factor_y_mem);
	}
	delete [] z_mem;
	delete [] u_mem;
	delete [] v_mem;
	delete [] ti_mem;

	cudaFree(dlat);
	cudaFree(dlon);
	cudaFree(dz_mem);
	cudaFree(du_mem);
	cudaFree(dv_mem);
	cudaFree(dti_mem);

	cudaFree(dudx);
	cudaFree(dudy);
	cudaFree(dvdx);
	cudaFree(dvdy);
	cudaFree(dvws);
      }
    }
    else{
      grid_data *work_mem;
      grid_data_allocation(z->get_grid_code(),work_mem);
//std::cout << "Work memory type created. " << z->get_grid_code() << endl;
      work_mem->create(z->get_nx(),z->get_ny(),z->get_nz(),7); //dudx, dudy, dvdx, dvdy, convergence, shear, deformation, vws
//std::cout << "Work memory created." << endl;
      grid_data_field* work[7];
      int i,j,k;
      for(i=0;i<7;i++){
	work[i] = new grid_data_field;
	work[i]->set(work_mem,i);
      }
      //std::cout << "Work pointer ok." << endl;

      work[0]->cal_x_derivatives(u);
      work[1]->cal_y_derivatives(u);
      work[2]->cal_x_derivatives(v);
      work[3]->cal_y_derivatives(v);

      if(map_factor_x != NULL){
	*(work[0]) *= *map_factor_x;
	*(work[2]) *= *map_factor_x;
      }

      if(map_factor_y != NULL){
	*(work[1]) *= *map_factor_y;
	*(work[3]) *= *map_factor_y;
      }
      
//std::cout << "Derivatives calculated." << endl;

      error = work[5]->copy(*(work[2]));
      *(work[5])+=*(work[1]);
    
      error = work[4]->copy(*(work[0]));
      *(work[4])-=*(work[3]);

    //deformation
      for(i=0;i<work[6]->get_nx();i++){
	for(j=0;j<work[6]->get_ny();j++){
	  for(k=0;k<work[6]->get_nz();k++){
	    *(work[6]->get_data(i,j,k)) = pow((*(work[4]->get_data(i,j,k)))*(*(work[4]->get_data(i,j,k))) + (*(work[5]->get_data(i,j,k)))*(*(work[5]->get_data(i,j,k))),0.5);
	  }
	}
      }
//std::cout << "Deformation calculation done." << endl;

      //divergence
      work[4]->copy(*(work[0]));
      *(work[4])+=*(work[3]);

      *(work[6])-=*(work[4]);
//std::cout << "convergence calculation done." << endl;

      //vws
      for(i=0;i<ti2->get_nx();i++){
	for(j=0;j<ti2->get_ny();j++){
	  for(k=1;k<ti2->get_nz()-1;k++){
	    //*(ti2->get_data(i,j,k)) = (pow((*(u->get_data(i,j,k+1)))*(*(u->get_data(i,j,k+1))) + (*(v->get_data(i,j,k+1)))*(*(v->get_data(i,j,k+1))),0.5) - pow((*(u->get_data(i,j,k-1)))*(*(u->get_data(i,j,k-1))) + (*(v->get_data(i,j,k-1)))*(*(v->get_data(i,j,k-1))),0.5))/(*(z->get_data(i,j,k+1)) - *(z->get_data(i,j,k-1)));
	    *(ti2->get_data(i,j,k)) = pow( ((*(u->get_data(i,j,k+1))) - (*(u->get_data(i,j,k-1)))) * ((*(u->get_data(i,j,k+1))) - (*(u->get_data(i,j,k-1)))) + ((*(v->get_data(i,j,k+1))) - (*(v->get_data(i,j,k-1)))) * ((*(v->get_data(i,j,k+1))) - (*(v->get_data(i,j,k-1)))),0.5)/(*(z->get_data(i,j,k+1)) - *(z->get_data(i,j,k-1)));
	  }
	  *(ti2->get_data(i,j,0)) = *(ti2->get_data(i,j,1));
	  *(ti2->get_data(i,j,ti2->get_nz()-1)) = *(ti2->get_data(i,j,ti2->get_nz()-2));
	}
      }
//std::cout << "vws calculation done." << endl;

      (*ti2) *= *(work[6]);
//    std::cout << "TI2 calculation done." << endl;
      
      for(i=0;i<7;i++){
	delete work[i];
      }
      delete work_mem;
    }
  
    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_cal_TI3(const grid_data_field* z,const grid_data_field *p,const grid_data_field *t,const grid_data_field *q,const grid_data_field *ti2,const grid_data_field *vws,grid_data_field *ti3,bool gpu_mode){
    if(grid_data_field_check_grid_inconsistence(z,q) ||
       grid_data_field_check_grid_inconsistence(z,p) ||
       grid_data_field_check_grid_inconsistence(z,t) ||
       grid_data_field_check_grid_inconsistence(z,ti2) ||
       grid_data_field_check_grid_inconsistence(z,vws) ||
       grid_data_field_check_grid_inconsistence(z,ti3)){
      return _ERRORCODE_DATAINCONSISTENCE;
    }
    
    int error = _ERRORCODE_NOERROR;

    if(gpu_mode){
      return _ERRORCODE_NOTIMPLEMENTED;
    }
    else{
      int i,j,k;
      for(i=0;i<ti3->get_nx();i++){
	for(j=0;j<ti3->get_ny();j++){
	  for(k=1;k<ti3->get_nz()-1;k++){
	    *(ti3->get_data(i,j,k)) = 1. - 1./(1. + 0.25*(*(vws->get_data(i,j,k)))*(*(vws->get_data(i,j,k)))/((meteorology_g0/meteorology_cal_virtual_potential_temperature(*(p->get_data(i,j,k)),*(t->get_data(i,j,k)),*(q->get_data(i,j,k))))*((meteorology_cal_virtual_potential_temperature(*(p->get_data(i,j,k+1)),*(t->get_data(i,j,k+1)),*(q->get_data(i,j,k+1))) - meteorology_cal_virtual_potential_temperature(*(p->get_data(i,j,k-1)),*(t->get_data(i,j,k-1)),*(q->get_data(i,j,k-1))))/(*(z->get_data(i,j,k+1)) - *(z->get_data(i,j,k-1))))));
	  }
	}
      }
      (*ti3) *= *(ti2);
    }

    return error;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_cal_turb(const grid_data_field* z,const grid_data_field* u,const grid_data_field* v,const grid_data_field* u_p3,const grid_data_field* v_p3,const grid_data_field *t,const grid_data_field* map_factor_x,const grid_data_field* map_factor_y,grid_data_field *ti2,grid_data_field *dti,grid_data_field *vws,grid_data_field *inri,grid_data_field *div,bool gpu_mode,double **work_space){
    ###CPP### gpu_mode = false;
    if(grid_data_field_check_grid_inconsistence(z,u) ||
       grid_data_field_check_grid_inconsistence(z,v) ||
       grid_data_field_check_grid_inconsistence(z,u_p3) ||
       grid_data_field_check_grid_inconsistence(z,v_p3) ||
       grid_data_field_check_grid_inconsistence(z,t) ||
       grid_data_field_check_grid_inconsistence(z,ti2) ||
       grid_data_field_check_grid_inconsistence(z,vws) ||
       grid_data_field_check_grid_inconsistence(z,dti) ||
       grid_data_field_check_grid_inconsistence(z,inri) ||
       (div != NULL && grid_data_field_check_grid_inconsistence(z,div)) ||
       (map_factor_x != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_x)) ||
       (map_factor_y != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_y))){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    if(gpu_mode){
      //this part of code only generates if GPU mode is enabled
      ###CUDA###{
	size_t free, total;
	cudaMemGetInfo(&free,&total);

	int nbatchx, nbatchy;
	int error = determine_nbatchxy(nbatchx,nbatchy,z->get_nx(),z->get_ny(),0,0,((8.*z->get_nx())*z->get_ny()*z->get_nz()*(4+7+6) + 8.*(z->get_nx())*z->get_ny()*(4))*1.2); // memory ~ (nx) * ny *nz * 8 (num bytes of double) * (4 + 7 + 6) + (nx) * ny * 8 * 4 (map factor + lat-long) + 20% contingency

	if(error){
	  return error;
	}

	double *z_mem, *u_mem, *v_mem, *t_mem, *p_mem, *ti_mem, *dti_mem, *vws_mem, *ri_mem;
	double *div_mem;
	double *u_p3_mem, *v_p3_mem;
	double *dz_mem, *du_mem, *dv_mem, *dt_mem, *dp_mem, *d_ti_mem, *d_dti_mem, *d_vws_mem,*d_ri_mem;
	double *du_p3_mem, *dv_p3_mem;
	double *d_div, *d_div_p3;
	double *dudx,*dudy,*dvdx,*dvdy;
	double *map_factor_x_mem, *map_factor_y_mem;
	double *d_map_factor_x_mem = NULL;
	double *d_map_factor_y_mem = NULL;
	double *lat, *lon;
	double *dlat, *dlon;
	int batchx_index,batchy_index;
	int batchx_size,batchy_size;
	batchx_size = z->get_nx()/nbatchx;
	batchy_size = z->get_ny()/nbatchy;
	int i,j,k;

	if(work_space == NULL){
	  lon = new double [(batchx_size+2)*(batchy_size+2)];
	  lat = new double [(batchx_size+2)*(batchy_size+2)];
	  z_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  t_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  p_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ti_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  dti_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  vws_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ri_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem = new double [(batchx_size+2)*(batchy_size+2)];
	    map_factor_y_mem = new double [(batchx_size+2)*(batchy_size+2)];
	  }
	}
	else{
	  lon = work_space[0];
	  lat = work_space[1];
	  z_mem = work_space[2];
	  u_mem = work_space[3];
	  v_mem = work_space[4];
	  t_mem = work_space[5];
	  p_mem = work_space[6];
	  u_p3_mem = work_space[7];
	  v_p3_mem = work_space[8];
	  ti_mem = work_space[9];
	  dti_mem = work_space[10];
	  vws_mem = work_space[11];
	  ri_mem = work_space[12];
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem = work_space[13];
	    map_factor_y_mem = work_space[14];
	  }
	}

	if(div!=NULL){
	  div_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	}

	cudaMalloc(&dlat,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dlon,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dz_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dt_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dp_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ri_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vws_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaMalloc(&d_map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	  cudaMalloc(&d_map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	}
	else{
	  d_map_factor_x_mem = NULL;
	  d_map_factor_y_mem = NULL;
	}

	int numthreads = cuda_setting::get_numthreads();
	dim3 grid;

	clock_t times[2];
	int i_offset, j_offset;
	int index_2d, index_3d;

	for(batchy_index=0;batchy_index<nbatchy;batchy_index++){
	  j_offset = batchy_index*batchy_size;
	  for(batchx_index=0;batchx_index<nbatchx;batchx_index++){
	    i_offset = batchx_index*batchx_size;
	    times[0] = clock();
	    for(i=0;i<batchx_size;i++){
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = (t->get_z(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *(map_factor_x->get_data(i_offset+i,j_offset+j,0));
		  map_factor_y_mem[index_2d] = *(map_factor_y->get_data(i_offset+i,j_offset+j,0));
		}
	      }
	    }

	    if(batchx_index==0){
	      i=-1;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0) - z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(u->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(v->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(t->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = (t->get_z(t->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(u_p3->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(v_p3->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(map_factor_x->get_nx()-1,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(map_factor_y->get_nx()-1,j_offset+j,0));
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = (t->get_z(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(0,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(0,j_offset+j,0));
		  }
		}
	      }
	    }
	    else{
	      i=-1;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = (t->get_z(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchx_index==nbatchx-1){
	      i=batchx_size;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0) + z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = (t->get_z(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(0,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(0,j_offset+j,0);
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(z->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(z->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(z->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = (t->get_z(z->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(z->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(z->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(z->get_nx()-1,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(z->get_nx()-1,j_offset+j,0);
		  }
		}
	      }
	    }
	    else{
	      i=batchx_size;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y((batchx_index+1)*batchx_size,j_offset+j,0);
		lon[index_2d] = z->get_x((batchx_index+1)*batchx_size,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  p_mem[index_3d] = (t->get_z((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		}
	      }
	    }

	    if(batchy_index==0){
	      j=-1;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0) - z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = (t->get_z(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0);
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = (t->get_z(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	    }
	    else{
	      j=-1;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = (t->get_z(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchy_index==nbatchy-1){
	      j=batchy_size;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0) + z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = (t->get_z(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0);
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = (t->get_z(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	    }
	    else{
	      j=batchy_size;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,(batchy_index+1)*batchy_size,0);
		lon[index_2d] = z->get_x(i_offset+i,(batchy_index+1)*batchy_size,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  p_mem[index_3d] = (t->get_z(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		}
	      }
	    }

	     times[1] = clock();
	     std::cout << "Data prepared for memory transfer. " << cal_sec_between(times[0],times[1]) << "s" << endl;

	    cudaMemcpy(dlat,lat,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dlon,lon,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    if(map_factor_x != NULL && map_factor_y != NULL){
	      cudaMemcpy(d_map_factor_x_mem,map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	      cudaMemcpy(d_map_factor_y_mem,map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice);
	    }
	    cudaMemcpy(dz_mem,z_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(du_mem,u_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dv_mem,v_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dt_mem,t_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dp_mem,p_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(du_p3_mem,u_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(dv_p3_mem,v_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice);

	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy@meteorology_cal_TI2" <<endl;

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_mem,d_map_factor_x_mem,dudx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_TI2" <<endl;
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dv_mem,d_map_factor_x_mem,dvdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,du_mem,d_map_factor_y_mem,dudy);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_mem,d_map_factor_y_mem,dvdy);
	    /*
	    double *h_dudx = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    cudaMemcpy(h_dudx,dudx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	    grid_data_field* test_field = new grid_data_field;
	    grid_data *work_mem;
	    grid_data_allocation(z->get_grid_code(),work_mem);
	    work_mem->create(z->get_nx(),z->get_ny(),z->get_nz(),1);
	    test_field->set(work_mem,0);
	    test_field->cal_x_derivatives(u);
	    *(test_field) *= *map_factor_x;

	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		for(k=0;k<z->get_nz();k++){
		  if(fabs(*(test_field->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k)) - h_dudx[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k]) > 1e-10){
		    std::cout << "Difference found: " << i << " " << j << " " << k << " " << *(test_field->get_data(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k)) << " " << h_dudx[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k] << " " << u->get_x(batchx_index*batchx_size+i,batchy_index*batchy_size+j,k) << std::endl;
		  }
		}
	      }
	    }

	    delete [] h_dudx;
	    */
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);

	    cuda_add<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx,dvdy,d_div);

	    if(div!=NULL){
	      cudaMemcpy(div_mem,d_div,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	      for(j=0;j<batchy_size;j++){
		for(i=0;i<batchx_size;i++){
		  for(k=0;k<z->get_nz();k++){
		    *(div->get_data(i_offset+i,j_offset+j,k)) = div_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  }
		}
	      }
	    }

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*(z->get_nz()-2)/numthreads);

	    meteorology_cal_vws_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,d_vws_mem);
	    meteorology_cal_ti2_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_vws_mem,d_ti_mem);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_p3_mem,d_map_factor_x_mem,dudx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_p3_mem,d_map_factor_y_mem,dvdy);

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_add<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx,dvdy,d_div_p3);

	    cuda_multiply<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti_mem,1.e7,d_ti_mem);
	    cuda_multiply<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div,1.e5,d_div);
	    cuda_multiply<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div_p3,1.e5,d_div_p3);

	    meteorology_cal_theta<<<grid,numthreads>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dp_mem,dt_mem,dt_mem);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_richardson_num_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dt_mem,dz_mem,d_vws_mem,d_ri_mem);
	    meteorology_cal_dti_kernel<<<grid,numthreads>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_ti_mem,d_div,d_div_p3,d_dti_mem);

	    cudaMemcpy(ti_mem,d_ti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	    cudaMemcpy(vws_mem,d_vws_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	    cudaMemcpy(dti_mem,d_dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);
	    cudaMemcpy(ri_mem,d_ri_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);

	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		for(k=0;k<z->get_nz();k++){
		  *(ti2->get_data(i_offset+i,j_offset+j,k)) = ti_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(vws->get_data(i_offset+i,j_offset+j,k)) = vws_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(dti->get_data(i_offset+i,j_offset+j,k)) = dti_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(inri->get_data(i_offset+i,j_offset+j,k)) = ri_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		}
	      }
	    }
	  }
	}

	if(work_space==NULL){
	  delete [] lat;
	  delete [] lon;
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    delete [] map_factor_x_mem;
	    delete [] map_factor_y_mem;
	  }
	  delete [] z_mem;
	  delete [] u_mem;
	  delete [] v_mem;
	  delete [] t_mem;
	  delete [] p_mem;
	  delete [] u_p3_mem;
	  delete [] v_p3_mem;
	  delete [] ti_mem;
	  delete [] dti_mem;
	  delete [] vws_mem;
	  delete [] ri_mem;
	}

	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaFree(d_map_factor_x_mem);
	  cudaFree(d_map_factor_y_mem);
	}

	if(div!=NULL){
	  delete [] div_mem;
	}

	cudaFree(dlat);
	cudaFree(dlon);
	cudaFree(dz_mem);
	cudaFree(du_mem);
	cudaFree(dv_mem);
	cudaFree(dt_mem);
	cudaFree(dp_mem);
	cudaFree(du_p3_mem);
	cudaFree(dv_p3_mem);
	cudaFree(d_div);
	cudaFree(d_div_p3);

	cudaFree(dudx);
	cudaFree(dudy);
	cudaFree(dvdx);
	cudaFree(dvdy);

	cudaFree(d_vws_mem);
	cudaFree(d_ti_mem);
	cudaFree(d_dti_mem);
	cudaFree(d_ri_mem);
      }
    }
    else{
      grid_data *work_mem;
      grid_data_allocation(z->get_grid_code(),work_mem);
//std::cout << "Work memory type created. " << z->get_grid_code() << endl;
      work_mem->create(z->get_nx(),z->get_ny(),z->get_nz(),7); //dudx, dudy, dvdx, dvdy, convergence, shear, deformation, vws
//std::cout << "Work memory created." << endl;
      grid_data_field* work[7];
      int i,j,k;
      for(i=0;i<7;i++){
	work[i] = new grid_data_field;
	work[i]->set(work_mem,i);
      }
      //std::cout << "Work pointer ok." << endl;

      work[0]->cal_x_derivatives(u);
      work[1]->cal_y_derivatives(u);
      work[2]->cal_x_derivatives(v);
      work[3]->cal_y_derivatives(v);
      
      if(map_factor_x != NULL){
	*(work[0]) *= *map_factor_x;
	*(work[2]) *= *map_factor_x;
      }
      
      if(map_factor_y != NULL){
	*(work[1]) *= *map_factor_y;
	*(work[3]) *= *map_factor_y;
      }
      
//std::cout << "Derivatives calculated." << endl;

      work[5]->copy(*(work[2]));
/*
    if(error){
      cout << "Error in grid_data_field copy" << endl;
    }
*/
      *(work[5])+=*(work[1]);
    
      work[4]->copy(*(work[0]));
      *(work[4])-=*(work[3]);

    //deformation
      for(i=0;i<work[6]->get_nx();i++){
	for(j=0;j<work[6]->get_ny();j++){
	  for(k=0;k<work[6]->get_nz();k++){
	    *(work[6]->get_data(i,j,k)) = pow((*(work[4]->get_data(i,j,k)))*(*(work[4]->get_data(i,j,k))) + (*(work[5]->get_data(i,j,k)))*(*(work[5]->get_data(i,j,k))),0.5);
	  }
	}
      }
//std::cout << "Deformation calculation done." << endl;

      //divergence
      work[4]->copy(*(work[0]));
      *(work[4])+=*(work[3]);

      *(work[6])-=*(work[4]);
//std::cout << "convergence calculation done." << endl;

      //vws
      for(i=0;i<ti2->get_nx();i++){
	for(j=0;j<ti2->get_ny();j++){
	  for(k=1;k<ti2->get_nz()-1;k++){
	    //*(vws->get_data(i,j,k)) = (pow((*(u->get_data(i,j,k+1)))*(*(u->get_data(i,j,k+1))) + (*(v->get_data(i,j,k+1)))*(*(v->get_data(i,j,k+1))),0.5) - pow((*(u->get_data(i,j,k-1)))*(*(u->get_data(i,j,k-1))) + (*(v->get_data(i,j,k-1)))*(*(v->get_data(i,j,k-1))),0.5))/(*(z->get_data(i,j,k+1)) - *(z->get_data(i,j,k-1)));
	    *(vws->get_data(i,j,k)) = fabs((pow((*(u->get_data(i,j,k+1)) - *(u->get_data(i,j,k-1)))*(*(u->get_data(i,j,k+1)) - *(u->get_data(i,j,k-1))) + (*(v->get_data(i,j,k+1)) - *(v->get_data(i,j,k-1)))*(*(v->get_data(i,j,k+1)) - *(v->get_data(i,j,k-1))),0.5))/(*(z->get_data(i,j,k+1)) - *(z->get_data(i,j,k-1))));
	  }
	  *(vws->get_data(i,j,0)) = *(vws->get_data(i,j,1));
	  *(vws->get_data(i,j,ti2->get_nz()-1)) = *(vws->get_data(i,j,ti2->get_nz()-2));
	}
      }
//std::cout << "vws calculation done." << endl;

      ti2->copy(*(work[6]));
      (*ti2)*=(*vws);
      (*ti2)*=1e7;
//    std::cout << "TI2 calculation done." << endl;

      work[0]->cal_x_derivatives(u_p3);
      work[3]->cal_y_derivatives(v_p3);
      if(map_factor_x != NULL){
	*(work[0]) *= *map_factor_x;
      }
      if(map_factor_y != NULL){
	*(work[3]) *= *map_factor_y;
      }

       work[5]->copy(*(work[0]));
      *(work[5])+=*(work[3]);

      *(work[5])-=*(work[4]);

      *(work[5])*=1e5;
      dti->copy(*ti2);
      *dti += *(work[5]);

      for(i=0;i<ti2->get_nx();i++){
	for(j=0;j<ti2->get_ny();j++){
	  for(k=0;k<ti2->get_nz();k++){
	    *(work[0]->get_data(i,j,k)) = meteorology_cal_theta(t->get_z(i,j,k),*(t->get_data(i,j,k)));
	  }
	}
      }

      for(i=0;i<ti2->get_nx();i++){
	for(j=0;j<ti2->get_ny();j++){
	  for(k=1;k<ti2->get_nz()-1;k++){
	    *(inri->get_data(i,j,k)) = meteorology_g0*(*(work[0]->get_data(i,j,k-1)) - *(work[0]->get_data(i,j,k+1)))/(*(work[0]->get_data(i,j,k)) * (*(z->get_data(i,j,k-1)) - *(z->get_data(i,j,k+1))) * *(vws->get_data(i,j,k)) * *(vws->get_data(i,j,k)));
	  }
	}
      }

      
      for(i=0;i<7;i++){
	delete work[i];
      }
      delete work_mem;
    }

    return _ERRORCODE_NOERROR;
  }
###CPP### ###CUDA### ###HOST### int meteorology_cal_gtg_suite(const grid_data_field* z,const grid_data_field* p,const grid_data_field* u,const grid_data_field* v,const grid_data_field* u_p3,const grid_data_field* v_p3,const grid_data_field *t,const grid_data_field *q,const grid_data_field* map_factor_x,const grid_data_field* map_factor_y,grid_data_field *ti2,grid_data_field *ti3,grid_data_field *ti4,grid_data_field *dti,grid_data_field *vws,grid_data_field *inri,grid_data_field *div,grid_data_field *tke,grid_data_field *tke_dtf,
 grid_data_field *tke_adj1,grid_data_field *tke_adj2,grid_data_field *tke_adj3,grid_data_field *tke_adj4,grid_data_field *tke_adj5,grid_data_field *tke_adj6,
 grid_data_field *colson_panofsky,grid_data_field *browns_index,grid_data_field *pv,grid_data_field *grad_pv,
							      //grid_data_field *clark_cat,
 grid_data_field *curvature,grid_data_field *grad_t,grid_data_field *wind_index,grid_data_field *dutton_index,grid_data_field *mos_cat,double *work_space,bool gpu_mode,bool to_smooth,int x_neightbour,int y_neightbour,double radius){// if map_factor are NULL, they will be set to 1. gpu_mode is forced to be false without CUDA. conv can be set to NULL (optional output)
    ###CPP### gpu_mode = false;
    if(grid_data_field_check_grid_inconsistence(z,u) ||
       grid_data_field_check_grid_inconsistence(z,v) ||
       grid_data_field_check_grid_inconsistence(z,u_p3) ||
       grid_data_field_check_grid_inconsistence(z,v_p3) ||
       grid_data_field_check_grid_inconsistence(z,p) ||
       grid_data_field_check_grid_inconsistence(z,t) ||
       grid_data_field_check_grid_inconsistence(z,q) ||
       grid_data_field_check_grid_inconsistence(z,ti2) ||
       grid_data_field_check_grid_inconsistence(z,ti3) ||
       grid_data_field_check_grid_inconsistence(z,ti4) ||
       grid_data_field_check_grid_inconsistence(z,vws) ||
       grid_data_field_check_grid_inconsistence(z,dti) ||
       grid_data_field_check_grid_inconsistence(z,inri) ||
       grid_data_field_check_grid_inconsistence(z,tke) ||
       grid_data_field_check_grid_inconsistence(z,tke_dtf) ||

       grid_data_field_check_grid_inconsistence(z,div) ||
       grid_data_field_check_grid_inconsistence(z,colson_panofsky) ||
       grid_data_field_check_grid_inconsistence(z,browns_index) ||
       grid_data_field_check_grid_inconsistence(z,pv) ||
       grid_data_field_check_grid_inconsistence(z,grad_pv) ||
       //grid_data_field_check_grid_inconsistence(z,clark_cat) ||
       grid_data_field_check_grid_inconsistence(z,curvature) ||
       grid_data_field_check_grid_inconsistence(z,grad_t) ||
       grid_data_field_check_grid_inconsistence(z,wind_index) ||
       grid_data_field_check_grid_inconsistence(z,dutton_index) ||
       grid_data_field_check_grid_inconsistence(z,mos_cat) ||
       (map_factor_x != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_x)) ||
       (map_factor_y != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_y))){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    if(
       (tke_adj1 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj1)) ||
       (tke_adj2 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj2)) ||
       (tke_adj3 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj3)) ||
       (tke_adj4 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj4)) ||
       (tke_adj5 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj5)) ||
       (tke_adj6 != NULL && grid_data_field_check_grid_inconsistence(z,tke_adj6))
       ){
      return _ERRORCODE_DATAINCONSISTENCE;
    }      


    if(gpu_mode){
      //this part of code only generates if GPU mode is enabled
      ###CUDA###{
	size_t free, total;
	cudaMemGetInfo(&free,&total);
	
	int nbatchx, nbatchy;
	int error = determine_nbatchxy(nbatchx,nbatchy,z->get_nx(),z->get_ny(),0,0,(8.*z->get_nx()*z->get_ny()*z->get_nz()*48 + 8.*z->get_nx()*z->get_ny()*5)*1.2); // memory ~ (nx) * ny *nz * 8 (num bytes of double) * (48 variables) + (nx) * ny * 8 * 5 (map factor + lat-long + coriolis_fre) + 20% contingency

	if(error){
	  return error;
	}

	const int num_cudaStream = 4;
	cudaStream_t *stream = new cudaStream_t [num_cudaStream];
	int i,j,k;
	for(i=0;i<num_cudaStream;i++){
	  cudaStreamCreate(stream+i);
	}

	double *z_mem, *u_mem, *v_mem, *t_mem, *q_mem,*p_mem;
	double *div_mem;
	double *u_p3_mem, *v_p3_mem;
	double *dz_mem, *du_mem, *dv_mem, *dt_mem, *dq_mem,*d_theta_mem,*d_thetav_mem,*dp_mem;
	double *ti2_mem, *ti3_mem, *ti4_mem, *dti_mem, *vws_mem, *ri_mem, *tke_mem, *tke_dtf_mem, *colson_panofsky_mem, *browns_index_mem, *pv_mem, *grapv_mem, *clark_cat_mem, *curvature_mem, *grad_t_mem, *wind_index_mem, *dutton_index_mem, *mos_cat_mem;
	double *tke_adj1_mem,*tke_adj2_mem,*tke_adj3_mem,*tke_adj4_mem,*tke_adj5_mem,*tke_adj6_mem;
	double *d_ti2_mem, *d_ti3_mem, *d_ti4_mem, *d_dti_mem, *d_vws_mem, *d_ri_mem, *d_tke_mem, *d_tke_dtf_mem, *d_colson_panofsky_mem, *d_browns_index_mem, *d_pv_mem, *d_grad_pv_mem, *d_clark_cat_mem, *d_curvature_mem, *d_grad_t_mem, *d_wind_index_mem, *d_dutton_index_mem, *d_mos_cat_mem;
	double *d_tke_adj1_mem,*d_tke_adj2_mem,*d_tke_adj3_mem,*d_tke_adj4_mem,*d_tke_adj5_mem,*d_tke_adj6_mem;
	double *du_p3_mem, *dv_p3_mem;
	double *d_div, *d_div_p3;
	double *d_coriolis_fre_mem;
	double *dpvdx, *dpvdy, *dtdx, *dtdy;
	double *d_winds, *d_vorticity_curvarture, *d_vorticity_shear;
	double *dudx,*dudy,*dvdx,*dvdy,*dVdx,*dVdy;
	double *dudx_p3,*dudy_p3,*dvdx_p3,*dvdy_p3;
	double *map_factor_x_mem, *map_factor_y_mem;
	double *d_map_factor_x_mem = NULL;
	double *d_map_factor_y_mem = NULL;
	double *lat, *lon;
	double *dlat, *dlon;
	double **smooth = new double* [num_cudaStream];
	int batchx_index,batchy_index;
	int batchx_size,batchy_size;
	batchx_size = z->get_nx()/nbatchx;
	batchy_size = z->get_ny()/nbatchy;

	if(work_space == NULL){
	  lon = new double [(batchx_size+2)*(batchy_size+2)];
	  lat = new double [(batchx_size+2)*(batchy_size+2)];
	  z_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  t_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  q_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  p_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  
	  ti2_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ti3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ti4_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  dti_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  vws_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ri_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  tke_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  tke_dtf_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  colson_panofsky_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  browns_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  pv_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  grapv_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  clark_cat_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  curvature_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  grad_t_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  wind_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  dutton_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  mos_cat_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem = new double [(batchx_size+2)*(batchy_size+2)];
	    map_factor_y_mem = new double [(batchx_size+2)*(batchy_size+2)];
	  }

	  if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3!= NULL && tke_adj4!= NULL && tke_adj5!= NULL && tke_adj6!= NULL){
	    tke_adj1_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    tke_adj2_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    tke_adj3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    tke_adj4_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    tke_adj5_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	    tke_adj6_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  }
	  div_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	}
	else{
	  int count = 0;
	  lon = work_space;
	  count += (batchx_size+2)*(batchy_size+2);
	  lat  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2);
	  z_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  u_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  v_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  t_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  q_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  p_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  u_p3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  v_p3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  
	  ti2_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ti3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ti4_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  dti_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  vws_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ri_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  tke_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  tke_dtf_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  colson_panofsky_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  browns_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  pv_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  grapv_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  clark_cat_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  curvature_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  grad_t_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  wind_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  dutton_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  mos_cat_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem  = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2);
	    map_factor_y_mem  = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2);
	  }
	  div_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();

	  if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3!= NULL && tke_adj4!= NULL && tke_adj5!= NULL && tke_adj6!= NULL){
	    tke_adj1_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	    tke_adj2_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	    tke_adj3_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	    tke_adj4_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	    tke_adj5_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	    tke_adj6_mem = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  }	  
	}
	
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@before cudaMalloc@meteorology_cal_gtg_suite" <<endl;
	cudaMalloc(&dlat,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dlon,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&d_coriolis_fre_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dz_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dt_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dq_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_theta_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_thetav_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dp_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dVdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dVdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	cudaMalloc(&d_winds,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vorticity_curvarture,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vorticity_shear,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vws_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	cudaMalloc(&d_ti2_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ti3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ti4_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ri_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_tke_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_tke_dtf_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_colson_panofsky_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_browns_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_pv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dpvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dpvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dtdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dtdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_grad_pv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_clark_cat_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_curvature_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_grad_t_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_wind_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_dutton_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_mos_cat_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	for(i=0;i<num_cudaStream;i++){
	  cudaMalloc(&smooth[i],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	}

	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaMalloc(&d_map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	  cudaMalloc(&d_map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	}
	else{
	  d_map_factor_x_mem = NULL;
	  d_map_factor_y_mem = NULL;
	}

	if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3!= NULL && tke_adj4!= NULL && tke_adj5!= NULL && tke_adj6!= NULL){
	  cudaMalloc(&d_tke_adj1_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&d_tke_adj2_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&d_tke_adj3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&d_tke_adj4_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&d_tke_adj5_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&d_tke_adj6_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	}
	else{
	  d_tke_adj1_mem = NULL;
	  d_tke_adj2_mem = NULL;
	  d_tke_adj3_mem = NULL;
	  d_tke_adj4_mem = NULL;
	  d_tke_adj5_mem = NULL;
	  d_tke_adj6_mem = NULL;
	}
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMalloc@meteorology_cal_gtg_suite" <<endl;

	int numthreads = cuda_setting::get_numthreads();
	dim3 grid;
	dim3 grid_copy;

	int i_offset, j_offset;
	int index_2d, index_3d;

	for(batchy_index=0;batchy_index<nbatchy;batchy_index++){
	  j_offset = batchy_index*batchy_size;
	  for(batchx_index=0;batchx_index<nbatchx;batchx_index++){
	    i_offset = batchx_index*batchx_size;
	    for(i=0;i<batchx_size;i++){
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *(map_factor_x->get_data(i_offset+i,j_offset+j,0));
		  map_factor_y_mem[index_2d] = *(map_factor_y->get_data(i_offset+i,j_offset+j,0));
		}
	      }
	    }

	    if(batchx_index==0){
	      i=-1;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0) - z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(u->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(v->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(t->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(p->get_nx()-1,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(p->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(u_p3->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(v_p3->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(map_factor_x->get_nx()-1,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(map_factor_y->get_nx()-1,j_offset+j,0));
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(0,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(0,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(0,j_offset+j,0));
		  }
		}
	      }
	    }
	    else{
	      i=-1;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchx_index==nbatchx-1){
	      i=batchx_size;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0) + z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(0,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(0,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(0,j_offset+j,0);
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(z->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(z->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(z->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(z->get_nx()-1,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(z->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(z->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(z->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(z->get_nx()-1,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(z->get_nx()-1,j_offset+j,0);
		  }
		}
	      }
	    }
	    else{
	      i=batchx_size;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y((batchx_index+1)*batchx_size,j_offset+j,0);
		lon[index_2d] = z->get_x((batchx_index+1)*batchx_size,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		}
	      }
	    }

	    if(batchy_index==0){
	      j=-1;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0) - z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,z->get_ny()-1,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0);
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,0,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	    }
	    else{
	      j=-1;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchy_index==nbatchy-1){
	      j=batchy_size;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0) + z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,0,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0);
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,z->get_ny()-1,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	    }
	    else{
	      j=batchy_size;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,(batchy_index+1)*batchy_size,0);
		lon[index_2d] = z->get_x(i_offset+i,(batchy_index+1)*batchy_size,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		}
	      }
	    }

	    cudaMemcpyAsync(dlat,lat,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dlat@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dlon,lon,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dlon@meteorology_cal_gtg_suite" <<endl;
	    if(map_factor_x != NULL && map_factor_y != NULL){
	      cudaMemcpyAsync(d_map_factor_x_mem,map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for map_factor_x_mem@meteorology_cal_gtg_suite" <<endl;
	      cudaMemcpyAsync(d_map_factor_y_mem,map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for map_factor_y_mem@meteorology_cal_gtg_suite" <<endl;
	    }
	    cudaMemcpyAsync(dz_mem,z_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[3]);
	    cudaMemcpyAsync(du_mem,u_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    cudaMemcpyAsync(dv_mem,v_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    cudaMemcpyAsync(dt_mem,t_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dt_mem@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dp_mem,p_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dp_mem@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dq_mem,q_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    cudaMemcpyAsync(du_p3_mem,u_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[2]);
	    cudaMemcpyAsync(dv_p3_mem,v_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[2]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    grid_copy.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    meteorology_cal_theta<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dp_mem,dt_mem,d_theta_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_theta@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_thetav<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_theta_mem,dq_mem,d_thetav_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_thetav@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_mem,d_map_factor_x_mem,dudx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dv_mem,d_map_factor_x_mem,dvdx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cudaStreamSynchronize(stream[1]);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,du_mem,d_map_factor_y_mem,dudy);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_mem,d_map_factor_y_mem,dvdy);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);

	    cuda_add<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx,dvdy,d_div);
	    meteorology_uv_to_speed_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),du_mem,dv_mem,d_winds);
	    earth_cal_coriolis_fre<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2),dlat,d_coriolis_fre_mem);
	    
	    cudaStreamSynchronize(stream[0]);
	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,d_winds,d_map_factor_x_mem,dVdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,d_winds,d_map_factor_y_mem,dVdy);

	    meteorology_cal_vws_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,d_vws_mem);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_vws_kernel@meteorology_cal_gtg_suite" <<endl;
	    cudaStreamSynchronize(stream[0]);
	    cudaStreamSynchronize(stream[1]);
	    cudaStreamSynchronize(stream[3]);

	    meteorology_cal_ti2_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_vws_mem,d_ti2_mem);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_ti2_kernel@meteorology_cal_gtg_suite" <<endl;
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_multiply<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti2_mem,1.e7,d_ti2_mem);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_ti3_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_thetav_mem,d_vws_mem,d_ti2_mem,d_ti3_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_ti3_kernel@meteorology_cal_gtg_suite" <<endl;
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti2_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_ti2_mem);
	    }
	    cudaMemcpyAsync(ti2_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti3_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_ti3_mem);
	    }
	    cudaMemcpyAsync(ti3_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);

	    meteorology_cal_vorticity<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,du_mem,dv_mem,dudy,dvdx,d_winds,dVdx,dVdy,d_vorticity_curvarture,d_vorticity_shear);
	    meteorology_cal_ti4_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_coriolis_fre_mem,d_vorticity_curvarture,d_vorticity_shear,dz_mem,d_thetav_mem,d_vws_mem,d_ti4_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti4_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_ti4_mem);
	    }
	    cudaMemcpyAsync(ti4_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_add<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_vorticity_curvarture,d_vorticity_shear,d_curvature_mem);
	    cuda_square<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_curvature_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_curvature_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_curvature_mem);
	    }
	    cudaMemcpyAsync(curvature_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_p3_mem,d_map_factor_x_mem,dudx_p3);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_p3_mem,d_map_factor_y_mem,dvdy_p3);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_add<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx_p3,dvdy_p3,d_div_p3);
	    cuda_multiply<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div,1.e5,d_div);
	    cuda_multiply<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div_p3,1.e5,d_div_p3);
	    cudaStreamSynchronize(stream[0]);
	    cudaStreamSynchronize(stream[2]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_dti_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_ti2_mem,d_div,d_div_p3,d_dti_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_dti_kernel@meteorology_cal_gtg_suite" <<endl;
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_div,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_div);
	    }
	    cudaMemcpyAsync(div_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_dti_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_dti_mem);
	    }
	    cudaMemcpyAsync(dti_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    meteorology_cal_richardson_num_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_theta_mem,dz_mem,d_vws_mem,d_ri_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_richardson_num_kernel@meteorology_cal_gtg_suite" <<endl;

	    meteorology_cal_colson_panofsky_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_ri_mem,d_vws_mem,d_colson_panofsky_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_colson_panofsky_kernel@meteorology_cal_gtg_suite" <<endl;

	    if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3 != NULL && tke_adj4 != NULL && tke_adj5 != NULL && tke_adj6 != NULL){
	      meteorology_cal_tke_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_ri_mem,d_vws_mem,d_tke_mem,d_tke_dtf_mem,d_tke_adj1_mem,d_tke_adj2_mem,d_tke_adj3_mem,d_tke_adj4_mem,d_tke_adj5_mem,d_tke_adj6_mem);
	    }
	    else{
	      meteorology_cal_tke_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_ri_mem,d_vws_mem,d_tke_mem,d_tke_dtf_mem);
	    }
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_tke_kernel@meteorology_cal_gtg_suite" <<endl;

	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ri_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_ri_mem);
	    }
	    cudaMemcpyAsync(ri_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_colson_panofsky_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_colson_panofsky_mem);
	    }
	    cudaMemcpyAsync(colson_panofsky_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_mem);
	    }
	    cudaMemcpyAsync(tke_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_dtf_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_dtf_mem);
	    }
	    cudaMemcpyAsync(tke_dtf_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3 != NULL && tke_adj4 != NULL && tke_adj5 != NULL && tke_adj6 != NULL){
	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj1_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj1_mem);
	      }
	      cudaMemcpyAsync(tke_adj1_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	      
	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj2_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj2_mem);
	      }
	      cudaMemcpyAsync(tke_adj2_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj3_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj3_mem);
	      }
	      cudaMemcpyAsync(tke_adj3_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj4_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj4_mem);
	      }
	      cudaMemcpyAsync(tke_adj4_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj5_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj5_mem);
	      }
	      cudaMemcpyAsync(tke_adj5_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	      if(to_smooth){
		gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_adj6_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	      }
	      else{
		cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_adj6_mem);
	      }
	      cudaMemcpyAsync(tke_adj6_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    }

	    meteorology_cal_browns_index_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_coriolis_fre_mem,d_vws_mem,d_browns_index_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_browns_index_kernel@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_pv_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dvdx,dudy,dp_mem,d_coriolis_fre_mem,d_theta_mem,d_pv_mem);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,d_pv_mem,d_map_factor_x_mem,dpvdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,d_pv_mem,d_map_factor_y_mem,dpvdy);
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_square<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdx);
	    cuda_square<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdy);
	    cuda_add<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdx,dpvdy,d_grad_pv_mem);
	    cuda_sqrt<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_pv_mem);
	    
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_pv_kernel@meteorology_cal_gtg_suite" <<endl;

	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_browns_index_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_browns_index_mem);
	    }
	    cudaMemcpyAsync(browns_index_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_pv_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_pv_mem);
	    }
	    cudaMemcpyAsync(pv_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_grad_pv_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_grad_pv_mem);
	    }
	    cudaMemcpyAsync(grapv_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dt_mem,d_map_factor_x_mem,dtdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dt_mem,d_map_factor_y_mem,dtdy);
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_square<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdx);
	    cuda_square<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdy);
	    cuda_add<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdx,dtdy,d_grad_t_mem);
	    cuda_sqrt<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_t_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_grad_t_mem,x_neightbour,y_neightbour,radius,smooth[3]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[3],d_grad_t_mem);
	    }
	    cudaMemcpyAsync(grad_t_mem,smooth[3],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[3]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_mos_cat_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_winds,d_mos_cat_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_mos_cat_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_mos_cat_mem);
	    }
	    cudaMemcpyAsync(mos_cat_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    meteorology_cal_dutton_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dVdx,dVdy,du_mem,dv_mem,d_winds,d_vws_mem,d_dutton_index_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_vws_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_vws_mem);
	    }
	    cudaMemcpyAsync(vws_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_dutton_index_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_dutton_index_mem);
	    }
	    cudaMemcpyAsync(dutton_index_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    meteorology_cal_wind_index_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,d_winds,d_wind_index_mem);
	    if(to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_wind_index_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_wind_index_mem);
	    }
	    cudaMemcpyAsync(wind_index_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);

	    cudaDeviceSynchronize();
	    
	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		for(k=0;k<z->get_nz();k++){
		  *(div->get_data(i_offset+i,j_offset+j,k)) = div_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti2->get_data(i_offset+i,j_offset+j,k)) = ti2_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti3->get_data(i_offset+i,j_offset+j,k)) = ti3_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti4->get_data(i_offset+i,j_offset+j,k)) = ti4_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(vws->get_data(i_offset+i,j_offset+j,k)) = vws_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(dti->get_data(i_offset+i,j_offset+j,k)) = dti_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(inri->get_data(i_offset+i,j_offset+j,k)) = ri_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(colson_panofsky->get_data(i_offset+i,j_offset+j,k)) = colson_panofsky_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(browns_index->get_data(i_offset+i,j_offset+j,k)) = browns_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(tke->get_data(i_offset+i,j_offset+j,k)) = tke_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(tke_dtf->get_data(i_offset+i,j_offset+j,k)) = tke_dtf_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(pv->get_data(i_offset+i,j_offset+j,k)) = pv_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(grad_pv->get_data(i_offset+i,j_offset+j,k)) = grapv_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(curvature->get_data(i_offset+i,j_offset+j,k)) = curvature_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(grad_t->get_data(i_offset+i,j_offset+j,k)) = grad_t_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(wind_index->get_data(i_offset+i,j_offset+j,k)) = wind_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(dutton_index->get_data(i_offset+i,j_offset+j,k)) = dutton_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(mos_cat->get_data(i_offset+i,j_offset+j,k)) = mos_cat_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		}
	      }
	    }

	    if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3 != NULL && tke_adj4 != NULL && tke_adj5 != NULL && tke_adj6 != NULL){
	      for(j=0;j<batchy_size;j++){
		for(i=0;i<batchx_size;i++){
		  for(k=0;k<z->get_nz();k++){
		    *(tke_adj1->get_data(i_offset+i,j_offset+j,k)) = tke_adj1_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		    *(tke_adj2->get_data(i_offset+i,j_offset+j,k)) = tke_adj2_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		    *(tke_adj3->get_data(i_offset+i,j_offset+j,k)) = tke_adj3_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		    *(tke_adj4->get_data(i_offset+i,j_offset+j,k)) = tke_adj4_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		    *(tke_adj5->get_data(i_offset+i,j_offset+j,k)) = tke_adj5_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		    *(tke_adj6->get_data(i_offset+i,j_offset+j,k)) = tke_adj6_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  }
		}
	      }
	    }

	  } 
	}
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_end_of_batchxy_loop@meteorology_cal_gtg_suite" <<endl;
	
	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaFree(d_map_factor_x_mem);
	  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_map_factor_x_mem@meteorology_cal_gtg_suite" <<endl;
	  cudaFree(d_map_factor_y_mem);
          if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_map_factor_y_mem@meteorology_cal_gtg_suite" <<endl;
	}
	if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3 != NULL && tke_adj4 != NULL && tke_adj5 != NULL && tke_adj6 != NULL){
	  cudaFree(d_tke_adj1_mem);
	  cudaFree(d_tke_adj2_mem);
	  cudaFree(d_tke_adj3_mem);
	  cudaFree(d_tke_adj4_mem);
	  cudaFree(d_tke_adj5_mem);
	  cudaFree(d_tke_adj6_mem);
	}
	for(i=0;i<num_cudaStream;i++){
	  cudaFree(smooth[i]);
	}
	delete [] smooth;

	if(work_space == NULL){
	  delete [] lat;
	  delete [] lon;
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    delete [] map_factor_x_mem;
	    delete [] map_factor_y_mem;
	  }
	  if(tke_adj1 != NULL && tke_adj2 != NULL && tke_adj3 != NULL && tke_adj4 != NULL && tke_adj5 != NULL && tke_adj6 != NULL){
	    delete [] tke_adj1_mem;
	    delete [] tke_adj2_mem;
	    delete [] tke_adj3_mem;
	    delete [] tke_adj4_mem;
	    delete [] tke_adj5_mem;
	    delete [] tke_adj6_mem;
	  }
	  delete [] z_mem;
	  delete [] u_mem;
	  delete [] v_mem;
	  delete [] t_mem;
	  delete [] q_mem;
	  delete [] p_mem;
	  delete [] u_p3_mem;
	  delete [] v_p3_mem;
	  delete [] ti2_mem;
	  delete [] ti3_mem;
	  delete [] ti4_mem;
	  delete [] dti_mem;
	  delete [] vws_mem;
	  delete [] ri_mem;
	  delete [] tke_mem;
	  delete [] tke_dtf_mem;
	  delete [] colson_panofsky_mem;
	  delete [] browns_index_mem;
	  delete [] pv_mem;
	  delete [] grapv_mem;
	  delete [] clark_cat_mem;
	  delete [] curvature_mem;
	  delete [] grad_t_mem;
	  delete [] wind_index_mem;
	  delete [] dutton_index_mem;
	  delete [] mos_cat_mem;
	  delete [] div_mem;
	}

	cudaFree(dlat);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dlat@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dlon);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dlon@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dz_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dz_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(du_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_du__mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dv_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dv_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dt_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dt_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_theta_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dtheta_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_thetav_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dthetav_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dp_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dp_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dq_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dq_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(du_p3_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_du_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dv_p3_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dv_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_div);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_ddiv_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_div_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_div_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudx);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudy);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdx);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdy);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudx_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudy_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdx_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdy_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_coriolis_fre_mem);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_coriolis_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dVdx);
	cudaFree(dVdy);
	cudaFree(dpvdx);
	cudaFree(dpvdy);
	cudaFree(dtdx);
	cudaFree(dtdy);

	cudaFree(d_ti2_mem);
	cudaFree(d_ti3_mem);
	cudaFree(d_ti4_mem);
	cudaFree(d_dti_mem);
	cudaFree(d_vws_mem);
	cudaFree(d_ri_mem);
	cudaFree(d_tke_mem);
	cudaFree(d_tke_dtf_mem);
	cudaFree(d_colson_panofsky_mem);
	cudaFree(d_browns_index_mem);
	cudaFree(d_pv_mem);
	cudaFree(d_grad_pv_mem);
	cudaFree(d_clark_cat_mem);
	cudaFree(d_curvature_mem);
	cudaFree(d_grad_t_mem);
	cudaFree(d_wind_index_mem);
	cudaFree(d_dutton_index_mem);
	cudaFree(d_mos_cat_mem);

	cudaFree(d_winds);
	cudaFree(d_vorticity_curvarture);
	cudaFree(d_vorticity_shear);

	for(i=0;i<num_cudaStream;i++){
	  cudaStreamDestroy(stream[i]);
	}
	delete [] stream;

	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_end_function@meteorology_cal_gtg_suite : "  <<endl;
      }
    }
    else{
      
    }
    return _ERRORCODE_NOERROR;
  }

  ###CUDA### ###GLOBAL### void meteorology_cal_edr_mapping_kernel(int nstate,double *index,int nmap,double *threshold,double *scale,double *out){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      if(index[i] >= threshold[nmap-1]){
	out[i] = scale[nmap-1];
      }
      else if(index[i] <= threshold[0]){
	out[i] = scale[0];
      }
      else{
	int j;
	for(j=nmap-2;j>=0;j--){
	  if(index[i] >= threshold[j]){
	     break;
	  }
	}
	out[i] = (index[i] - threshold[j])/(threshold[j+1] - threshold[j])*(scale[j+1] - scale[j]) + scale[j];
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_cal_edr_add_index(int nstate,double *index,double weighting,double *edr){
    int i = blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      edr[i] += weighting*index[i];
    }
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_cal_gtg_suite(const grid_data_field* z,const grid_data_field* p,const grid_data_field* u,const grid_data_field* v,const grid_data_field* u_p3,const grid_data_field* v_p3,const grid_data_field *t,const grid_data_field *q,const grid_data_field* map_factor_x,const grid_data_field* map_factor_y,grid_data_field *ti2,grid_data_field *ti3,grid_data_field *ti4,grid_data_field *dti,grid_data_field *vws,grid_data_field *inri,grid_data_field *div,grid_data_field *tke,grid_data_field *tke_dtf,
    grid_data_field *colson_panofsky,grid_data_field *browns_index,grid_data_field *pv,grid_data_field *grad_pv,
  //grid_data_field *clark_cat,
    grid_data_field *curvature,grid_data_field *grad_t,grid_data_field *wind_index,grid_data_field *dutton_index,grid_data_field *mos_cat,bool *use_in_edr,int nmap,double *threshold,double *scale,double *weighting,grid_data_field *edr,double *work_space,bool gpu_mode,bool index_to_smooth,bool edr_to_smooth,int x_neightbour,int y_neightbour,double radius){// if map_factor are NULL, they will be set to 1. gpu_mode is forced to be false without CUDA. work_space is for pinned memory workspace, only meaningful for speed up GPU transfer, set to NULL to disable.
    const int num_index = 18;

    ###CPP### gpu_mode = false;
    if(grid_data_field_check_grid_inconsistence(z,u) ||
       grid_data_field_check_grid_inconsistence(z,v) ||
       grid_data_field_check_grid_inconsistence(z,u_p3) ||
       grid_data_field_check_grid_inconsistence(z,v_p3) ||
       grid_data_field_check_grid_inconsistence(z,p) ||
       grid_data_field_check_grid_inconsistence(z,t) ||
       grid_data_field_check_grid_inconsistence(z,q) ||
       grid_data_field_check_grid_inconsistence(z,ti2) ||
       grid_data_field_check_grid_inconsistence(z,ti3) ||
       grid_data_field_check_grid_inconsistence(z,ti4) ||
       grid_data_field_check_grid_inconsistence(z,vws) ||
       grid_data_field_check_grid_inconsistence(z,dti) ||
       grid_data_field_check_grid_inconsistence(z,inri) ||
       grid_data_field_check_grid_inconsistence(z,tke) ||
       grid_data_field_check_grid_inconsistence(z,tke_dtf) ||
       grid_data_field_check_grid_inconsistence(z,div) ||
       grid_data_field_check_grid_inconsistence(z,colson_panofsky) ||
       grid_data_field_check_grid_inconsistence(z,browns_index) ||
       grid_data_field_check_grid_inconsistence(z,pv) ||
       grid_data_field_check_grid_inconsistence(z,grad_pv) ||
       //grid_data_field_check_grid_inconsistence(z,clark_cat) ||
       grid_data_field_check_grid_inconsistence(z,curvature) ||
       grid_data_field_check_grid_inconsistence(z,grad_t) ||
       grid_data_field_check_grid_inconsistence(z,wind_index) ||
       grid_data_field_check_grid_inconsistence(z,dutton_index) ||
       grid_data_field_check_grid_inconsistence(z,mos_cat) ||
       grid_data_field_check_grid_inconsistence(z,edr) ||
       (map_factor_x != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_x)) ||
       (map_factor_y != NULL && grid_data_field_check_grid_inconsistence(z,map_factor_y))){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    if(gpu_mode){
      //this part of code only generates if GPU mode is enabled
      ###CUDA###{
	size_t free, total;
	cudaMemGetInfo(&free,&total);
	
	int nbatchx, nbatchy;
	int error = determine_nbatchxy(nbatchx,nbatchy,z->get_nx(),z->get_ny(),0,0,(8.*z->get_nx()*z->get_ny()*z->get_nz()*48 + 8.*z->get_nx()*z->get_ny()*5)*1.2); // memory ~ (nx) * ny *nz * 8 (num bytes of double) * (48 variables) + (nx) * ny * 8 * 5 (map factor + lat-long + coriolis_fre) + 20% contingency

	if(error){
	  return error;
	}

	const int num_cudaStream = 4;
	cudaStream_t *stream = new cudaStream_t [num_cudaStream];
	int i,j,k;
	for(i=0;i<num_cudaStream;i++){
	  cudaStreamCreate(stream+i);
	}

	double *z_mem, *u_mem, *v_mem, *t_mem, *q_mem,*p_mem;
	double *div_mem;
	double *u_p3_mem, *v_p3_mem;
	double *dz_mem, *du_mem, *dv_mem, *dt_mem, *dq_mem,*d_theta_mem,*d_thetav_mem,*dp_mem;
	double *ti2_mem, *ti3_mem, *ti4_mem, *dti_mem, *vws_mem, *ri_mem, *tke_mem, *tke_dtf_mem, *colson_panofsky_mem, *browns_index_mem, *pv_mem, *grapv_mem, *clark_cat_mem, *curvature_mem, *grad_t_mem, *wind_index_mem, *dutton_index_mem, *mos_cat_mem;
	double *edr_mem;
	double *d_ti2_mem, *d_ti3_mem, *d_ti4_mem, *d_dti_mem, *d_vws_mem, *d_ri_mem, *d_tke_mem, *d_tke_dtf_mem, *d_colson_panofsky_mem, *d_browns_index_mem, *d_pv_mem, *d_grad_pv_mem, *d_clark_cat_mem, *d_curvature_mem, *d_grad_t_mem, *d_wind_index_mem, *d_dutton_index_mem, *d_mos_cat_mem;
	double *d_tke_adj1_mem,*d_tke_adj2_mem,*d_tke_adj3_mem,*d_tke_adj4_mem,*d_tke_adj5_mem,*d_tke_adj6_mem;
	double *du_p3_mem, *dv_p3_mem;
	double *d_div, *d_div_p3;
	double *d_coriolis_fre_mem;
	double *dpvdx, *dpvdy, *dtdx, *dtdy;
	double *d_winds, *d_vorticity_curvarture, *d_vorticity_shear;
	double *dudx,*dudy,*dvdx,*dvdy,*dVdx,*dVdy;
	double *dudx_p3,*dudy_p3,*dvdx_p3,*dvdy_p3;
	double *map_factor_x_mem, *map_factor_y_mem;
	double *d_map_factor_x_mem = NULL;
	double *d_map_factor_y_mem = NULL;
	double *lat, *lon;
	double *dlat, *dlon;
	double **smooth = new double* [num_cudaStream];
	double **mapping_space = new double* [num_cudaStream];

	double *d_threshold, *d_scale;
	double *d_edr_mem;

	int batchx_index,batchy_index;
	int batchx_size,batchy_size;
	batchx_size = z->get_nx()/nbatchx;
	batchy_size = z->get_ny()/nbatchy;

	if(work_space == NULL){
	  lon = new double [(batchx_size+2)*(batchy_size+2)];
	  lat = new double [(batchx_size+2)*(batchy_size+2)];
	  z_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  t_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  q_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  p_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  u_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  v_p3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  
	  ti2_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ti3_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ti4_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  dti_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  vws_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  ri_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  tke_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  tke_dtf_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  colson_panofsky_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  browns_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  pv_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  grapv_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  clark_cat_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  curvature_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  grad_t_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  wind_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  dutton_index_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  mos_cat_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	  edr_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];

	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem = new double [(batchx_size+2)*(batchy_size+2)];
	    map_factor_y_mem = new double [(batchx_size+2)*(batchy_size+2)];
	  }

	  div_mem = new double [(batchx_size+2)*(batchy_size+2)*z->get_nz()];
	}
	else{
	  int count = 0;
	  lon = work_space;
	  count += (batchx_size+2)*(batchy_size+2);
	  lat  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2);
	  z_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  u_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  v_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  t_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  q_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  p_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  u_p3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  v_p3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  
	  ti2_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ti3_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ti4_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  dti_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  vws_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  ri_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  tke_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  tke_dtf_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  colson_panofsky_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  browns_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  pv_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  grapv_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  clark_cat_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  curvature_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  grad_t_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  wind_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  dutton_index_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  mos_cat_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    map_factor_x_mem  = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2);
	    map_factor_y_mem  = work_space + count;
	    count += (batchx_size+2)*(batchy_size+2);
	  }
	  div_mem  = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();

	  edr_mem = work_space + count;
	  count += (batchx_size+2)*(batchy_size+2)*z->get_nz();
	}

	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@before cudaMalloc@meteorology_cal_gtg_suite" <<endl;
	cudaMalloc(&dlat,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dlon,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&d_coriolis_fre_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	cudaMalloc(&dz_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dt_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dq_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_theta_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_thetav_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dp_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&du_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dv_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dVdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dVdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudx_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dudy_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdx_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dvdy_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_div_p3,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	cudaMalloc(&d_winds,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vorticity_curvarture,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vorticity_shear,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_vws_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	cudaMalloc(&d_ti2_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ti3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ti4_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_dti_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_ri_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_tke_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_tke_dtf_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_colson_panofsky_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_browns_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_pv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dpvdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dpvdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dtdx,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&dtdy,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_grad_pv_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_clark_cat_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_curvature_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_grad_t_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_wind_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_dutton_index_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_mos_cat_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));

	for(i=0;i<num_cudaStream;i++){
	  cudaMalloc(&smooth[i],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	  cudaMalloc(&mapping_space[i],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	}

	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaMalloc(&d_map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	  cudaMalloc(&d_map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double));
	}
	else{
	  d_map_factor_x_mem = NULL;
	  d_map_factor_y_mem = NULL;
	}

	cudaMalloc(&d_edr_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double));
	cudaMalloc(&d_threshold,nmap*num_index*sizeof(double));
	cudaMalloc(&d_scale,nmap*sizeof(double));
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMalloc@meteorology_cal_gtg_suite" <<endl;

	cudaMemcpyAsync(d_threshold,threshold,nmap*num_index*sizeof(double),cudaMemcpyHostToDevice,stream[3]);
	cudaMemcpyAsync(d_scale,scale,nmap*sizeof(double),cudaMemcpyHostToDevice,stream[3]);

	int numthreads = cuda_setting::get_numthreads();
	dim3 grid;
	dim3 grid_copy;

	int i_offset, j_offset;
	int index_2d, index_3d;

	cudaMemcpyAsync(dz_mem,z_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[3]);

	for(batchy_index=0;batchy_index<nbatchy;batchy_index++){
	  j_offset = batchy_index*batchy_size;
	  for(batchx_index=0;batchx_index<nbatchx;batchx_index++){
	    i_offset = batchx_index*batchx_size;
	    for(i=0;i<batchx_size;i++){
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *(map_factor_x->get_data(i_offset+i,j_offset+j,0));
		  map_factor_y_mem[index_2d] = *(map_factor_y->get_data(i_offset+i,j_offset+j,0));
		}
	      }
	    }

	    if(batchx_index==0){
	      i=-1;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0) - z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(u->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(v->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(t->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(p->get_nx()-1,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(p->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(u_p3->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(v_p3->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(map_factor_x->get_nx()-1,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(map_factor_y->get_nx()-1,j_offset+j,0));
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(0,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *(map_factor_x->get_data(0,j_offset+j,0));
		    map_factor_y_mem[index_2d] = *(map_factor_y->get_data(0,j_offset+j,0));
		  }
		}
	      }
	    }
	    else{
	      i=-1;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchx_index==nbatchx-1){
	      i=batchx_size;
	      if(z->is_x_periodic()){
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(0,j_offset+j,0);
		  lon[index_2d] = z->get_x(0,j_offset+j,0) + z->get_x_period();
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(0,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(0,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(0,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(0,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(0,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(0,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(0,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(0,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(0,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(0,j_offset+j,0);
		  }
		}
	      }
	      else{
		for(j=0;j<batchy_size;j++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(z->get_nx()-1,j_offset+j,0);
		  lon[index_2d] = z->get_x(z->get_nx()-1,j_offset+j,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(z->get_nx()-1,j_offset+j,k));
		    u_mem[index_3d] = *(u->get_data(z->get_nx()-1,j_offset+j,k));
		    v_mem[index_3d] = *(v->get_data(z->get_nx()-1,j_offset+j,k));
		    t_mem[index_3d] = *(t->get_data(z->get_nx()-1,j_offset+j,k));
		    p_mem[index_3d] = *(p->get_data(z->get_nx()-1,j_offset+j,k));
		    q_mem[index_3d] = *(q->get_data(z->get_nx()-1,j_offset+j,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(z->get_nx()-1,j_offset+j,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(z->get_nx()-1,j_offset+j,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(z->get_nx()-1,j_offset+j,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(z->get_nx()-1,j_offset+j,0);
		  }
		}
	      }
	    }
	    else{
	      i=batchx_size;
	      for(j=0;j<batchy_size;j++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y((batchx_index+1)*batchx_size,j_offset+j,0);
		lon[index_2d] = z->get_x((batchx_index+1)*batchx_size,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data((batchx_index+1)*batchx_size,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data((batchx_index+1)*batchx_size,j_offset+j,0);
		}
	      }
	    }

	    if(batchy_index==0){
	      j=-1;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0) - z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,z->get_ny()-1,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0);
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,0,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	    }
	    else{
	      j=-1;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,j_offset+j,0);
		lon[index_2d] = z->get_x(i_offset+i,j_offset+j,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,j_offset+j,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,j_offset+j,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,j_offset+j,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,j_offset+j,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,j_offset+j,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,j_offset+j,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,j_offset+j,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,j_offset+j,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,j_offset+j,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,j_offset+j,0);
		}
	      }
	    }
	    
	    if(batchy_index==nbatchy-1){
	      j=batchy_size;
	      if(z->is_y_periodic()){
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,0,0) + z->get_y_period();
		  lon[index_2d] = z->get_x(i_offset+i,0,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,0,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,0,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,0,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,0,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,0,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,0,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,0,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,0,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,0,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,0,0);
		  }
		}
	      }
	      else{
		for(i=0;i<batchx_size;i++){
		  index_2d = (i+1)*(batchy_size+2)+j+1;
		  lat[index_2d] = z->get_y(i_offset+i,z->get_ny()-1,0);
		  lon[index_2d] = z->get_x(i_offset+i,z->get_ny()-1,0);
		  for(k=0;k<z->get_nz();k++){
		    index_3d = index_2d*z->get_nz()+k;
		    z_mem[index_3d] = *(z->get_data(i_offset+i,z->get_ny()-1,k));
		    u_mem[index_3d] = *(u->get_data(i_offset+i,z->get_ny()-1,k));
		    v_mem[index_3d] = *(v->get_data(i_offset+i,z->get_ny()-1,k));
		    t_mem[index_3d] = *(t->get_data(i_offset+i,z->get_ny()-1,k));
		    p_mem[index_3d] = *(p->get_data(i_offset+i,z->get_ny()-1,k));
		    q_mem[index_3d] = *(q->get_data(i_offset+i,z->get_ny()-1,k));
		    u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,z->get_ny()-1,k));
		    v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,z->get_ny()-1,k));
		  }
		  if(map_factor_x != NULL && map_factor_y != NULL){
		    map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,z->get_ny()-1,0);
		    map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,z->get_ny()-1,0);
		  }
		}
	      }
	    }
	    else{
	      j=batchy_size;
	      for(i=0;i<batchx_size;i++){
		index_2d = (i+1)*(batchy_size+2)+j+1;
		lat[index_2d] = z->get_y(i_offset+i,(batchy_index+1)*batchy_size,0);
		lon[index_2d] = z->get_x(i_offset+i,(batchy_index+1)*batchy_size,0);
		for(k=0;k<z->get_nz();k++){
		  index_3d = index_2d*z->get_nz()+k;
		  z_mem[index_3d] = *(z->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_mem[index_3d] = *(u->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_mem[index_3d] = *(v->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  t_mem[index_3d] = *(t->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  p_mem[index_3d] = *(p->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  q_mem[index_3d] = *(q->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  u_p3_mem[index_3d] = *(u_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		  v_p3_mem[index_3d] = *(v_p3->get_data(i_offset+i,(batchy_index+1)*batchy_size,k));
		}
		if(map_factor_x != NULL && map_factor_y != NULL){
		  map_factor_x_mem[index_2d] = *map_factor_x->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		  map_factor_y_mem[index_2d] = *map_factor_y->get_data(i_offset+i,(batchy_index+1)*batchy_size,0);
		}
	      }
	    }

	    cudaMemsetAsync(d_edr_mem,0,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),stream[0]);
	    cudaMemcpyAsync(dlat,lat,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dlat@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dlon,lon,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dlon@meteorology_cal_gtg_suite" <<endl;
	    if(map_factor_x != NULL && map_factor_y != NULL){
	      cudaMemcpyAsync(d_map_factor_x_mem,map_factor_x_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for map_factor_x_mem@meteorology_cal_gtg_suite" <<endl;
	      cudaMemcpyAsync(d_map_factor_y_mem,map_factor_y_mem,(batchx_size+2)*(batchy_size+2)*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for map_factor_y_mem@meteorology_cal_gtg_suite" <<endl;
	    }
	    cudaMemcpyAsync(dz_mem,z_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[3]);
	    cudaMemcpyAsync(du_mem,u_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    cudaMemcpyAsync(dv_mem,v_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[0]);
	    cudaMemcpyAsync(dt_mem,t_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dt_mem@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dp_mem,p_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy for dp_mem@meteorology_cal_gtg_suite" <<endl;
	    cudaMemcpyAsync(dq_mem,q_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[1]);
	    cudaMemcpyAsync(du_p3_mem,u_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[2]);
	    cudaMemcpyAsync(dv_p3_mem,v_p3_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyHostToDevice,stream[2]);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cudaMemcpy@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    grid_copy.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    meteorology_cal_theta<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dp_mem,dt_mem,d_theta_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_theta@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_thetav<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_theta_mem,dq_mem,d_thetav_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_thetav@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_mem,d_map_factor_x_mem,dudx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dv_mem,d_map_factor_x_mem,dvdx);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cudaStreamSynchronize(stream[1]);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,du_mem,d_map_factor_y_mem,dudy);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_mem,d_map_factor_y_mem,dvdy);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);

	    cuda_add<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx,dvdy,d_div);
	    meteorology_uv_to_speed_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),du_mem,dv_mem,d_winds);
	    earth_cal_coriolis_fre<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2),dlat,d_coriolis_fre_mem);
	    
	    cudaStreamSynchronize(stream[0]);
	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,d_winds,d_map_factor_x_mem,dVdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,d_winds,d_map_factor_y_mem,dVdy);

	    meteorology_cal_vws_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,d_vws_mem);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_vws_kernel@meteorology_cal_gtg_suite" <<endl;
	    cudaStreamSynchronize(stream[0]);
	    cudaStreamSynchronize(stream[1]);
	    cudaStreamSynchronize(stream[3]);

	    meteorology_cal_ti2_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_vws_mem,d_ti2_mem);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_ti2_kernel@meteorology_cal_gtg_suite" <<endl;
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_multiply<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti2_mem,1.e7,d_ti2_mem);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_ti3_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_thetav_mem,d_vws_mem,d_ti2_mem,d_ti3_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_ti3_kernel@meteorology_cal_gtg_suite" <<endl;
	    int indices_index=0; //ti2
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti2_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[0]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[0],weighting[indices_index],d_edr_mem);
	    }
	    indices_index=1; //ti3
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti3_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[0]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[0],weighting[indices_index],d_edr_mem);
	    }

	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti2_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_ti2_mem);
	    }
	    cudaMemcpyAsync(ti2_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti3_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_ti3_mem);
	    }
	    cudaMemcpyAsync(ti3_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);


	    meteorology_cal_vorticity<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,du_mem,dv_mem,dudy,dvdx,d_winds,dVdx,dVdy,d_vorticity_curvarture,d_vorticity_shear);
	    meteorology_cal_ti4_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_coriolis_fre_mem,d_vorticity_curvarture,d_vorticity_shear,dz_mem,d_thetav_mem,d_vws_mem,d_ti4_mem);
	    indices_index=2; //ti4
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ti4_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ti4_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_ti4_mem);
	    }
	    cudaMemcpyAsync(ti4_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_add<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_vorticity_curvarture,d_vorticity_shear,d_curvature_mem);
	    cuda_square<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_curvature_mem);
	    indices_index=13; //curvature
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_curvature_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_curvature_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_curvature_mem);
	    }
	    cudaMemcpyAsync(curvature_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,du_p3_mem,d_map_factor_x_mem,dudx_p3);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cuda_cal_x_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dv_p3_mem,d_map_factor_y_mem,dvdy_p3);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_cuda_cal_y_derivatives_kernel@meteorology_cal_gtg_suite" <<endl;

	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_add<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dudx_p3,dvdy_p3,d_div_p3);
	    cuda_multiply<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div,1.e5,d_div);
	    cuda_multiply<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div_p3,1.e5,d_div_p3);
	    cudaStreamSynchronize(stream[0]);
	    cudaStreamSynchronize(stream[2]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_dti_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_ti2_mem,d_div,d_div_p3,d_dti_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_dti_kernel@meteorology_cal_gtg_suite" <<endl;
	    indices_index=6; //DIV
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_div,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[0]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[0],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_div,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_div);
	    }
	    cudaMemcpyAsync(div_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    indices_index=3; //DTI
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_dti_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[0]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[0],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_dti_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_dti_mem);
	    }
	    cudaMemcpyAsync(dti_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);

	    meteorology_cal_richardson_num_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,d_theta_mem,dz_mem,d_vws_mem,d_ri_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_richardson_num_kernel@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_colson_panofsky_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_ri_mem,d_vws_mem,d_colson_panofsky_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_colson_panofsky_kernel@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_tke_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,d_ri_mem,d_vws_mem,d_tke_mem,d_tke_dtf_mem);
	    if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_tke_kernel@meteorology_cal_gtg_suite" <<endl;
	    indices_index=5; //RI
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_ri_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_ri_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_ri_mem);
	    }
	    cudaMemcpyAsync(ri_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    indices_index=9; //CP
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_colson_panofsky_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_colson_panofsky_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_colson_panofsky_mem);
	    }
	    cudaMemcpyAsync(colson_panofsky_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    indices_index=7; //TKE
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_tke_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_mem);
	    }
	    cudaMemcpyAsync(tke_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    indices_index=8; //DTF3
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_tke_dtf_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_tke_dtf_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_tke_dtf_mem);
	    }
	    cudaMemcpyAsync(tke_dtf_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);

	    meteorology_cal_browns_index_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_coriolis_fre_mem,d_vws_mem,d_browns_index_mem);
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_browns_index_kernel@meteorology_cal_gtg_suite" <<endl;
	    meteorology_cal_pv_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dvdx,dudy,dp_mem,d_coriolis_fre_mem,d_theta_mem,d_pv_mem);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,d_pv_mem,d_map_factor_x_mem,dpvdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,d_pv_mem,d_map_factor_y_mem,dpvdy);
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_square<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdx);
	    cuda_square<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdy);
	    cuda_add<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dpvdx,dpvdy,d_grad_pv_mem);
	    cuda_sqrt<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_pv_mem);
	    
            if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_meteorology_cal_pv_kernel@meteorology_cal_gtg_suite" <<endl;

	    indices_index=10; //Browns
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_browns_index_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[2]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[2],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_browns_index_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_browns_index_mem);
	    }
	    cudaMemcpyAsync(browns_index_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);
	    indices_index=11; //PV
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_pv_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[2]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[2],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_pv_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_pv_mem);
	    }
	    cudaMemcpyAsync(pv_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);
	    indices_index=12; //GRAD_PV
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_pv_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[2]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[2],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_grad_pv_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_grad_pv_mem);
	    }
	    cudaMemcpyAsync(grapv_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    cuda_cal_x_derivatives_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlon,dt_mem,d_map_factor_x_mem,dtdx);
	    cuda_cal_y_derivatives_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dlat,dt_mem,d_map_factor_y_mem,dtdy);
	    grid.x = (int) ceil((double) (batchx_size+2)*(batchy_size+2)*z->get_nz()/numthreads);
	    cuda_square<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdx);
	    cuda_square<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdy);
	    cuda_add<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),dtdx,dtdy,d_grad_t_mem);
	    cuda_sqrt<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_t_mem);
	    indices_index=14; //GRAD_T
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_grad_t_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[3]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[3],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[3]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_grad_t_mem,x_neightbour,y_neightbour,radius,smooth[3]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[3]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[3],d_grad_t_mem);
	    }
	    cudaMemcpyAsync(grad_t_mem,smooth[3],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[3]);

	    grid.x = (int) ceil((double) (batchx_size)*(batchy_size)*z->get_nz()/numthreads);
	    meteorology_cal_mos_cat_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dudx,dudy,dvdx,dvdy,d_winds,d_mos_cat_mem);
	    indices_index=17; //MOS_CAT
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_mos_cat_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[0]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[0],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[0]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_mos_cat_mem,x_neightbour,y_neightbour,radius,smooth[0]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[0]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[0],d_mos_cat_mem);
	    }
	    cudaMemcpyAsync(mos_cat_mem,smooth[0],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[0]);
	    meteorology_cal_dutton_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dVdx,dVdy,du_mem,dv_mem,d_winds,d_vws_mem,d_dutton_index_mem);
	    indices_index=4; //VWS
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_vws_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_vws_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_vws_mem);
	    }
	    cudaMemcpyAsync(vws_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    indices_index=16; //Dutton Index
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_dutton_index_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[1]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[1],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[1]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_dutton_index_mem,x_neightbour,y_neightbour,radius,smooth[1]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[1]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[1],d_dutton_index_mem);
	    }
	    cudaMemcpyAsync(dutton_index_mem,smooth[1],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[1]);
	    meteorology_cal_wind_index_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size,batchy_size,z->get_nz(),1,1,0,dz_mem,du_mem,dv_mem,d_winds,d_wind_index_mem);
	    indices_index=15; //Wind Index
	    if(use_in_edr[indices_index]){
	      meteorology_cal_edr_mapping_kernel<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),d_wind_index_mem,nmap,d_threshold+indices_index*nmap,d_scale,mapping_space[2]);
	      meteorology_cal_edr_add_index<<<grid,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),mapping_space[2],weighting[indices_index],d_edr_mem);
	    }
	    if(index_to_smooth){
	      gaussian_smooth_kernel<<<grid,numthreads,0,stream[2]>>>(batchx_size+2,batchy_size+2,z->get_nz(),d_wind_index_mem,x_neightbour,y_neightbour,radius,smooth[2]);
	    }
	    else{
	      cuda_set_value<<<grid_copy,numthreads,0,stream[2]>>>((batchx_size+2)*(batchy_size+2)*z->get_nz(),smooth[2],d_wind_index_mem);
	    }
	    cudaMemcpyAsync(wind_index_mem,smooth[2],(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost,stream[2]);

	    cudaDeviceSynchronize();
	    cudaMemcpy(edr_mem,d_edr_mem,(batchx_size+2)*(batchy_size+2)*z->get_nz()*sizeof(double),cudaMemcpyDeviceToHost);

	    for(j=0;j<batchy_size;j++){
	      for(i=0;i<batchx_size;i++){
		for(k=0;k<z->get_nz();k++){
		  *(div->get_data(i_offset+i,j_offset+j,k)) = div_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti2->get_data(i_offset+i,j_offset+j,k)) = ti2_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti3->get_data(i_offset+i,j_offset+j,k)) = ti3_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(ti4->get_data(i_offset+i,j_offset+j,k)) = ti4_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(vws->get_data(i_offset+i,j_offset+j,k)) = vws_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(dti->get_data(i_offset+i,j_offset+j,k)) = dti_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(inri->get_data(i_offset+i,j_offset+j,k)) = ri_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(colson_panofsky->get_data(i_offset+i,j_offset+j,k)) = colson_panofsky_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(browns_index->get_data(i_offset+i,j_offset+j,k)) = browns_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(tke->get_data(i_offset+i,j_offset+j,k)) = tke_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(tke_dtf->get_data(i_offset+i,j_offset+j,k)) = tke_dtf_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(pv->get_data(i_offset+i,j_offset+j,k)) = pv_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(grad_pv->get_data(i_offset+i,j_offset+j,k)) = grapv_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(curvature->get_data(i_offset+i,j_offset+j,k)) = curvature_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(grad_t->get_data(i_offset+i,j_offset+j,k)) = grad_t_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(wind_index->get_data(i_offset+i,j_offset+j,k)) = wind_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(dutton_index->get_data(i_offset+i,j_offset+j,k)) = dutton_index_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(mos_cat->get_data(i_offset+i,j_offset+j,k)) = mos_cat_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		  *(edr->get_data(i_offset+i,j_offset+j,k)) = edr_mem[((i+1)*(batchy_size+2)+j+1)*z->get_nz()+k];
		}
	      }
	    }

	  }
	}
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_end_of_batchxy_loop@meteorology_cal_gtg_suite" <<endl;
	
	if(map_factor_x != NULL && map_factor_y != NULL){
	  cudaFree(d_map_factor_x_mem);
	  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_map_factor_x_mem@meteorology_cal_gtg_suite" <<endl;
	  cudaFree(d_map_factor_y_mem);
          if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_map_factor_y_mem@meteorology_cal_gtg_suite" <<endl;
	}
	for(i=0;i<num_cudaStream;i++){
	  cudaFree(smooth[i]);
	  cudaFree(mapping_space[i]);
	}
	delete [] smooth;
	delete [] mapping_space;

	if(work_space == NULL){
	  delete [] lat;
	  delete [] lon;
	  if(map_factor_x != NULL && map_factor_y != NULL){
	    delete [] map_factor_x_mem;
	    delete [] map_factor_y_mem;
	  }
	  delete [] z_mem;
	  delete [] u_mem;
	  delete [] v_mem;
	  delete [] t_mem;
	  delete [] q_mem;
	  delete [] p_mem;
	  delete [] u_p3_mem;
	  delete [] v_p3_mem;
	  delete [] ti2_mem;
	  delete [] ti3_mem;
	  delete [] ti4_mem;
	  delete [] dti_mem;
	  delete [] vws_mem;
	  delete [] ri_mem;
	  delete [] tke_mem;
	  delete [] tke_dtf_mem;
	  delete [] colson_panofsky_mem;
	  delete [] browns_index_mem;
	  delete [] pv_mem;
	  delete [] grapv_mem;
	  delete [] clark_cat_mem;
	  delete [] curvature_mem;
	  delete [] grad_t_mem;
	  delete [] wind_index_mem;
	  delete [] dutton_index_mem;
	  delete [] mos_cat_mem;
	  delete [] div_mem;
	  delete [] edr_mem;
	}

	cudaFree(dlat);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dlat@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dlon);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dlon@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dz_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dz_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(du_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_du__mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dv_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dv_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dt_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dt_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_theta_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dtheta_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_thetav_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dthetav_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dp_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dp_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dq_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dq_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(du_p3_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_du_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dv_p3_mem);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dv_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_div);
        if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_ddiv_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_div_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_d_div_p3_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudx);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudy);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdx);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdy);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudx_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dudy_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dudy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdx_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdx_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dvdy_p3);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_dvdy_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(d_coriolis_fre_mem);
	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_free_coriolis_mem@meteorology_cal_gtg_suite" <<endl;
	cudaFree(dVdx);
	cudaFree(dVdy);
	cudaFree(dpvdx);
	cudaFree(dpvdy);
	cudaFree(dtdx);
	cudaFree(dtdy);

	cudaFree(d_ti2_mem);
	cudaFree(d_ti3_mem);
	cudaFree(d_ti4_mem);
	cudaFree(d_dti_mem);
	cudaFree(d_vws_mem);
	cudaFree(d_ri_mem);
	cudaFree(d_tke_mem);
	cudaFree(d_tke_dtf_mem);
	cudaFree(d_colson_panofsky_mem);
	cudaFree(d_browns_index_mem);
	cudaFree(d_pv_mem);
	cudaFree(d_grad_pv_mem);
	cudaFree(d_clark_cat_mem);
	cudaFree(d_curvature_mem);
	cudaFree(d_grad_t_mem);
	cudaFree(d_wind_index_mem);
	cudaFree(d_dutton_index_mem);
	cudaFree(d_mos_cat_mem);
	cudaFree(d_edr_mem);
	
	cudaFree(d_threshold);
	cudaFree(d_scale);

	cudaFree(d_winds);
	cudaFree(d_vorticity_curvarture);
	cudaFree(d_vorticity_shear);

	for(i=0;i<num_cudaStream;i++){
	  cudaStreamDestroy(stream[i]);
	}
	delete [] stream;

	if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@cuda_end_function@meteorology_cal_gtg_suite : "  <<endl;
      }
    }
    else{
      
    }
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_cal_icing_rh_tt(const grid_data_field* t,const grid_data_field* q,const grid_data_field* ice){
    if(grid_data_field_check_grid_inconsistence(t,q) ||
       grid_data_field_check_grid_inconsistence(t,ice)){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    int i,j,k;
    for(i=0;i<t->get_nx();i++){
      for(j=0;j<t->get_ny();j++){
	for(k=0;k<t->get_nz();k++){
	  if(*(t->get_data(i,j,k)) <= meteorology_C_to_K && *(t->get_data(i,j,k)) >= meteorology_C_to_K - 5. && *(q->get_data(i,j,k))/meteorology_cal_saturated_mixing_ratio(t->get_z(i,j,k),*(t->get_data(i,j,k))) >= 0.95){
	    *(ice->get_data(i,j,k)) = 1.;
	  }
	  else{
	    *(ice->get_data(i,j,k)) = 0.;
	  }
	}
      }
    }


    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### ###DEVICE### double meteorology_convective_cal_ice_ratio(double t){
    double alpha;

    if(t <= tice){
      alpha = 0.;
    }
    else if(t >= t0){
      alpha = 1;
    }
    else{
      alpha = pow((t - tice)/(t0 - tice),2.);
    }

    return alpha;
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_cal_layer_density(int nstate,int nz,double *temperature,double *pressure,double *mixing_ratio,int level,double *density){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      density[i] = libjeff::meteorology_cal_density(temperature[i*nz+level],pressure[i*nz+level],mixing_ratio[i*nz+level]);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_cal_conv_scale_w(int nstate,int nz,double *blh,double *sshf,double *slhf,double *temperature,double *density,int departure_level,double *conv_scale_w){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      conv_scale_w[i] = 1.2*cbrt(u_asterisk_cube - 1.5*kapper*meteorology_g0*blh[i]*(sshf[i]/meteorology_Cpd + 0.61*slhf[i]*temperature[i*nz+departure_level]/meteorology_Lv)/(density[i]*temperature[i*nz+departure_level]));
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_cal_delta_t(int nstate,double *sshf,double *density,double *conv_scale_w,double *delta_t){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      delta_t[i] = -1.5*sshf[i]/(meteorology_Cpd*density[i]*conv_scale_w[i]);
      if(delta_t[i] > 3){
	delta_t[i] = 3.;
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_cal_delta_q(int nstate,double *slhf,double *density,double *conv_scale_w,double *delta_q){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      delta_q[i] = 1.5*slhf[i]/(meteorology_Lv*density[i]*conv_scale_w[i]);
      if(delta_q[i] > 2e-3){
	delta_q[i] = 2e-3;
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_delta_t(int nstate,double *delta_t){
	 int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      delta_t[i] = 0.2;
	} 
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_delta_q(int nstate,double *delta_q){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      delta_q[i] = 1.e-4;
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_cal_parcel_t(int nstate,double *parcel_s,double *gph,double *updraft_ke,double *parcel_t){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      if(updraft_ke[i] >= 0.){
	parcel_t[i] = (parcel_s[i] - meteorology_g0*gph[i])/meteorology_Cpd;
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_shallow_set_updraft_ke(int nstate,int nz,double *conv_scale_w,double *updraft_ke){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      updraft_ke[i*nz] = 0.5*conv_scale_w[i]*conv_scale_w[i];
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_updraft_ke(int nstate,int nz,double *density,double *updraft_ke){
	  int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      updraft_ke[i*nz] = 0.5/(density[i]*density[i]);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_shallow_set_parcel_s(int nstate,int nz,double *temperature,double *delta_t,double *gph,double *parcel_s){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      parcel_s[i*nz] = (temperature[i*nz] + delta_t[i])*meteorology_Cpd + meteorology_g0*gph[i*nz];
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_shallow_set_parcel_q(int nstate,int nz,double *qvapor,double *delta_q,double *parcel_q){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      parcel_q[i*nz] = qvapor[i*nz] + delta_q[i];
      if(parcel_q[i*nz] < 0){
	parcel_q[i*nz] = 0;
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_parcel_s(int nstate,int nz,double *pressure,double *temperature,double *gph,double *delta_t,int layer_index,double *parcel_s){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      double temp_s;
      int count,j;
      
      if(pressure[i*nz+layer_index] >= pressure[i*nz] -60.){
	temp_s = 0.;
	count = 0;
	
	for(j=0;j<nz;j++){
	  if(fabs(pressure[i*nz+layer_index] - pressure[i*nz+j]) <= 50.*0.5){
	    temp_s += temperature[i*nz+layer_index]*meteorology_Cpd + meteorology_g0*gph[i*nz+layer_index];
	    count++;
	  }
	  else if(pressure[i*nz+layer_index] - pressure[i*nz+j] > 50.*0.5){
	    break;
	  }
	}
	temp_s /= count;
	
	parcel_s[i*nz+layer_index]= temp_s + delta_t[i]*meteorology_Cpd;
      }
      else{
	parcel_s[i*nz+layer_index]= (temperature[i*nz+layer_index] + delta_t[i])*meteorology_Cpd + meteorology_g0*gph[i*nz+layer_index];
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_parcel_q(int nstate,int nz,double *pressure,double *qvapor,double *delta_q,int layer_index,double *parcel_q){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      double temp_q;
      int count,j;
      
      if(pressure[i*nz+layer_index] >= pressure[i*nz] -60.){
	temp_q = 0.;
	count = 0;
	
	for(j=0;j<nz;j++){
	  if(fabs(pressure[i*nz+layer_index] - pressure[i*nz+j]) <= 50.*0.5){
	    temp_q += qvapor[i*nz+layer_index];
	    count++;
	  }
	  else if(pressure[i*nz+layer_index] - pressure[i*nz+j] > 50.*0.5){
	    break;
	  }
	}
	temp_q /= count;
	
	parcel_q[i*nz+layer_index]= temp_q + delta_q[i];
      }
      else{
	parcel_q[i*nz+layer_index]= qvapor[i*nz+layer_index] + delta_q[i];
      }		
    }
  }
  ###CPP### ###CUDA### ###HOST### void meteorology_convective_scheme_ec_simplified_shallow_entrainment(const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* z,double *updraft_ke,double *parcel_s,double *parcel_q){
    int i,j,k;

    double env_s, epsilon, delta_z, parcel_t, parcel_t1, env_tv, parcel_tv;
    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	for(k=1;k<p->get_nz();k++){
	  if(*(p->get_data(i,j,k)) > 0){
	    env_s = 0.5*((*(t->get_data(i,j,k)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(i,j,k))) + (*(t->get_data(i,j,k-1)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(i,j,k-1))));
	    epsilon = (2e-4 + 0.8/((*(z->get_data(i,j,k))) + (*(z->get_data(i,j,k-1))))*2);
	    if(epsilon < 0){
	      epsilon = 2.e-4;
	    }
	    //density = 0.5*(meteorology_cal_density((*(t->get_data(i,j,k))),(*(p->get_data(i,j,k))),(*(q->get_data(i,j,k)))) + meteorology_cal_density((*(t->get_data(i,j,k-1))),(*(p->get_data(i,j,k-1))),(*(q->get_data(i,j,k-1)))));
	    delta_z = (*(z->get_data(i,j,k))) - (*(z->get_data(i,j,k-1)));

	    //parcel_s[(i*p->get_ny()+j)*p->get_nz()+k] = parcel_s[(i*p->get_ny()+j)*p->get_nz()+k-1] + env_s*(epsilon)/(0.5*(epsilon) + 1./(delta_z));
	    parcel_s[(i*p->get_ny()+j)*p->get_nz()+k] = (env_s*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_s[(i*p->get_ny()+j)*p->get_nz()+k-1])/(1. + 0.5*epsilon*delta_z);
	    //parcel_q[(i*p->get_ny()+j)*p->get_nz()+k] = parcel_q[(i*p->get_ny()+j)*p->get_nz()+k-1] + (epsilon)/(0.5*(epsilon) + 1./(delta_z))*(*(q->get_data(i,j,k)));
	    parcel_q[(i*p->get_ny()+j)*p->get_nz()+k] = ((*(q->get_data(i,j,k)))*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_q[(i*p->get_ny()+j)*p->get_nz()+k-1])/(1. + 0.5*epsilon*delta_z);
	    
	    parcel_t = (parcel_s[(i*p->get_ny()+j)*p->get_nz()+k] - meteorology_g0*(*(z->get_data(i,j,k))))/meteorology_Cpd;
	    parcel_t1 = (parcel_s[(i*p->get_ny()+j)*p->get_nz()+k-1] - meteorology_g0*(*(z->get_data(i,j,k-1))))/meteorology_Cpd;
	    env_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,t->get_data(i,j,k),q->get_data(i,j,k),NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,t->get_data(i,j,k-1),q->get_data(i,j,k-1),NULL,NULL,NULL));
	    parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[(i*p->get_ny()+j)*p->get_nz()+k],NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[(i*p->get_ny()+j)*p->get_nz()+k-1],NULL,NULL,NULL));
	    
	    //updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] = (1. + epsilon*density*delta_z*(1. + 1.875*0.506))*updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5));
	    //updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] = ((1. - epsilon*density*delta_z*(1. + 1.875*0.506))*updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + epsilon*density*delta_z*(1. + 1.875*0.506));
	    //updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] = ((1. - epsilon*delta_z*(1. + 1.875*0.506)/density)*updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + epsilon*delta_z*(1. + 1.875*0.506)/density);
	    updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] = ((1. - epsilon*delta_z*(1. + 1.875*0.506))*updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + epsilon*delta_z*(1. + 1.875*0.506));

	    if(updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] < 0.){
	      /*
	      for(m=k+1;m<p->get_nz();m++){
		updraft_ke[(i*p->get_ny()+j)*p->get_nz()+m] = -1.;
	      }
	      */
	      break;
	    }
	  }
	  else{
	    /*
	    for(m=k;m<p->get_nz();m++){
	      updraft_ke[(i*p->get_ny()+j)*p->get_nz()+m] = -1.;
	    }
	    */
	    break;
	  }
	}
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_simplified_shallow_entrainment_kernel(int nstate,int nz,int layer_index,double *pressure,double *temperature,double *qvapor,double *gph,double *updraft_ke,double *parcel_s,double *parcel_q){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate){
      if(updraft_ke[i*nz+layer_index] >= 0.){
	double env_s, epsilon, delta_z, parcel_t, parcel_t1, env_tv, parcel_tv;

	env_s = 0.5*(temperature[i*nz+layer_index]*meteorology_Cpd +meteorology_g0*gph[i*nz+layer_index] + temperature[i*nz+layer_index-1]*meteorology_Cpd +meteorology_g0*gph[i*nz+layer_index-1]);
	epsilon = (2e-4 + 0.8/(gph[i*nz+layer_index] + gph[i*nz+layer_index-1])*2);
	if(epsilon < 0){
	  epsilon = 2.e-4;
	}
	delta_z = gph[i*nz+layer_index] - gph[i*nz+layer_index-1];

	parcel_s[i*nz+layer_index] = (env_s*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_s[i*nz+layer_index-1])/(1. + 0.5*epsilon*delta_z);
	parcel_q[i*nz+layer_index] = (qvapor[i*nz+layer_index]*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_q[i*nz+layer_index-1])/(1. + 0.5*epsilon*delta_z);
	    
	parcel_t = (parcel_s[i*nz+layer_index] - meteorology_g0*gph[i*nz+layer_index])/meteorology_Cpd;
	parcel_t1 = (parcel_s[i*nz+layer_index-1] - meteorology_g0*gph[i*nz+layer_index-1])/meteorology_Cpd;
	env_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&temperature[i*nz+layer_index],&qvapor[i*nz+layer_index],NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,&temperature[i*nz+layer_index-1],&qvapor[i*nz+layer_index-1],NULL,NULL,NULL));
	parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[i*nz+layer_index],NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[i*nz+layer_index-1],NULL,NULL,NULL));
	updraft_ke[i*nz+layer_index] = ((1. - epsilon*delta_z*(1. + 1.875*0.506))*updraft_ke[i*nz+layer_index-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + epsilon*delta_z*(1. + 1.875*0.506));
      }
      else{
	updraft_ke[i*nz+layer_index] = -1.;
      }
    }
  }
  ###CUDA### ###HOST### void meteorology_convective_scheme_ec_simplified_shallow_entrainment_gpu(int nstate,int nz,double *pressure,double *temperature,double *qvapor,double *gph,double *updraft_ke,double *parcel_s,double *parcel_q){
    int i;
    int numthreads = cuda_setting::get_numthreads();
    dim3 grid;

    grid.x = (int) ceil(((double) nstate)/numthreads);

    for(i=1;i<nz;i++){
      meteorology_convective_scheme_ec_simplified_shallow_entrainment_kernel<<<grid,numthreads>>>(nstate,nz,i,pressure,temperature,qvapor,gph,updraft_ke,parcel_s,parcel_q);
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_find_cloudbase(int nstate,int nz,double *pressure,double *parcel_t,double *parcel_q,double *updraft_ke,int *cloud_base_level){
    int i=blockDim.x*blockIdx.x + threadIdx.x;
    int k;

    if(i<nstate){
      cloud_base_level[i] = -1;
      for(k=0;k<nz;k++){
	if(updraft_ke[i*nz+k] >= 0){
	  if(meteorology_cal_mixing_ratio(pressure[i*nz+k],parcel_t[i*nz+k],parcel_t[i*nz+k]) <= parcel_q[i*nz+k]){
	    cloud_base_level[i]=k;
	    break;
	  }
	}
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_find_cloudtop(int nstate,int nz,double *updraft_ke,int *cloud_base_level,int *cloud_top_level){
    int i=blockDim.x*blockIdx.x + threadIdx.x;
    int k;

    if(i<nstate){
      cloud_top_level[i] = -1;
      if(cloud_base_level[i]>=0){
	for(k=cloud_base_level[i]+1;k<nz;k++){
	  if(updraft_ke[i*nz+k] < 0){
	    cloud_top_level[i] = k;
	    break;
	  }
	}
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_check_shallow_conv_type(int nstate,int nz,double *pressure,double *updraft_ke,double *parcel_t,double *parcel_q,double *gph,int *cloud_base_level,int *cloud_top_level,double *cloud_base_w,double *cloud_base_s,double *cloud_base_q,double *cloud_base_qc,int *conv_type){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate && cloud_base_level[i] >= 0){
      if(pressure[i*nz+cloud_base_level[i]] - pressure[i*nz+cloud_top_level[i]] <= 200.){
	conv_type[i] = 1;
	cloud_base_w[i] = pow(2.*updraft_ke[i*nz+cloud_base_level[i]],0.5);
	cloud_base_s[i] = parcel_t[i*nz+cloud_base_level[i]];
	cloud_base_q[i] = parcel_q[i*nz+cloud_base_level[i]];
	cloud_base_qc[i] = 0.;

	meteorology_cal_saturation_adjustment(pressure[i*nz+cloud_base_level[i]],cloud_base_s[i],cloud_base_q[i],cloud_base_qc[i]);

	cloud_base_s[i] = cloud_base_s[i]*meteorology_Cpd + meteorology_g0*gph[i*nz+cloud_base_level[i]];
      }
    }
  }
  ###CUDA### ###GLOBAL### void meteorology_convective_scheme_ec_deep_set_p_mask(int nstate,int nz,double *pressure,int departure_level,int *p_mask){
    int i=blockDim.x*blockIdx.x + threadIdx.x;

    if(i<nstate && pressure[i*nz] - pressure[i*nz+departure_level] > 350.){
      p_mask[i] = 1;
    }
  }

  ###CPP### ###CUDA### ###HOST### void meteorology_convective_scheme_ec_simplified_deep_entrainment(int xindex,int yindex,int departing_level,const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,const grid_data_field* z,double *updraft_ke,double *parcel_s,double *parcel_q,double *parcel_qc,double *parcel_qr,bool &lcl_found,int &lcl_level){
    int k,m;

    double env_s, epsilon, delta_z, parcel_t, parcel_t1, env_tv, parcel_tv;
//double delta_p;
    double condensate;
    lcl_found = false;
    int error;
    double alpha, es;
    for(k=departing_level+1;k<p->get_nz();k++){
      env_s = 0.5*((*(t->get_data(xindex,yindex,k)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(xindex,yindex,k))) + (*(t->get_data(xindex,yindex,k-1)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(xindex,yindex,k-1))));
      epsilon = 0.4*1.75e-3*pow(0.5*(
				     meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k))) +
				     meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1))))
				/meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,0)),*(t->get_data(xindex,yindex,0)),*(t->get_data(xindex,yindex,0))),3.);
      if(epsilon > 0.4*1.75e-3){
	epsilon = 0.4*1.75e-3;
      }
	      //(2e-4 + 0.8/((*(z->get_data(xindex,yindex,k))) + (*(z->get_data(xindex,yindex,k-1))))*2);
      //density = 0.5*(meteorology_cal_density((*(t->get_data(xindex,yindex,k))),(*(p->get_data(xindex,yindex,k))),(*(q->get_data(xindex,yindex,k)))) + meteorology_cal_density((*(t->get_data(xindex,yindex,k-1))),(*(p->get_data(xindex,yindex,k-1))),(*(q->get_data(xindex,yindex,k-1)))));
      delta_z = (*(z->get_data(xindex,yindex,k))) - (*(z->get_data(xindex,yindex,k-1)));
      //delta_p = (*(p->get_data(xindex,yindex,k))) - (*(p->get_data(xindex,yindex,k-1)))*100.;

      //before adjustment
      parcel_s[k] = (env_s*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_s[k-1])/(1. + 0.5*epsilon*delta_z);
      parcel_q[k] = ((*(q->get_data(xindex,yindex,k)))*epsilon*delta_z + (1. - 0.5*epsilon*delta_z)*parcel_q[k-1])/(1. + 0.5*epsilon*delta_z);
      parcel_t = (parcel_s[k] - meteorology_g0*(*(z->get_data(xindex,yindex,k))))/meteorology_Cpd;
      if(parcel_t > 400){
	std::cout << "Bug. Temperature too high: " << parcel_t << " " << parcel_s[k] << " " << parcel_s[k-1] << endl;
      }
      parcel_t1 = (parcel_s[k-1] - meteorology_g0*(*(z->get_data(xindex,yindex,k-1))))/meteorology_Cpd;
      condensate = 0.;

      alpha = meteorology_convective_cal_ice_ratio(parcel_t);
      es = alpha*meteorology_cal_saturated_mixing_ratio(*(p->get_data(xindex,yindex,k)),parcel_t) + (1. - alpha)*meteorology_cal_saturated_mixing_ratio_ice(*(p->get_data(xindex,yindex,k)),parcel_t);
      //lv = alpha*meteorology_Lv + (1. - alpha)*meteorology_Lvice;
      
      if(parcel_q[k] > es){ //saturation adjustment
	error = meteorology_cal_saturation_adjustment(*(p->get_data(xindex,yindex,k)),parcel_t,parcel_q[k],condensate);
	if(lcl_found == false){
	  lcl_level = k;
	  lcl_found = true;
	}
	if(error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
	  if(libjeff::debug_setting::get_debug_mode_warning()){
	    std::cout << "Warning! Saturation adjustment failed to converge in simplified deep entrainment." << endl;
	  }
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	    log.clear();
	  }
	}
	else{
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    log.clear();
	  }
	}
      }

      parcel_s[k] = parcel_t*meteorology_Cpd +meteorology_g0*(*(z->get_data(xindex,yindex,k)));
      parcel_qc[k] = parcel_qc[k-1]*0.5 + condensate;//*delta_z*meteorology_cal_density(*(p->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k)),*(q->get_data(xindex,yindex,k)));
      if(libjeff::debug_setting::get_debug_mode_warning() && parcel_qc[k] < 0){
	std::cout << "Warning! Qcloud < 0. Qcloud = " << parcel_qc[k] << endl;
      }

      env_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,t->get_data(xindex,yindex,k),q->get_data(xindex,yindex,k),NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,t->get_data(xindex,yindex,k-1),q->get_data(xindex,yindex,k-1),NULL,NULL,NULL));
      /*
      parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[k],NULL,&parcel_qc[k],NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[k-1],NULL,&parcel_qc[k-1],NULL));
      */
      parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[k],NULL,&parcel_qc[k],NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[k-1],NULL,&parcel_qc[k-1],NULL));

	    //updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k] = (1. + epsilon*density*delta_z*(1. + 1.875*0.506))*updraft_ke[(i*p->get_ny()+j)*p->get_nz()+k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5));
      updraft_ke[k] = ((1. - epsilon*delta_z*(1. + 1.875*0.506))*updraft_ke[k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + epsilon*delta_z*(1. + 1.875*0.506));
      if(updraft_ke[k] < 0.){
	if(lcl_found && k == lcl_level){
	  lcl_found = false;
	}
	for(m=k+1;m<p->get_nz();m++){
	  updraft_ke[m] = -1.;
	}
	break;
      }
    }
  }
  ###CPP### ###CUDA### ###HOST### double meteorology_convective_scheme_ec_cal_updraft_ggp(double mf,double density,double wup,double t,double lup,bool island){
    double c0, lcrit;
    double alpha = meteorology_convective_cal_ice_ratio(t);

    c0 = 1.4e-3*(1.3*alpha + (1-alpha));
    lcrit = 0.0005;

    if(t < tbf){
      double tempdiff = tbf - t;
      if(tbf - tice < tempdiff){
	tempdiff = tbf - tice;
      }
      c0 *= (1 + 0.5*pow(tempdiff,0.5));
      lcrit /= (1 + 0.5*pow(tempdiff,0.5));
    }
    
    if(wup > 10){
      wup = 10;
    }

    if(island){
      if(lup > 0.0005){
	return c0*mf*lup*(1. - exp(-pow(lup/lcrit,2.)))/(0.75*density*wup);
      }
      else{
	return 0.;
      }
    }
    else{
      if(lup > 0.0003){
	return c0*mf*lup*(1. - exp(-pow(lup/lcrit,2.)))/(0.75*density*wup);
      }
      else{
	return 0.;
      }
    }
  }
  ###CPP### ###CUDA### ###HOST### double meteorology_convective_scheme_ec_cal_updraft_sfall(double mf,double vn,double rn,double wup,double delta_p){
    return meteorology_g0*mf*vn*rn/(wup*fabs(delta_p));
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_updraft_condensate(double epsilon,double mu,double delta_p,double p,double env_s,double env_q,double mfn,double mfn_1,double zn,double zn_1,double &sn,double sn_1,double &qn,double qn_1,double &adj_q){
    adj_q = 0;

    double outs, outq, condensate;
    double temps,tempq, tempt;
    double lv, alpha;

    tempt = (sn_1 - meteorology_g0*zn_1)/meteorology_Cpd;

    int i,error;
    for(i=0;i<MAX_ITERATION_UPDRAFT_CONDENSATION;i++){
      alpha = meteorology_convective_cal_ice_ratio(tempt);
      lv = alpha*meteorology_Lv + (1-alpha)*meteorology_Lvice;
      //outq = ((2*meteorology_g0 + mu*delta_p)*mfn_1*qn_1 - epsilon*delta_p*(mfn + mfn_1)*env_q - meteorology_g0*mfn*adj_q)/((meteorology_g0 - mu*delta_p)*mfn);
      //outs = ((2*meteorology_g0 + mu*delta_p)*mfn_1*sn_1 - epsilon*delta_p*(mfn + mfn_1)*env_s + meteorology_Lv*meteorology_g0*mfn*(adj_q - outq))/((2*meteorology_g0 - mu*delta_p)*mfn);
      outq = ((2*meteorology_g0 + mu*delta_p)*mfn_1*qn_1 - epsilon*delta_p*(mfn + mfn_1)*env_q + 2*meteorology_g0*mfn*adj_q)/((4*meteorology_g0 - mu*delta_p)*mfn);
      outs = ((2*meteorology_g0 + mu*delta_p)*mfn_1*sn_1 - epsilon*delta_p*(mfn + mfn_1)*env_s - 2*lv*meteorology_g0*mfn*(adj_q - outq))/((2*meteorology_g0 - mu*delta_p)*mfn);
      //outq = ((2*meteorology_g0 + mu*delta_p)*mfn_1*qn_1 - epsilon*delta_p*(mfn + mfn_1)*env_q - 2*meteorology_g0*mfn*adj_q)/((-mu*delta_p)*mfn);
      //outs = ((2*meteorology_g0 + mu*delta_p)*mfn_1*sn_1 - epsilon*delta_p*(mfn + mfn_1)*env_s - 2*lv*meteorology_g0*mfn*(outq - adj_q))/((2*meteorology_g0 - mu*delta_p)*mfn);

      temps = outs;
      tempq = outq;

      tempt = (temps - meteorology_g0*zn)/meteorology_Cpd;

      error = meteorology_cal_saturation_adjustment(p,tempt,tempq,condensate);
      if(error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
	if(libjeff::debug_setting::get_debug_mode_warning()){
	  std::cout << "Warning! Saturation adjustment failed to converge in cloud condensate calculation." << endl;
	  return error;
	}
	if(libjeff::debug_setting::get_debug_mode_debug_log()){
	  libjeff::debug_log log;
	  std::cout << log;
	  std::cout.flush();
	}
      }

      if(libjeff::debug_setting::get_debug_mode_debug_log()){
	libjeff::debug_log log;
	log << "Updraft condensation calculation: Iteration: " << i << " " << adj_q << " " << tempq << '\n';
      }

      if(fabs(adj_q-tempq) < DEFAULT_UPDRAFT_CONDENSATION_ACCURACY){
	sn = outs;
	qn = outq;
	return _ERRORCODE_NOERROR;
      }

      adj_q = tempq;
    }

    return _ERRORCODE_ITERATIONSFAILEDTOCONVERGE;
  }

  ###CPP### ###CUDA### ###HOST### double ec_updraft_conversion_funct(double in,double *dparms,int *iparms){
    /*
      dparms[0] = mu
      dparms[1] = delta_p
      dparms[2] = density
      dparms[3] = wup
      dparms[4] = t
      dparms[5] = mfn
      dparms[6] = mfn_1
      dparms[7] = lupn_1
      dparms[8] = condensate
    */
    /*
    int i;
    for(i=0;i<9;i++){
      std::cout << dparms[i] << " ";
    }
    std::cout << in << " ";
    */
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      int i;
      for(i=0;i<9;i++){
	log << dparms[i] << " ";
      }
      log << meteorology_convective_scheme_ec_cal_updraft_ggp(dparms[5],dparms[2],dparms[3],dparms[4],in,false) << " " << in << " ";
    }
    double result = ((2.*meteorology_g0 - dparms[0]*dparms[1])*dparms[5])*in - ((2*meteorology_g0 + dparms[0]*dparms[1])*dparms[6]*dparms[7] - 2.*dparms[8]*dparms[1] + 2.*meteorology_convective_scheme_ec_cal_updraft_ggp(dparms[5],dparms[2],dparms[3],dparms[4],in,false)*dparms[1]);
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << result << '\n';
    }
    return result;
  }
  ###CPP### ###CUDA### ###HOST### double ec_updraft_fallout_funct(double in,double *dparms,int *iparms){
    /*
    dparms[0] = mu;
    dparms[1] = delta_p;
    dparms[2] = wup;
    dparms[3] = t;
    dparms[4] = mfn;
    dparms[5] = mfn_1;
    dparms[6] = rupn_1;
    dparms[7] = ggp;      
    dparms[8] = alpha;
    */
    /*
    int i;
    for(i=0;i<9;i++){
      std::cout << dparms[i] << " ";
    }
    std::cout << in << " ";
    */
    double vn = 21.18*pow(in,0.2)*dparms[8] + (1-dparms[8])*21.18*pow(in,0.2)*0.5;
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      int i;
      for(i=0;i<8;i++){
	log << dparms[i] << " ";
      }
      log << meteorology_convective_scheme_ec_cal_updraft_sfall(dparms[4],vn,in,dparms[2],dparms[1]) << " " << in << " ";
    }
    double result = ((2.*meteorology_g0 - dparms[0]*dparms[1])*dparms[4])*in - ((2*meteorology_g0 + dparms[0]*dparms[1])*dparms[5]*dparms[6] - 2.*dparms[7]*dparms[1] + 2.*meteorology_convective_scheme_ec_cal_updraft_sfall(dparms[4],vn,in,dparms[2],dparms[1])*dparms[1]);

    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << result << '\n';
    }
    return result;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_updraft_conversion(double mu,double delta_p,double density,double t,double mfn,double mfn_1,double zn,double zn_1,double updraft_ken,double updraft_ken_1,double qn,double qn_1,double &lupn,double lupn_1,double condensate,double &ggp){
    int i;

    double outl;
    double wup;

    wup = pow(updraft_ken + updraft_ken_1,0.5);
    double *dparms = new double [9];

    dparms[0] = mu;
    dparms[1] = delta_p;
    dparms[2] = density;
    dparms[3] = wup;
    dparms[4] = t;
    dparms[5] = mfn;
    dparms[6] = mfn_1;
    dparms[7] = lupn_1;
    dparms[8] = condensate;

    int *iparms = NULL;

    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << "Updraft conversion iteration starts" << '\n';
    }
int error = numerical_schemes_bisection_method(MAX_ITERATION_GGP_CALCULATION,0.,(mfn_1*lupn_1-delta_p*condensate/meteorology_g0)/mfn,0,DEFAULT_GGP_CALCULATION_ACCURACY,dparms,iparms,ec_updraft_conversion_funct,outl);
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << "Updraft conversion iteration ends" << '\n';
    }
    /*
    for(i=0;i<MAX_ITERATION_GGP_CALCULATION;i++){ //
      templ = ((2*meteorology_g0 + mu*delta_p)*mfn_1*lupn_1 - 2.*condensate*delta_p + 2*meteorology_convective_scheme_ec_cal_updraft_ggp(mfn,density,wup,t,outl,false)*delta_p)/(2*meteorology_g0 - mu*delta_p);
      cout << i << " " << outl << " " << templ << endl;

      if((fabs(templ-outl)/(outl+templ)) < DEFAULT_GGP_CALCULATION_ACCURACY){
	lupn = templ;
	ggp = meteorology_convective_scheme_ec_cal_updraft_ggp(mfn,density,wup,t,lupn,false);
	return _ERRORCODE_NOERROR;
      }

      outl = templ;
    }
    */
    if(error == _ERRORCODE_NOERROR){
      lupn = outl;
      ggp = meteorology_convective_scheme_ec_cal_updraft_ggp(mfn,density,wup,t,lupn,false);
    }
    delete [] dparms;

    return error;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_updraft_fallout(double mu,double delta_p,double t,double mfn,double mfn_1,double updraft_ken,double updraft_ken_1,double lupn,double lupn_1,double &rupn,double rupn_1,double ggp,double &sfall){
    int i;

    double alpha = meteorology_convective_cal_ice_ratio(t);
    double vn;
    double wup = pow(updraft_ken + updraft_ken_1,0.5);

    double outr;
    outr = rupn_1;

    double *dparms = new double [9];

    dparms[0] = mu;
    dparms[1] = delta_p;
    dparms[2] = wup;
    dparms[3] = t;
    dparms[4] = mfn;
    dparms[5] = mfn_1;
    dparms[6] = rupn_1;
    dparms[7] = ggp;
    dparms[8] = alpha;

    int *iparms = NULL;
   
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << "Updraft fallout iteration starts" << '\n';
    }

    int error = numerical_schemes_bisection_method(MAX_ITERATION_FALLOUT_CALCULATION,0.,(mfn_1*rupn_1-delta_p*ggp/meteorology_g0)/mfn,0,DEFAULT_FALLOUT_CALCULATION_ACCURACY,dparms,iparms,ec_updraft_fallout_funct,outr);
    /*
    for(i=0;i<MAX_ITERATION_FALLOUT_CALCULATION;i++){
      vn = 21.18*pow(outr,0.2)*alpha + (1-alpha)*21.18*pow(outr,0.2)*0.5;
      fallout = meteorology_g0*mfn*vn*outr/(wup*fabs(delta_p));

      tempr = ((2*meteorology_g0 + mu*delta_p)*mfn_1*rupn_1 - 2.*ggp*delta_p + 2*delta_p*fallout)/(2*meteorology_g0 - mu*delta_p);
      if(libjeff::debug_setting::get_debug_mode_debug_log()){
	libjeff::debug_log log;
	log << i << " " << vn << " " << fallout << " " << tempr << " " << outr << '\n';
      }
      
      if(tempr >= 0. && ((tempr < 0.1*DEFAULT_FALLOUT_CALCULATION_ACCURACY && outr < 0.1*DEFAULT_FALLOUT_CALCULATION_ACCURACY) || (fabs(tempr-outr)/(outr+tempr)) < DEFAULT_FALLOUT_CALCULATION_ACCURACY)){
	rupn = tempr;
	vn = 21.18*pow(rupn,0.2)*alpha + (1-alpha)*21.18*pow(rupn,0.2)*0.5;
	sfall = meteorology_g0*mfn*vn*rupn/(wup*fabs(delta_p));
	return _ERRORCODE_NOERROR;
      }

      outr = tempr;
    }
    */
    if(libjeff::debug_setting::get_debug_mode_debug_log()){
      libjeff::debug_log log;
      log << "Updraft fallout iteration ends" << '\n';
    }
    
    if(error == _ERRORCODE_NOERROR){
      rupn = outr;
      vn = 21.18*pow(rupn,0.2)*alpha + (1-alpha)*21.18*pow(rupn,0.2)*0.5;
      sfall = meteorology_convective_scheme_ec_cal_updraft_sfall(mfn,vn,rupn,wup,delta_p);
    }
    delete [] dparms;

    if(error == _ERRORCODE_NOERROR && !(rupn >= 0.)){
      error = _ERRORCODE_ITERATIONSFAILEDTOCONVERGE;
    }

    return error;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_shallow_updraft_column(int xindex,int yindex,int departing_level,double factor,const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,const grid_data_field* z,double cloud_base_mf,double *updraft_ke,double *parcel_s,double *parcel_q,double *parcel_qc,double *parcel_qr){
    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_deep_updraft_column(int xindex,int yindex,int cloud_base_level,double factor,const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,const grid_data_field* z,double cloud_base_mf,double *updraft_ke,double *parcel_s,double *parcel_q,double *parcel_qc,double *parcel_qr,double *out_fallout){
    int k,i,j;

    double env_s, epsilon, mu, density, parcel_t, parcel_t1, env_tv, parcel_tv, mf, mf_down, parcel_rh;
    double fscale, rh, adj_q;
    double delta_p, delta_z;
    double condensate, ggp, fallout;
    double dtemp;
//double mean_env_t, mean_env_q;
//double mean_t, mean_q;
    int error = _ERRORCODE_NOERROR, temp_error;
    mf = cloud_base_mf;
    for(k=cloud_base_level+1;k<p->get_nz();k++){
      mf_down = mf;
      fscale = pow(0.5*(meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k))) +
			meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1))))
		   /meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,cloud_base_level)),*(t->get_data(xindex,yindex,cloud_base_level)),*(t->get_data(xindex,yindex,cloud_base_level))),3.);
      if(fscale > 1.){
	fscale = 1.;
      }
      //rh = 0.5*(*(q->get_data(xindex,yindex,k))/meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k)),*(t->get_data(xindex,yindex,k))) + *(q->get_data(xindex,yindex,k-1))/meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1)),*(t->get_data(xindex,yindex,k-1))));
      rh = (0.5*(*(q->get_data(xindex,yindex,k)) + *(q->get_data(xindex,yindex,k-1))))/meteorology_cal_mixing_ratio(0.5*(*(p->get_data(xindex,yindex,k)) + *(p->get_data(xindex,yindex,k-1))),0.5*(*(t->get_data(xindex,yindex,k)) + *(t->get_data(xindex,yindex,k-1))),0.5*(*(t->get_data(xindex,yindex,k)) + *(t->get_data(xindex,yindex,k-1))));

      delta_z = (*(z->get_data(xindex,yindex,k))) - (*(z->get_data(xindex,yindex,k-1)));
      delta_p = ((*(p->get_data(xindex,yindex,k))) - (*(p->get_data(xindex,yindex,k-1))))*100.;

      //mean_env_t = 0.5*(*(t->get_data(xindex,yindex,k-1)) + *(t->get_data(xindex,yindex,k)));
      //mean_env_q = 0.5*(*(q->get_data(xindex,yindex,k-1)) + *(q->get_data(xindex,yindex,k)));

      env_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,t->get_data(xindex,yindex,k-1),q->get_data(xindex,yindex,k-1),NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,t->get_data(xindex,yindex,k),q->get_data(xindex,yindex,k),NULL,NULL,NULL));
      //env_tv = meteorology_cal_virtual_temperature(NULL,&mean_env_t,&mean_env_q,NULL,NULL,NULL);
      parcel_t1 = (parcel_s[k-1] - meteorology_g0*(*(z->get_data(xindex,yindex,k-1))))/meteorology_Cpd+1;
      parcel_t = parcel_t1;
      parcel_q[k] = parcel_q[k-1];

      const int num_iteration = 4;

      for(i=0;i<num_iteration;i++){
	//mean_t = 0.5*(parcel_t1 + parcel_t);
	//mean_q = 0.5*(parcel_q[k-1] + parcel_q[k]);
	parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[k-1],NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[k],NULL,NULL,NULL));
	//parcel_tv = meteorology_cal_virtual_temperature(NULL,&mean_t,&mean_q,NULL,NULL,NULL);
	parcel_rh = parcel_q[k-1]/meteorology_cal_saturated_mixing_ratio(*(p->get_data(xindex,yindex,k-1)),parcel_t1); //for diagnostic, no use in calculation

      //first quess for updraft KE. Used for calculating detrainment. Need to refine later
	updraft_ke[k] = ((1. - 1.75e-3 *factor*delta_z*(1.3 - rh)*fscale*(1. + 1.875*0.506))*updraft_ke[k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + 1.75e-3 *factor*delta_z*(1.3 - rh)*fscale*(1. + 1.875*0.506));
	//updraft_ke[k] += updraft_ke[k-1];
	//updraft_ke[k] *= 0.5;
	//updraft_ke[k] = updraft_ke[k-1];
	/*
	if(updraft_ke[k] < 0 && i==0){
	  parcel_t = parcel_t1 + 2.;
	  parcel_q[k] = meteorology_cal_mixing_ratio(*(p->get_data(xindex,yindex,k)),parcel_t,parcel_t);

	  parcel_tv = 0.5*(meteorology_cal_virtual_temperature(NULL,&parcel_t1,&parcel_q[k-1],NULL,NULL,NULL) + meteorology_cal_virtual_temperature(NULL,&parcel_t,&parcel_q[k],NULL,NULL,NULL));
	  //mean_t = 0.5*(parcel_t1 + parcel_t);
	  //mean_q = 0.5*(parcel_q[k-1] + parcel_q[k]);
	  //parcel_tv = meteorology_cal_virtual_temperature(NULL,&mean_t,&mean_q,NULL,NULL,NULL);
	  parcel_rh = parcel_q[k-1]/meteorology_cal_saturated_mixing_ratio(*(p->get_data(xindex,yindex,k-1)),parcel_t1);
	  
	  updraft_ke[k] = ((1. - 1.75e-3 *factor*delta_z*(1.3 - rh)*fscale*(1. + 1.875*0.506))*updraft_ke[k-1] + delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)))/(1. + 1.75e-3 *factor*delta_z*(1.3 - rh)*fscale*(1. + 1.875*0.506));
	}
	*/
	//std::cout << "Updraft KE: " << i << " " << updraft_ke[k] << endl;
	/*
	if(i==num_iteration-1 || updraft_ke[k] < 0){
	  if(k==cloud_base_level+1){
	    std::cout << xindex << " " << yindex << " " << k-1 << " " << updraft_ke[k-1] << " " << *(p->get_data(xindex,yindex,k-1)) << " " << parcel_t1 << " " << parcel_q[k-1] << " " << parcel_tv << " " << *(t->get_data(xindex,yindex,k-1)) << " " << *(q->get_data(xindex,yindex,k-1)) << " " << env_tv << endl;
	  }
	  std::cout << xindex << " " << yindex << " " << k << " " << updraft_ke[k] << " " << *(p->get_data(xindex,yindex,k)) << " " << parcel_t << " " << parcel_q[k] << " " << parcel_tv << " " << *(t->get_data(xindex,yindex,k)) << " " << *(q->get_data(xindex,yindex,k)) << " " << env_tv << " " << env_s << " " << fscale << " " << delta_z << endl;
	}
	*/
	if(updraft_ke[k] > 0){//second iteration for more accurate computation
	  env_s = 0.5*((*(t->get_data(xindex,yindex,k)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(xindex,yindex,k))) + (*(t->get_data(xindex,yindex,k-1)))*meteorology_Cpd +meteorology_g0*(*(z->get_data(xindex,yindex,k-1)))); 

	  density = 0.5*(meteorology_cal_density((*(t->get_data(xindex,yindex,k))),(*(p->get_data(xindex,yindex,k))),(*(q->get_data(xindex,yindex,k)))) + meteorology_cal_density((*(t->get_data(xindex,yindex,k-1))),(*(p->get_data(xindex,yindex,k-1))),(*(q->get_data(xindex,yindex,k-1)))));
	  if(libjeff::debug_setting::get_debug_mode_warning() && density <= 0){
	    std::cout << "Bug detected! Density <= 0. Density = " << density << " " << *(p->get_data(xindex,yindex,k)) << " " << *(t->get_data(xindex,yindex,k)) << " " << *(q->get_data(xindex,yindex,k)) << endl;
	  }
	  epsilon = 1.75e-3 *factor*(1.3 - rh)*fscale/density;
	  mu = 0.75e-4 *((1.6 - rh)/density);
	  if(updraft_ke[k] < updraft_ke[k-1]){
	    //dtemp = 0.75e-4 *((1 - (1.6 - rh)*pow(updraft_ke[k]/updraft_ke[k-1],0.5))/(density*delta_z));
	    //dtemp = (1-(1.6 - rh)*pow(updraft_ke[k]/updraft_ke[k-1],0.5))/(density*delta_z);
	    //dtemp = (1 - pow(updraft_ke[k]/updraft_ke[k-1],0.5));///density;
	    dtemp = (1.6 - rh)*(1. - pow(updraft_ke[k]/updraft_ke[k-1],0.5))/(density*delta_z);
	    if(dtemp > mu){
	      mu = dtemp;
	    }
	  }
	  if(libjeff::debug_setting::get_debug_mode_warning() && mu < 0){
	    std::cout << "Bug detected! Mu < 0. Mu = " << mu << " : " << rh << " " << density << " " << updraft_ke[k] << " " << updraft_ke[k-1] << " " << delta_z << endl;
	  }

	  mf = mf_down*(2*meteorology_g0 - (epsilon - mu)*delta_p)/(2*meteorology_g0 + (epsilon - mu)*delta_p);
	  if(libjeff::debug_setting::get_debug_mode_warning() && mf < 0){
	    std::cout << "Bug detected! Mass flux < 0 when KE > 0: mf = " << mf << " " << mf_down << " " << epsilon << " " << mu << " " << delta_p << std::endl;
	  }

	//std::cout << mu << " " << density << " " << *(p->get_data(xindex,yindex,k)) << " " << *(t->get_data(xindex,yindex,k)) << " " << *(q->get_data(xindex,yindex,k)) << endl;
	  temp_error = meteorology_convective_scheme_ec_cal_updraft_condensate(epsilon,mu,delta_p,*(p->get_data(xindex,yindex,k)),env_s,0.5*(*(q->get_data(xindex,yindex,k)) + *(q->get_data(xindex,yindex,k-1))),mf,mf_down,*(z->get_data(xindex,yindex,k)),*(z->get_data(xindex,yindex,k-1)),parcel_s[k],parcel_s[k-1],parcel_q[k],parcel_q[k-1],adj_q);
	  if(temp_error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      std::cout << "Warning! Updraft condensation calculation failed to converge." << endl;
	      std::cout << cloud_base_level << " " << k << endl;
	      for(j=cloud_base_level;j<k;j++){
		std::cout << j << " " << *(p->get_data(xindex,yindex,j)) << " " << *(z->get_data(xindex,yindex,j)) << " " << *(t->get_data(xindex,yindex,j)) << " " << *(q->get_data(xindex,yindex,j)) << " " << parcel_s[j] << " " << parcel_q[j] << endl;
	      }
	    }
	    if(libjeff::debug_setting::get_debug_mode_debug_log()){
	      libjeff::debug_log log;
	      std::cout << log;
	      std::cout.flush();
	    }
	    error = temp_error;
	  }
	  else{
	    if(libjeff::debug_setting::get_debug_mode_debug_log()){
	      libjeff::debug_log log;
	      log.clear();
	    }
	  }
	  condensate = meteorology_g0*mf*(parcel_q[k] - adj_q)/fabs(delta_p);
	
	  parcel_t = (parcel_s[k] - meteorology_g0*(*(z->get_data(xindex,yindex,k))))/meteorology_Cpd;
	}
	else{
	  if(libjeff::debug_setting::get_debug_mode_warning() && i==0 && k==cloud_base_level+1){
	    std::cout << "Updraft KE < 0 in first iteration just above cloud base. No way to update the parcel virtual temperature" << endl;
	    std::cout << "Parcel Tv: " << parcel_tv << " Parcel RH: " << parcel_rh << " Environment Tv: " << env_tv << endl;
	    std::cout << "Parcel T: " << parcel_t1 << " Parcel Q: " << parcel_q[k-1] << " Env T: " << *(t->get_data(xindex,yindex,k-1)) << " Env Q: " << *(q->get_data(xindex,yindex,k-1)) << endl;
	    std::cout << "Inertial term: " << updraft_ke[k-1] << " Damping term: " << - 1.75e-3 *factor*delta_z*(1.3 - rh)*fscale*(1. + 1.875*0.506)*updraft_ke[k-1] << " Forcing term: " << delta_z*(parcel_tv - env_tv)*meteorology_g0/(env_tv*2.*(1+0.5)) << endl;
	  }
	  break;
	}
      }

      if(updraft_ke[k] > 0){
	temp_error = meteorology_convective_scheme_ec_cal_updraft_conversion(mu,delta_p,density,parcel_t,mf,mf_down,*(z->get_data(xindex,yindex,k)),*(z->get_data(xindex,yindex,k-1)),updraft_ke[k],updraft_ke[k-1],parcel_q[k],parcel_q[k-1],parcel_qc[k],parcel_qc[k-1],condensate,ggp);
	if(temp_error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
	  if(libjeff::debug_setting::get_debug_mode_warning()){
	    std::cout << "Warning! Updraft conversion calculation failed to converge." << endl;
	  }
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	  }
	  error = temp_error;
	}
	else if(libjeff::debug_setting::get_debug_mode_warning() && temp_error == _ERRORCODE_WRONGINPUTSFORITERATION){
	  std::cout << "Error! Bounds of the iterations do not enclose the solution." << endl;
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	  }
	}
	else{
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    log.clear();
	  }
	}
	
	temp_error = meteorology_convective_scheme_ec_cal_updraft_fallout(mu,delta_p,parcel_t,mf,mf_down,updraft_ke[k],updraft_ke[k-1],parcel_qc[k],parcel_qc[k-1],parcel_qr[k],parcel_qr[k-1],ggp,fallout);
	if(temp_error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
	  if(libjeff::debug_setting::get_debug_mode_warning()){
	    std::cout << "Warning! Updraft fallout calculation failed to converge." << endl;
	  }
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	  }
	  error = temp_error;
	}
	else if(parcel_qr[k] < 0){
	  if(libjeff::debug_setting::get_debug_mode_warning()){
	    std::cout << "Warning! Updraft fallout calculation converged to a neagtive value." << endl;
	  }
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	  }
	}
	/*
	else if(libjeff::debug_setting::get_debug_mode_warning() && temp_error == _ERRORCODE_WRONGINPUTSFORITERATION){
	  std::cout << "Error! Bounds of the iterations do not enclose the solution." << endl;
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    std::cout << log;
	    std::cout.flush();
	  }
	}
	*/
	else{
	  if(libjeff::debug_setting::get_debug_mode_debug_log()){
	    libjeff::debug_log log;
	    log.clear();
	  }
	}
	out_fallout[k] = fallout;
      }
      else{
	break;
      }
    }

    return error;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_conv_type(const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,const grid_data_field* z,const grid_data_field* sshf,const grid_data_field* slhf,const grid_data_field* blh,int *conv_type,int *cloud_base_level,int *cloud_top_level,double *cloud_base_w,double *cloud_base_s,double *cloud_base_q,double *cloud_base_qc,bool gpu_mode){ //0 for no convection, 1 for shallow, 2 for deep and 3 for mid-level
    double *conv_scale_w, *density;
    double *delta_t, *delta_q;

    double *updraft_ke,*parcel_s,*parcel_q,*parcel_t,*parcel_qc,*parcel_qr;

    int i,j,k,m,error;
    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	conv_type[i*p->get_ny()+j] = 0;
      }
    }
    
    if(gpu_mode){
      ###CUDA###{
        size_t free, total;
	cudaMemGetInfo(&free,&total);

	int nbatchx, nbatchy;
	error = determine_nbatchxy(nbatchx,nbatchy,p->get_nx(),p->get_ny(),0,0,((8.*p->get_nx())*p->get_ny()*p->get_nz()*(10) + 8.*(p->get_nx())*p->get_ny()*(11) + 4.*(p->get_nx())*p->get_ny()*5)*1.2); // memory ~ nx * ny *nz * 8 (num bytes of double) * (10 3D variables) + nx * ny * 8 * 11(surface variables) + nx * ny * 8 * 3(cloud type/levels + mask) + 20% contingency

	if(error){
	  return error;
	}

	int batchx_index,batchy_index;
	int batchx_size,batchy_size;
	batchx_size = p->get_nx()/nbatchx;
	batchy_size = p->get_ny()/nbatchy;

	if(libjeff::debug_setting::get_debug_mode_debug_message()){
	  std::cout << "Batch size: " << batchx_size << " X " << batchy_size << std::endl;
	}
      
        cudaMalloc(&density,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&conv_scale_w,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&delta_t,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&delta_q,batchx_size*batchy_size*sizeof(double));

	int numthreads = cuda_setting::get_numthreads();
	dim3 grid;

	double *temperature,*pressure,*qvapor,*gph;
	double *boundarylh,*sensiblehf,*latenthf;
	temperature = new double [batchx_size*batchy_size*p->get_nz()];
	pressure = new double [batchx_size*batchy_size*p->get_nz()];
	qvapor = new double [batchx_size*batchy_size*p->get_nz()];
	gph = new double [batchx_size*batchy_size*p->get_nz()];

	boundarylh = new double [batchx_size*batchy_size];
	sensiblehf = new double [batchx_size*batchy_size];
	latenthf = new double [batchx_size*batchy_size];

	double *d_temperature, *d_pressure, *d_qvapor,*d_gph;
	cudaMalloc(&d_temperature,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&d_pressure,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&d_qvapor,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&d_gph,batchx_size*batchy_size*p->get_nz()*sizeof(double));

	double *d_sshf,*d_blh,*d_slhf;
	cudaMalloc(&d_sshf,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&d_blh,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&d_slhf,batchx_size*batchy_size*sizeof(double));

	cudaMalloc(&updraft_ke,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&parcel_s,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&parcel_q,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&parcel_t,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&parcel_qc,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	cudaMalloc(&parcel_qr,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	
	int *d_cloud_base_level, *d_cloud_top_level, *d_conv_type;
	cudaMalloc(&d_cloud_base_level,batchx_size*batchy_size*sizeof(int));
	cudaMalloc(&d_cloud_top_level,batchx_size*batchy_size*sizeof(int));
	cudaMalloc(&d_conv_type,batchx_size*batchy_size*sizeof(int));

	double *d_cloud_base_w, *d_cloud_base_s, *d_cloud_base_q, *d_cloud_base_qc;
	cudaMalloc(&d_cloud_base_w,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&d_cloud_base_s,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&d_cloud_base_q,batchx_size*batchy_size*sizeof(double));
	cudaMalloc(&d_cloud_base_qc,batchx_size*batchy_size*sizeof(double));

	int *p_mask,*found_mask;
	cudaMalloc(&p_mask,batchx_size*batchy_size*sizeof(int));
	cudaMalloc(&found_mask,batchx_size*batchy_size*sizeof(int));

	for(batchy_index=0;batchy_index<nbatchy;batchy_index++){
	  for(batchx_index=0;batchx_index<nbatchx;batchx_index++){
	    grid.x = (int) ceil(((double) (batchx_size)*(batchy_size))/numthreads);
	    if(libjeff::debug_setting::get_debug_mode_debug_message()){
	      std::cout << "CUDA Kernel configuration: " << grid.x << " X " << numthreads << std::endl;
	    }
	    //shallow convection

	    t->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",temperature);
	    p->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",pressure);
	    q->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",qvapor);
	    z->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",gph);

	    cudaMemcpy(d_temperature,temperature,batchx_size*batchy_size*p->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(d_pressure,pressure,batchx_size*batchy_size*p->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(d_qvapor,qvapor,batchx_size*batchy_size*p->get_nz()*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(d_gph,gph,batchx_size*batchy_size*p->get_nz()*sizeof(double),cudaMemcpyHostToDevice);

	    sshf->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",sensiblehf);
	    slhf->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",latenthf);
	    blh->get_in_batch(nbatchx,nbatchy,1,batchx_index,batchy_index,0,0,0,0,"data",boundarylh);

	    cudaMemcpy(d_sshf,sensiblehf,batchx_size*batchy_size*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(d_slhf,latenthf,batchx_size*batchy_size*sizeof(double),cudaMemcpyHostToDevice);
	    cudaMemcpy(d_blh,boundarylh,batchx_size*batchy_size*sizeof(double),cudaMemcpyHostToDevice);
	    
	    meteorology_convective_scheme_ec_cal_layer_density<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_temperature,d_pressure,d_qvapor,0,density);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_layer_density@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    meteorology_convective_scheme_ec_cal_conv_scale_w<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_blh,d_sshf,d_slhf,d_temperature,density,0,conv_scale_w);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_conv_scale_w@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    meteorology_convective_scheme_ec_cal_delta_t<<<grid,numthreads>>>(batchx_size*batchy_size,d_sshf,density,conv_scale_w,delta_t);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_delta_t@shallow_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
	    meteorology_convective_scheme_ec_cal_delta_q<<<grid,numthreads>>>(batchx_size*batchy_size,d_slhf,density,conv_scale_w,delta_q);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_delta_q@shallow_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
								 
	    cudaMemset(updraft_ke,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_s,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_q,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_t,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));

	    meteorology_convective_scheme_ec_shallow_set_updraft_ke<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),conv_scale_w,updraft_ke);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_shallow_set_updraft_ke@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
	    meteorology_convective_scheme_ec_shallow_set_parcel_s<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_temperature,delta_t,d_gph,parcel_s);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_shallow_set_parcel_s@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
	    meteorology_convective_scheme_ec_shallow_set_parcel_q<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_qvapor,delta_q,parcel_q);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_shallow_set_parcel_q@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
	    
	    meteorology_convective_scheme_ec_simplified_shallow_entrainment_gpu(batchx_size*batchy_size,p->get_nz(),d_pressure,d_temperature,d_qvapor,d_gph,updraft_ke,parcel_s,parcel_q);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_simplified_shallow_entrainment_gpu@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    grid.x = (int) ceil(((double) (batchx_size)*(batchy_size)*p->get_nz())/numthreads);
	    meteorology_convective_scheme_ec_cal_parcel_t<<<grid,numthreads>>>(batchx_size*batchy_size*p->get_nz(),parcel_s,d_gph,updraft_ke,parcel_t);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_parcel_t@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    grid.x = (int) ceil(((double) (batchx_size)*(batchy_size))/numthreads);
	    meteorology_convective_scheme_ec_find_cloudbase<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_pressure,parcel_t,parcel_q,updraft_ke,d_cloud_base_level);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_find_cloudbase@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }
	    meteorology_convective_scheme_ec_find_cloudtop<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),updraft_ke,d_cloud_base_level,d_cloud_top_level);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_find_cloudtop@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    meteorology_convective_scheme_ec_check_shallow_conv_type<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_pressure,updraft_ke,parcel_t,parcel_q,d_gph,d_cloud_base_level,d_cloud_top_level,d_cloud_base_w,d_cloud_base_s,d_cloud_base_q,d_cloud_base_qc,d_conv_type);
	    if(libjeff::debug_setting::get_debug_mode_warning()){
	      if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_check_shallow_conv_type@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
	    }

	    //deep convection
	    cudaMemset(updraft_ke,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_s,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_q,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	    cudaMemset(parcel_t,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));

	    cudaMemset(p_mask,0,batchx_size*batchy_size*sizeof(int));
	    cudaMemset(found_mask,0,batchx_size*batchy_size*sizeof(int));
	    for(k=1;k<p->get_nz();k++){ //departure level
	      meteorology_convective_scheme_ec_deep_set_p_mask<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_pressure,k,p_mask);
	      
	      meteorology_convective_scheme_ec_cal_layer_density<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_temperature,d_pressure,d_qvapor,k,density);
	      if(k==1){
		meteorology_convective_scheme_ec_cal_conv_scale_w<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_blh,d_sshf,d_slhf,d_temperature,density,k,conv_scale_w);
		meteorology_convective_scheme_ec_cal_delta_t<<<grid,numthreads>>>(batchx_size*batchy_size,d_sshf,density,conv_scale_w,delta_t);
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_delta_t@deep_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
		}
		meteorology_convective_scheme_ec_cal_delta_q<<<grid,numthreads>>>(batchx_size*batchy_size,d_slhf,density,conv_scale_w,delta_q);
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_cal_delta_q@deep_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
		}
	      }
	      else{
		meteorology_convective_scheme_ec_deep_set_delta_t<<<grid,numthreads>>>(batchx_size*batchy_size,delta_t);
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_deep_set_delta_t@deep_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
		}
		meteorology_convective_scheme_ec_deep_set_delta_q<<<grid,numthreads>>>(batchx_size*batchy_size,delta_q);
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  if ( cudaSuccess != cudaPeekAtLastError() ) cout << "Failed. " << cudaGetErrorString(cudaGetLastError()) << "@meteorology_convective_scheme_ec_deep_set_delta_q@deep_convection@meteorology_convective_scheme_ec_cal_conv_type@meteorology" << std::endl;
		}
	      }
	      
	      meteorology_convective_scheme_ec_deep_set_updraft_ke<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),density,updraft_ke);
	      
	      meteorology_convective_scheme_ec_deep_set_parcel_s<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_pressure,d_temperature,d_gph,delta_t,k,parcel_s);
	      meteorology_convective_scheme_ec_deep_set_parcel_q<<<grid,numthreads>>>(batchx_size*batchy_size,p->get_nz(),d_pressure,d_qvapor,delta_q,k,parcel_q);
	      cudaMemset(parcel_qc,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));
	      cudaMemset(parcel_qr,0,batchx_size*batchy_size*p->get_nz()*sizeof(double));

	    }
	  }
	}
	delete [] temperature;
	delete [] pressure;
	delete [] qvapor;
	delete [] gph;

	delete [] boundarylh;
	delete [] sensiblehf;
	delete [] latenthf;

	cudaFree(d_sshf);
	cudaFree(d_blh);
	cudaFree(d_slhf);

	cudaFree(d_temperature);
	cudaFree(d_pressure);
	cudaFree(d_qvapor);
	cudaFree(d_gph);
	
	cudaFree(density);
	cudaFree(conv_scale_w);
	cudaFree(delta_t);
	cudaFree(delta_q);

	cudaFree(updraft_ke);
	cudaFree(parcel_s);
	cudaFree(parcel_q);
	cudaFree(parcel_t);
	cudaFree(parcel_qc);
	cudaFree(parcel_qr);

	cudaFree(d_cloud_base_w);
	cudaFree(d_cloud_base_s);
	cudaFree(d_cloud_base_q);
	cudaFree(d_cloud_base_qc);

	cudaFree(p_mask);
	cudaFree(found_mask);
      }
    }
    else{
      int ij,ijk;
      
      density = new double [p->get_nx()*p->get_ny()];
      conv_scale_w = new double [p->get_nx()*p->get_ny()];

      delta_t = new double [p->get_nx()*p->get_ny()];
      delta_q = new double [p->get_nx()*p->get_ny()];
      
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  ij = i*p->get_ny()+j;
	  density[ij] = meteorology_cal_density(*(t->get_data(i,j,0)),*(p->get_data(i,j,0)),*(q->get_data(i,j,0)));
	  conv_scale_w[ij] = 1.2*cbrt(u_asterisk_cube - 1.5*kapper*meteorology_g0*(*(blh->get_data(i,j,0)))*((*(sshf->get_data(i,j,0)))/meteorology_Cpd + 0.61*(*(slhf->get_data(i,j,0)))*(*(t->get_data(i,j,0)))/meteorology_Lv)/(density[ij]*(*(t->get_data(i,j,0)))));
	}
      }
      /*
	std::ofstream fout;
	fout.open("density.out");
	for(i=0;i<p->get_ny();i++){
	for(j=0;j<p->get_nx();j++){
	fout << density[j*p->get_ny()+i] << " ";
	}
	fout << endl;
	}
	fout.close();
	fout.open("conv_scale_w.out");
	for(i=0;i<p->get_ny();i++){
	for(j=0;j<p->get_nx();j++){
	fout << conv_scale_w[j*p->get_ny()+i] << " ";
	}
	fout << endl;
	}
	fout.close();
      */
      //shallow convection 
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  ij = i*p->get_ny()+j;
	  delta_t[ij] = -1.5*(*(sshf->get_data(i,j,0)))/(meteorology_Cpd*density[ij]*conv_scale_w[ij]);
	  if(delta_t[ij] > 3){
	    delta_t[ij] = 3.;
	  }
	  delta_q[ij] = 1.5*(*(slhf->get_data(i,j,0)))/(meteorology_Lv*density[ij]*conv_scale_w[ij]);
	  if(delta_q[ij] > 2e-3){
	    delta_q[ij] = 2e-3;
	  }
	}
      }
      
      /*
	fout.open("shallow.delta_t.out");
	for(i=0;i<p->get_ny();i++){
	for(j=0;j<p->get_nx();j++){
	fout << delta_t[j*p->get_ny()+i] << " ";
	}
	fout << endl;
	}
	fout.close();
	fout.open("shallow.delta_q.out");
	for(i=0;i<p->get_ny();i++){
	for(j=0;j<p->get_nx();j++){
	fout << delta_q[j*p->get_ny()+i] << " ";
	}
	fout << endl;
	}
	fout.close();
      */
      updraft_ke = new double [p->get_nx()*p->get_ny()*p->get_nz()];
      parcel_s = new double [p->get_nx()*p->get_ny()*p->get_nz()];
      parcel_q = new double [p->get_nx()*p->get_ny()*p->get_nz()];
      parcel_t = new double [p->get_nx()*p->get_ny()*p->get_nz()];
      
      for(i=0;i<p->get_nx()*p->get_ny()*p->get_nz();i++){
	parcel_s[i] = 0.;
	parcel_q[i] = 0.;
	parcel_t[i] = 0.;
	updraft_ke[i] = -1.;
      }
      
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  ij = i*p->get_ny()+j;
	  updraft_ke[(ij)*p->get_nz()] = 0.5*conv_scale_w[ij]*conv_scale_w[ij];
	  parcel_s[(ij)*p->get_nz()] = ((*(t->get_data(i,j,0))) + delta_t[ij])*meteorology_Cpd + meteorology_g0*(*(z->get_data(i,j,0)));
	  parcel_q[(ij)*p->get_nz()] = (*(q->get_data(i,j,0))) + delta_q[ij];
	  if(parcel_q[(ij)*p->get_nz()] < 0){
	    parcel_q[(ij)*p->get_nz()] = 0;
	  }
	}
      }
      
      //shallow convection test
      //std::cout << "Going to calculate shallow entrainment process" << endl;
      meteorology_convective_scheme_ec_simplified_shallow_entrainment(p,t,q,z,updraft_ke,parcel_s,parcel_q);
      //std::cout << "Done calculating shallow entrainment process" << endl;
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  ij = i*p->get_ny()+j;
	  for(k=0;k<p->get_nz();k++){
	    ijk = ij*p->get_nz()+k;
	    parcel_t[ijk] = (parcel_s[ijk] - meteorology_g0*(*(z->get_data(i,j,k))))/meteorology_Cpd;
	    
	    if(updraft_ke[ijk] < 0){
	      break;
	    }
	  }
	}
      }
      
      int count = 0;
      double cloud_base, cloud_top;
      bool cloud_base_found;
      double conv_t,conv_q,conv_c;
      int lcl_level;
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  ij = i*p->get_ny()+j;
	  cloud_base_found = false;
	  cloud_top = 2000.;
	  for(k=0;k<p->get_nz();k++){
	    ijk = ij*p->get_nz()+k;
	    if(!cloud_base_found && updraft_ke[ijk] >= 0){
	      if(meteorology_cal_mixing_ratio((*(p->get_data(i,j,k))),parcel_t[ijk],parcel_t[ijk]) <= parcel_q[ijk]){
		cloud_base_found = true;
		cloud_base = (*(p->get_data(i,j,k)));
		lcl_level = k;
	      }
	    }
	    else if(!cloud_base_found && updraft_ke[ijk] < 0){
	      break;
	    }
	    else if(cloud_base_found && updraft_ke[ijk] < 0){
	      cloud_top = (*(p->get_data(i,j,k)));
	      cloud_top_level[ij] = k;
	      break;
	    }
	  }
	  
	  if(cloud_base_found){
	    if(cloud_top == 2000.){
	      if(libjeff::debug_setting::get_debug_mode_warning()){
		std::cout << count++ << " Error! Cloud base found but cloud top not found. " << cloud_base << " " << (updraft_ke[ij*p->get_nz()+p->get_nz()-1] > updraft_ke[ij*p->get_nz()+p->get_nz()-3]?"Updraft KE increasing towards model top":"Strong overshot") << endl;
	      }
	    }
	    //out_cloud_base[i*p->get_ny()+j] = cloud_top; //cloud_base;
	    if(cloud_base - cloud_top <= 200.){
	      conv_type[ij] = 1;
	      cloud_base_level[ij] = lcl_level;
	      cloud_base_w[ij] = pow(2.*updraft_ke[(ij)*p->get_nz()+lcl_level],0.5);
	      conv_t = parcel_t[(ij)*p->get_nz()+lcl_level];
	      conv_q = parcel_q[(ij)*p->get_nz()+lcl_level];
	      if(conv_t <= 0 || conv_q <= 0){
		std::cout << "Bug! Negative temperature/qvapor: " << endl;
		std::cout << "LCL: " << lcl_level << endl;
		for(k=0;k<p->get_nz();k++){
		  std::cout << parcel_s[(ij)*p->get_nz()+k] << '\t';
		}
		std::cout << endl;
		for(k=0;k<p->get_nz();k++){
		  std::cout << parcel_t[(ij)*p->get_nz()+k] << '\t';
		}
		std::cout << endl;
		for(k=0;k<p->get_nz();k++){
		  std::cout << parcel_q[(ij)*p->get_nz()+k] << '\t';
		}
		std::cout << endl;
	      }
	      error = meteorology_cal_saturation_adjustment(*(p->get_data(i,j,lcl_level)),conv_t,conv_q,conv_c);
	      if(error == _ERRORCODE_ITERATIONSFAILEDTOCONVERGE){
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  std::cout << "Warning! Saturation adjustment failed to converge in cloud base calculation." << endl;
		}
		if(libjeff::debug_setting::get_debug_mode_debug_log()){
		  libjeff::debug_log log;
		  std::cout << log;
		  std::cout.flush();
		  log.clear();
		}
	      }
	      else{
		if(libjeff::debug_setting::get_debug_mode_debug_log()){
		  libjeff::debug_log log;
		  log.clear();
		}
	      }
	      cloud_base_s[ij] = conv_t*meteorology_Cpd + meteorology_g0*(*(z->get_data(i,j,lcl_level)));
	      cloud_base_q[ij] = conv_q;
	      cloud_base_qc[ij] = conv_c;
	    }
	  }
	}
      }
      delete [] parcel_t;
      delete [] parcel_s;
      delete [] parcel_q;
      delete [] updraft_ke;
      
      delete [] conv_scale_w;
      delete [] density;

//std::cout << "Preparing for deep convection calculation." << endl;
      double temp_s, temp_q;

    //deep convection
      updraft_ke = new double [p->get_nz()];
      parcel_s = new double [p->get_nz()];
      parcel_q = new double [p->get_nz()];
      parcel_t = new double [p->get_nz()];
      parcel_qc = new double [p->get_nz()];
      parcel_qr = new double [p->get_nz()];
      for(i=0;i<p->get_nx();i++){
	for(j=0;j<p->get_ny();j++){
	  //std::cout << " i x j: " << i << " x " << j << endl;
	  double density, conv_scale_w;
	  ij = i*p->get_ny()+j;
	  for(k=1;k<p->get_nz();k++){
	    for(m=k;m<p->get_nz();m++){
	      updraft_ke[m] = -1.;
	    }
	    //std::cout << " i x j x k: " << i << " x " << j << " x " << k << endl;
	    if(*(p->get_data(i,j,k))<*(p->get_data(i,j,0))-350){ //more than 350hPa away from ground, break
	      break;
	    }
	    
	    density = meteorology_cal_density(*(t->get_data(i,j,k)),*(p->get_data(i,j,k)),*(q->get_data(i,j,k)));
	    if(k==1){
	      conv_scale_w = 1.2*cbrt(u_asterisk_cube - 1.5*kapper*meteorology_g0*(*(blh->get_data(i,j,0)))*((*(sshf->get_data(i,j,0)))/meteorology_Cpd + 0.61*(*(slhf->get_data(i,j,0)))*(*(t->get_data(i,j,k)))/meteorology_Lv)/(density*(*(t->get_data(i,j,k)))));
	      
	      delta_t[ij] = -1.5*(*(sshf->get_data(i,j,0)))/(meteorology_Cpd*density*conv_scale_w);
	      if(delta_t[ij] > 3){
		delta_t[ij] = 3.;
	      }
	      delta_q[ij] = 1.5*(*(slhf->get_data(i,j,0)))/(meteorology_Lv*density*conv_scale_w);
	      if(delta_q[ij] > 2e-3){
		delta_q[ij] = 2e-3;
	      }
	    }
	    else{
	      delta_t[ij] = 0.2;
	      delta_q[ij] = 1.e-4;
	    }
	    
	    updraft_ke[k] = 0.5/(density*density); //set initial updraft velocity to 1 so KE = 0.5
	    if(*(p->get_data(i,j,k))>=*(p->get_data(i,j,0))-60){ //lowest 60hPa, need to do a 50hPa average 
	      temp_s = 0.;
	      temp_q = 0.;
	      count = 0;
	      for(m=0;m<p->get_nz();m++){
		if(fabs(*(p->get_data(i,j,k))-*(p->get_data(i,j,m))) <= 50./2){
		  temp_s += *(t->get_data(i,j,m))*meteorology_Cpd + meteorology_g0*(*(z->get_data(i,j,m)));
		  temp_q += *(q->get_data(i,j,m));
		  count ++;
		}
		else if(*(p->get_data(i,j,k))-*(p->get_data(i,j,m)) > 50./2){
		  break;
		}
	      }
	      temp_s /= count;
	      temp_q /= count;
	      
	      parcel_s[k] = temp_s + delta_t[ij]*meteorology_Cpd;
	      parcel_q[k] = temp_q + delta_q[ij];
	    }
	    else{ //just use grid value
	      parcel_s[k] = ((*(t->get_data(i,j,k))) + delta_t[ij])*meteorology_Cpd + meteorology_g0*(*(z->get_data(i,j,k)));
	      parcel_q[k] = (*(q->get_data(i,j,k))) + delta_q[ij];
	    }
	    parcel_qr[k] = 0.;
	    parcel_qc[k] = 0.;
	    
	    meteorology_convective_scheme_ec_simplified_deep_entrainment(i,j,k,p,t,q,qc,qr,z,updraft_ke,parcel_s,parcel_q,parcel_qc,parcel_qr,cloud_base_found,lcl_level);
	    
	    cloud_top = 2000.;
	    if(cloud_base_found){
	      cloud_base = (*(p->get_data(i,j,lcl_level)));
	      for(m=lcl_level;m<p->get_nz();m++){
		if(updraft_ke[m] < 0){
		  cloud_top = (*(p->get_data(i,j,m)));
		  cloud_top_level[ij] = m;
		  break;
		}
	      }
	      
	      if(cloud_base - cloud_top > 200.){
		conv_type[ij] = 2;
		//out_cloud_base[ij] = cloud_top;
		
		cloud_base_level[ij] = lcl_level;
		cloud_base_w[ij] = pow(2.*updraft_ke[lcl_level],0.5);
		cloud_base_s[ij] = parcel_s[lcl_level];
		cloud_base_q[ij] = parcel_q[lcl_level];
		cloud_base_qc[ij] = parcel_qc[lcl_level];
		break;
	      }
	      else if(cloud_top == 2000.){
		if(libjeff::debug_setting::get_debug_mode_warning()){
		  std::cout << "Warning! Unable to find cloud top." << endl;
		}
	      }
	    }
	  }
	}
      }
      
      delete [] parcel_t;
      delete [] parcel_s;
      delete [] parcel_q;
      delete [] parcel_qr;
      delete [] parcel_qc;
      delete [] updraft_ke;
      
      delete [] delta_t;
      delete [] delta_q;
    }
      
    //mid-level convection. To be implemented

    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_cbmf(const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* sshf,const grid_data_field* slhf,const grid_data_field *cbmf){


    return _ERRORCODE_NOERROR;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_updraft_calculation(const grid_data_field* p,const grid_data_field* z,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,int *conv_type,int *cloud_base_level,int *cloud_top_level,double *cloud_base_mf,double *cloud_base_w,double *cloud_base_s,double *cloud_base_q,double *cloud_base_qc,const grid_data_field* up_t,const grid_data_field* up_q,const grid_data_field* up_qc,const grid_data_field* up_qr,double* fallout){
    if(grid_data_field_check_grid_inconsistence(p,t) ||
       grid_data_field_check_grid_inconsistence(p,q) ||
       grid_data_field_check_grid_inconsistence(p,z) ||
       grid_data_field_check_grid_inconsistence(p,qc) ||
       grid_data_field_check_grid_inconsistence(p,qr) ||
       grid_data_field_check_grid_inconsistence(p,up_t) ||
       grid_data_field_check_grid_inconsistence(p,up_q) ||
       grid_data_field_check_grid_inconsistence(p,up_qc) ||
       grid_data_field_check_grid_inconsistence(p,up_qr)){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    int i,j,k,m, error = _ERRORCODE_NOERROR;
    int ij;
    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	for(k=0;k<p->get_nz();k++){
	  *(up_t->get_data(i,j,k)) = 0.;
	  *(up_q->get_data(i,j,k)) = 0.;
	  *(up_qc->get_data(i,j,k)) = 0.;
	  *(up_qr->get_data(i,j,k)) = 0.;
	}
      }
    }

    double *updraft_ke = new double [p->get_nz()];
    double *parcel_s = new double [p->get_nz()];
    double *parcel_q = new double [p->get_nz()];
    double *parcel_qc = new double [p->get_nz()];
    double *parcel_qr = new double [p->get_nz()];

    double factor, density;

    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	ij = i*p->get_ny()+j;
	if(conv_type[ij]!=0){
	  for(k=0;k<p->get_nz();k++){
	    updraft_ke[k] = -1.;
	    parcel_s[k] = 0.;
	    parcel_q[k] = 0.;
	    parcel_qc[k] = 0.;
	    parcel_qr[k] = 0.;
	    fallout[(ij)*p->get_nz()+k] = 0.;
	  }

	  density = meteorology_cal_density(*(t->get_data(i,j,cloud_base_level[ij])),
					    *(p->get_data(i,j,cloud_base_level[ij])),
					    *(q->get_data(i,j,cloud_base_level[ij])));
	  /*
	  + meteorology_cal_density(*(t->get_data(i,j,cloud_base_level[ij]+1)),
						 *(p->get_data(i,j,cloud_base_level[ij]+1)),
						 *(q->get_data(i,j,cloud_base_level[ij]+1))));
						 */
	  //updraft_ke[cloud_base_level[ij]] = 0.5*cloud_base_w[ij]*cloud_base_w[ij];
	  updraft_ke[cloud_base_level[ij]] = 0.5*cloud_base_w[ij]*cloud_base_w[ij]/(density*density);
	  parcel_s[cloud_base_level[ij]] = cloud_base_s[ij];
	  parcel_q[cloud_base_level[ij]] = cloud_base_q[ij];
	  parcel_qc[cloud_base_level[ij]] = cloud_base_qc[ij];
	  parcel_qr[cloud_base_level[ij]] = 0.;

	  factor = 2;
	  if(conv_type[ij]==2){ //deep convection
	    factor = 1;
	  }

	  if(conv_type[ij]==1){
	    //meteorology_convective_scheme_ec_shallow_updraft_column(i,j,cloud_base_level[ij],factor,p,t,q,qc,qr,z,cloud_base_mf[ij],updraft_ke,parcel_s,parcel_q,parcel_qc,parcel_qr);
	  }
	  else if(conv_type[ij]==2){
	    error = meteorology_convective_scheme_ec_deep_updraft_column(i,j,cloud_base_level[ij],factor,p,t,q,qc,qr,z,cloud_base_mf[ij],updraft_ke,parcel_s,parcel_q,parcel_qc,parcel_qr,fallout+(ij)*p->get_nz());
	    //error = meteorology_convective_scheme_ec_deep_downdraft_column(i,j,
	  }
	  else{
	    std::cout << "Error! Unknown convection type." << endl;
	  }

	  for(k=cloud_base_level[ij];k<p->get_nz();k++){
	    if(updraft_ke[k] < 0){
	      cloud_top_level[ij] = k;
	      break;
	    }
	  }
	  
	  for(k=cloud_base_level[ij];k<cloud_top_level[ij];k++){
	    *(up_t->get_data(i,j,k)) = (parcel_s[k] - meteorology_g0*(*(z->get_data(i,j,k))))/meteorology_Cpd;
	    *(up_q->get_data(i,j,k)) = parcel_q[k];
	    *(up_qc->get_data(i,j,k)) = parcel_qc[k];
	    *(up_qr->get_data(i,j,k)) = parcel_qr[k];
	    
	    //*(rainflux->get_data(i,j,k)) = fallout[k];
	  }
	}
      }
    }

    delete [] parcel_s;
    delete [] parcel_q;
    delete [] parcel_qr;
    delete [] parcel_qc;
    delete [] updraft_ke;

    return error;
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_downdraft_calculation(const grid_data_field* p,const grid_data_field* z,const grid_data_field* t,const grid_data_field* q,const grid_data_field* qc,const grid_data_field* qr,int *conv_type,int *cloud_base_level,int *cloud_top_level,double *cloud_base_mf,double *fallout,const grid_data_field* dn_t,const grid_data_field* dn_q,double *edown){
    if(grid_data_field_check_grid_inconsistence(p,t) ||
       grid_data_field_check_grid_inconsistence(p,q) ||
       grid_data_field_check_grid_inconsistence(p,z) ||
       grid_data_field_check_grid_inconsistence(p,qc) ||
       grid_data_field_check_grid_inconsistence(p,qr) ||
       grid_data_field_check_grid_inconsistence(p,dn_t) ||
       grid_data_field_check_grid_inconsistence(p,dn_q)){
      return _ERRORCODE_DATAINCONSISTENCE;
    }

    int i,j,k,m, error = _ERRORCODE_NOERROR;
    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	for(k=0;k<p->get_nz();k++){
	  *(dn_t->get_data(i,j,k)) = 0.;
	  *(dn_q->get_data(i,j,k)) = 0.;
	}
      }
    }

    double *parcel_s = new double [p->get_nz()];
    double *parcel_q = new double [p->get_nz()];

    double factor;

    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	if(conv_type[i*p->get_ny()+j]!=0){
	  for(k=0;k<p->get_nz();k++){
	    parcel_s[k] = 0.;
	    parcel_q[k] = 0.;
	    edown[(i*p->get_ny()+j)*p->get_nz()+k] = 0.;
	  }

	  factor = 2;
	  if(conv_type[i*p->get_ny()+j]==2){ //deep convection
	    factor = 1;
	  }

	  if(conv_type[i*p->get_ny()+j]==1){
	    //meteorology_convective_scheme_ec_shallow_updraft_column(i,j,cloud_base_level[i*p->get_ny()+j],factor,p,t,q,qc,qr,z,cloud_base_mf[i*p->get_ny()+j],updraft_ke,parcel_s,parcel_q,parcel_qc,parcel_qr);
	  }
	  else if(conv_type[i*p->get_ny()+j]==2){
	    //	    error = meteorology_convective_scheme_ec_deep_downdraft_column(i,j,cloud_base_level[i*p->get_ny()+j],cloud_top_level[i*p->get_ny()+j],factor,p,t,q,qc,qr,z,cloud_base_mf[i*p->get_ny()+j],parcel_s,parcel_q,parcel_qc,parcel_qr,edown+(i*p->get_ny()+j)*p->get_nz(),esubcld+(i*p->get_ny()+j)*p->get_nz());
	    //error = meteorology_convective_scheme_ec_deep_downdraft_column(i,j,
	  }
	  else{
	    std::cout << "Error! Unknown convection type." << endl;
	  }

	}
      }
    }

    delete [] parcel_s;
    delete [] parcel_q;

    return error;
  }
  ###CPP### ###CUDA### ###HOST### ###DEVICE### double cal_rainsnowflux_funct(double in,double *dparms,int *iparms){
    return in - dparms[2]*pow(0.5*(in+dparms[1]),26./45.) - dparms[0];
  }
  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_rainflux_calculation(const grid_data_field* p,const grid_data_field* t,const grid_data_field* q,const grid_data_field* up_t,int *conv_type,int *cloud_base_level,int *cloud_top_level,double *fallout,double *edown,const grid_data_field* rainflux,const grid_data_field* snowflux){
    int i,j,k,m, error = _ERRORCODE_NOERROR;

    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	for(k=0;k<p->get_nz();k++){
	  *(rainflux->get_data(i,j,k)) = 0.;
	  *(snowflux->get_data(i,j,k)) = 0.;
	}
      }
    }
    /*
    double *ratio, *melt, *twet, *esubcld, *qsat;
    ratio = new double [p->get_nz()];
    melt = new double [p->get_nz()];
    twet = new double [p->get_nz()];
    esubcld = new double [p->get_nz()];
    qsat = new double [p->get_nz()];
    */
    double ratio, melt, twet, qsat;//, esubcld;
    double meanp, meant, meanq;
    double esubcld_const;

    double *dparms = new double [3];

    for(i=0;i<p->get_nx();i++){
      for(j=0;j<p->get_ny();j++){
	if(conv_type[i*p->get_ny() + j] == 2){
	  /*
	  for(k=0;k<cloud_top_level[j*p->get_ny() + i];k++){
	    ratio[k] = meteorology_convective_cal_ice_ratio(0.5*(*(up_t->get_data(i,j,k)) + *(up_t->get_data(i,j,k))));
	    qsat[k] = meteorology_cal_saturated_mixing_ratio(*(p->get_data(i,j,k)),*(t->get_data(i,j,k)));
	    twet[k] = *(t->get_data(i,j,k)) - (qsat[k] - *(q->get_data(i,j,k)))*(1329.31 + 0.74615*(*(p->get_data(i,j,k)) - 0.85e3) - 40.637*(*(t->get_data(i,j,k)) - 275.));
	    melt[k] = meteorology_Cpd*(twet[k] - 273.16)*(1+0.5*(twet[k] - 273.16))/(11800. * 334000.);
	    esubcld[k] = 0.;
	    if(k<cloud_base_level[j*p->get_ny() + i] && qsat[k]*0.9 > *(q->get_data(i,j,k))){
	      esubcld[k] = 0.05*5.44e-4*(qsat[k]*0.9 - *(q->get_data(i,j,k)))*pow(pow(*(p->get_data(i,j,k))/(*(p->get_data(i,j,0))),0.5)*(*(rainflux->get_data(i,j,k+1)))/(5.09e-3*0.05),0.5777);
	    }
	  }
	  */

	  for(k=cloud_top_level[i*p->get_ny() + j]-1;k>=0;k--){
	    meanp = 0.5*(*(p->get_data(i,j,k)) + *(p->get_data(i,j,k+1)));
	    meant = 0.5*(*(t->get_data(i,j,k)) + *(t->get_data(i,j,k+1)));
	    meanq = 0.5*(*(q->get_data(i,j,k)) + *(q->get_data(i,j,k+1)));
	    ratio = meteorology_convective_cal_ice_ratio(meant);
	    qsat = meteorology_cal_saturated_mixing_ratio(meanp,meant); 
	    twet = meant - (qsat - meanq)*(1329.31 + 0.74615*(meanp - 0.85e3) - 40.637*(meant - 275.));
	    if((meant >= t0 && *(snowflux->get_data(i,j,k+1)) > 0.) || (meant < t0 && *(rainflux->get_data(i,j,k+1)) > 0.)){
	      melt = meteorology_Cpd*(twet - 273.16)*(1+0.5*(twet - 273.16))/(11800. * 334000.);
	    }
	    else{
	      melt = 0.;
	    }
	    /*
	    if(k==cloud_top_level[i*p->get_ny() + j]-1){
	      std::cout << "Precipitation calculation at cloud top: " << meanp << " " << meant << " " << meanq << " " << ratio << " " << qsat << " " << twet << " " << melt << std::endl;
	    }
	    */
	    if(k<cloud_base_level[i*p->get_ny() + j] && qsat*0.9 > meanq){
	      esubcld_const = 0.05*5.44e-4*(qsat*0.9 - meanq)*pow(pow(meanp/(*(p->get_data(i,j,0))),0.5)/(5.09e-3*0.05),26./45.)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0;

	      dparms[0] = *(rainflux->get_data(i,j,k+1))+(0.5*(fallout[(i*p->get_ny()+j)*p->get_nz()+k]+fallout[(i*p->get_ny()+j)*p->get_nz()+k+1])*ratio + melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0;
	      dparms[1] = *(rainflux->get_data(i,j,k+1));
	      dparms[2] = esubcld_const;

	      error = numerical_schemes_false_position_method(100,0.,*(rainflux->get_data(i,j,k+1))+(0.5*(fallout[(i*p->get_ny()+j)*p->get_nz()+k]+fallout[(i*p->get_ny()+j)*p->get_nz()+k+1])*ratio + melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0,*(rainflux->get_data(i,j,k+1)),0.001,dparms,NULL,cal_rainsnowflux_funct,*(rainflux->get_data(i,j,k)));

	      dparms[0] = *(snowflux->get_data(i,j,k+1))+(0.5*(fallout[(i*p->get_ny()+j)*p->get_nz()+k]+fallout[(i*p->get_ny()+j)*p->get_nz()+k+1])*(1.-ratio) - melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0;
	      dparms[1] = *(snowflux->get_data(i,j,k+1));
	      dparms[2] = esubcld_const;

	      error = numerical_schemes_false_position_method(100,0.,*(snowflux->get_data(i,j,k+1))+(0.5*(fallout[(i*p->get_ny()+j)*p->get_nz()+k]+fallout[(i*p->get_ny()+j)*p->get_nz()+k+1])*(1.-ratio) - melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0,*(snowflux->get_data(i,j,k+1)),0.001,dparms,NULL,cal_rainsnowflux_funct,*(snowflux->get_data(i,j,k)));
	    }
	    else{
	      *(rainflux->get_data(i,j,k)) = *(rainflux->get_data(i,j,k+1)) + (fallout[(i*p->get_ny()+j)*p->get_nz()+k]*ratio + melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0;
	      *(snowflux->get_data(i,j,k)) = *(snowflux->get_data(i,j,k+1)) + (fallout[(i*p->get_ny()+j)*p->get_nz()+k]*(1.-ratio) - melt)*(*(p->get_data(i,j,k)) - *(p->get_data(i,j,k+1)))*100./meteorology_g0;
	    }
	  }
	}
      }
    }

    delete [] dparms;
    /*
    delete [] ratio;
    delete [] melt;
    delete [] twet;
    delete [] esubcld;
    delete [] qsat;
    */
    return error;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_convective_scheme_ec_cal_cloudcontent(const grid_data_field* p,const grid_data_field* sshf,const grid_data_field* slhf,const grid_data_field* blh,const grid_data_field* t,const grid_data_field* q,const grid_data_field* z,const grid_data_field* qc,const grid_data_field* qr,const grid_data_field* up_t,const grid_data_field* up_q,const grid_data_field* up_qc,const grid_data_field* up_qr,const grid_data_field* dn_t,const grid_data_field* dn_q,const grid_data_field* rainflux,const grid_data_field* snowflux,const grid_data_field* cloud_base,const grid_data_field* cloud_top,bool gpu_mode){
    if(grid_data_field_check_grid_inconsistence(p,t) ||
       grid_data_field_check_grid_inconsistence(p,q) ||
       grid_data_field_check_grid_inconsistence(p,qc) ||
       grid_data_field_check_grid_inconsistence(p,qr) ||
       grid_data_field_check_grid_inconsistence(p,sshf) ||
       grid_data_field_check_grid_inconsistence(p,slhf) ||
       grid_data_field_check_grid_inconsistence(p,blh) ||
       grid_data_field_check_grid_inconsistence(p,z) ||
       grid_data_field_check_grid_inconsistence(p,up_t) ||
       grid_data_field_check_grid_inconsistence(p,up_q) ||
       grid_data_field_check_grid_inconsistence(p,up_qc) ||
       grid_data_field_check_grid_inconsistence(p,up_qr) ||
       grid_data_field_check_grid_inconsistence(p,dn_t) ||
       grid_data_field_check_grid_inconsistence(p,dn_q) ||
       grid_data_field_check_grid_inconsistence(p,rainflux) ||
       grid_data_field_check_grid_inconsistence(p,snowflux)){
      return _ERRORCODE_DATAINCONSISTENCE;
    }
    ###CPP### gpu_mode = false;

    int *conv_type = new int [p->get_nx()*p->get_ny()];
    //double *cloud_base = new double [p->get_nx()*p->get_ny()];
    double *cloud_base_w = new double [p->get_nx()*p->get_ny()];
    double *cloud_base_s = new double [p->get_nx()*p->get_ny()];
    double *cloud_base_q = new double [p->get_nx()*p->get_ny()];
    double *cloud_base_qc = new double [p->get_nx()*p->get_ny()];
    double *fallout = new double [p->get_nx()*p->get_ny()*p->get_nz()];
    double *edown = new double [p->get_nx()*p->get_ny()*p->get_nz()];
    int *cloud_base_level = new int [p->get_nx()*p->get_ny()];
    int *cloud_top_level = new int [p->get_nx()*p->get_ny()];

    int i,j;
    for(i=0;i<p->get_nx()*p->get_ny();i++){
      cloud_base_level[i] = 0;
      cloud_top_level[i] = 0;
      cloud_base_w[i] = 0.;
      cloud_base_s[i] = 0.;
      cloud_base_q[i] = 0.;
      cloud_base_qc[i] = 0.;
    }

    clock_t times[2];
    times[0] = clock();

    meteorology_convective_scheme_ec_cal_conv_type(p,t,q,qc,qr,z,sshf,slhf,blh,conv_type,cloud_base_level,cloud_top_level,cloud_base_w,cloud_base_s,cloud_base_q,cloud_base_qc,gpu_mode);

    times[1] = clock();
    std::cout << "Done determining convection type. " << cal_sec_between(times[0],times[1]) << "s" << std::endl;
    times[0] = times[1];

    std::ofstream fout;
    /*
    fout.open("cloud_base_w.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -1. << " ";
	}
	else{
	  fout <<  cloud_base_w[j*p->get_ny() + i] << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();
    
    fout.open("cloud_base_t.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -1. << " ";
	}
	else{
	  fout <<  (cloud_base_s[j*p->get_ny() + i] - meteorology_g0*(*(z->get_data(j,i,cloud_base_level[j*p->get_ny() + i]))))/meteorology_Cpd << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();

    fout.open("cloud_base_z.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -1. << " ";
	}
	else{
	  fout <<  *(z->get_data(j,i,cloud_base_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();
*/
    fout.open("cloud_top.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -10. << " ";
	}
	else{
	  fout <<  *(p->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();
/*
    fout.open("cloud_thick.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -10. << " ";
	}
	else{
	  fout <<  *(p->get_data(j,i,cloud_base_level[j*p->get_ny() + i])) - *(p->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();

    fout.open("cloud_top_temperature.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << 300. << " ";
	}
	else{
	  fout <<  *(t->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();
*/
    //Calculation of cloud base mass flux based on closure assumption. to be implemented
    double *cloud_base_mf = new double [p->get_nx()*p->get_ny()];

    for(i=0;i<p->get_nx()*p->get_ny();i++){
      cloud_base_mf[i] = 1.;
    }

    //updraft calculation
    std::cout << "Begin updraft calculation." << endl;
    meteorology_convective_scheme_ec_updraft_calculation(p,z,t,q,qc,qr,conv_type,cloud_base_level,cloud_top_level,cloud_base_mf,cloud_base_w,cloud_base_s,cloud_base_q,cloud_base_qc,up_t,up_q,up_qc,up_qr,fallout);
    times[1] = clock();
    std::cout << "Done updraft calculation. " << cal_sec_between(times[0],times[1]) << "s" << std::endl;
    times[0] = times[1];
    meteorology_convective_scheme_ec_downdraft_calculation(p,z,t,q,qc,qr,conv_type,cloud_base_level,cloud_top_level,cloud_base_mf,fallout,dn_t,dn_q,edown);
    times[1] = clock();
    std::cout << "Done downdraft calculation. " << cal_sec_between(times[0],times[1]) << "s" << std::endl;
    times[0] = times[1];
    meteorology_convective_scheme_ec_rainflux_calculation(p,t,q,up_t,conv_type,cloud_base_level,cloud_top_level,fallout,edown,rainflux,snowflux);
    times[1] = clock();
    std::cout << "Done rainflux calculation. " << cal_sec_between(times[0],times[1]) << "s" << std::endl;
    times[0] = times[1];

    for(i=0;i<cloud_base->get_ny();i++){
      for(j=0;j<cloud_base->get_nx();j++){
	if(conv_type[j*p->get_ny() + i] == 0){
	  *(cloud_base->get_data(j,i,0)) = -1.;
	  *(cloud_top->get_data(j,i,0)) = -1.;
	}
	else{
	  *(cloud_base->get_data(j,i,0)) = *(p->get_data(j,i,cloud_base_level[j*p->get_ny() + i]));
	  *(cloud_top->get_data(j,i,0)) = *(p->get_data(j,i,cloud_top_level[j*p->get_ny() + i]));
	}
      }
    }

/*
    fout.open("cloud_top.full_calculation.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] == 0){
	  fout << -10. << " ";
	}
	else{
	  fout <<  *(p->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();

    fout.open("cloud_thick.full_calculation.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] != 2){
	  fout << -10. << " ";
	}
	else{
	  fout <<  *(p->get_data(j,i,cloud_base_level[j*p->get_ny() + i])) - *(p->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();

    fout.open("cloud_top_temperature.full_calculation.out");
    for(i=0;i<p->get_ny();i++){
      for(j=0;j<p->get_nx();j++){
	//fout << conv_type[j*p->get_ny() + i] << " ";
	if(conv_type[j*p->get_ny() + i] != 2){
	  fout << 300 << " ";
	}
	else{
	  fout <<  *(t->get_data(j,i,cloud_top_level[j*p->get_ny() + i])) << " ";
	  //fout << (*(p->get_data(j,i,0))) - cloud_base[j*p->get_ny() + i] << " ";
	}
	
      }
      fout << endl;
    }
    fout.close();
*/

    delete [] conv_type;
    delete [] cloud_base_level;
    delete [] cloud_base_w;
    delete [] cloud_base_s;
    delete [] cloud_base_q;
    delete [] cloud_base_qc;
    delete [] fallout;
    delete [] edown;
    //delete [] cloud_base;
    
    return _ERRORCODE_NOERROR;
  }

  ###CPP### ###CUDA### ###HOST### int meteorology_convert_ec_mdl2plv(timed_grid_data *mdl_data,const grid_data_field* p,timed_grid_data *plv_data,int nplv,double *plv,double missing_value){
    plv_data->destroy();
    plv_data->create(mdl_data->get_num_data_time(),grid_data_allocation(mdl_data->get_data_grid()[0]->get_grid_code()));
    plv_data->set_data_time(mdl_data->get_data_time());

    int i,j,k,t,m,n;
    grid_data_field* work_p = new grid_data_field;

    for(t=0;t<mdl_data->get_num_data_time();t++){
      int ndim = mdl_data->get_data_grid()[t]->get_ndim();
      int nx = mdl_data->get_data_grid()[t]->get_nx();
      int ny = mdl_data->get_data_grid()[t]->get_ny();
      int nmdlz = mdl_data->get_data_grid()[t]->get_nz();

      plv_data->get_data_grid()[t]->create(nx,ny,nplv,ndim);

      plv_data->get_data_grid()[t]->set_x(mdl_data->get_data_grid()[t]->get_x());
      plv_data->get_data_grid()[t]->set_y(mdl_data->get_data_grid()[t]->get_y());
      plv_data->get_data_grid()[t]->set_z(plv);

      work_p->set(mdl_data->get_data_grid()[t],p->get_dim_index());
      /*
      if(t==0){
	for(k=0;k<mdl_data->get_data_grid()[t]->get_nz();k++){
	  std::cout << *(work_p->get_data(0,0,k)) << " ";
	}
	std::cout << std::endl;
      }
      */
      for(k=0;k<nplv;k++){
	for(i=0;i<nx;i++){
	  for(j=0;j<ny;j++){
	    if(plv[k] > *(work_p->get_data(i,j,0))){
	      for(n=0;n<ndim;n++){
		plv_data->get_data_grid()[t]->get_data(i,j,k)[n] = missing_value;
	      }
	    }
	    else if(plv[k] < *(work_p->get_data(i,j,nmdlz-1))){
	      for(n=0;n<ndim;n++){
		plv_data->get_data_grid()[t]->get_data(i,j,k)[n] = missing_value;
	      }
	    }
	    else{
	      for(m=1;m<nmdlz;m++){
		if(*(work_p->get_data(i,j,m)) < plv[k]){
		  break;
		}
	      }
	      /*
	      std::cout << "Have data ";
	      std::cout << m << std::endl;
	      */
	      for(n=0;n<ndim;n++){
		plv_data->get_data_grid()[t]->get_data(i,j,k)[n] = mdl_data->get_data_grid()[t]->get_data(i,j,m-1)[n] + (log(plv[k]) - log(*(work_p->get_data(i,j,m-1))))/(log(*(work_p->get_data(i,j,m))) - log(*(work_p->get_data(i,j,m-1))))*(mdl_data->get_data_grid()[t]->get_data(i,j,m)[n] - mdl_data->get_data_grid()[t]->get_data(i,j,m-1)[n]);
	      }
	    }
	  }
	}
      }
    }
	delete work_p;

    return _ERRORCODE_NOERROR;
  }

}
